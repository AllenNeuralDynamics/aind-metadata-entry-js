{"version":3,"file":"core.cjs.production.min.js","sources":["../src/components/IconButton.js","../src/components/AddButton.js","../src/types.js","../src/validate.js","../src/utils.js","../src/components/fields/ArrayField.js","../src/components/fields/BooleanField.js","../src/components/fields/MultiSchemaField.js","../src/components/fields/NumberField.js","../src/components/fields/ObjectField.js","../src/components/fields/SchemaField.js","../src/components/fields/StringField.js","../src/components/fields/index.js","../src/components/fields/DescriptionField.js","../src/components/fields/TitleField.js","../src/components/fields/NullField.js","../src/components/fields/UnsupportedField.js","../src/components/widgets/AltDateWidget.js","../src/components/widgets/AltDateTimeWidget.js","../src/components/widgets/BaseInput.js","../src/components/widgets/CheckboxWidget.js","../src/components/widgets/CheckboxesWidget.js","../src/components/widgets/FileWidget.js","../src/components/widgets/RadioWidget.js","../src/components/widgets/SelectWidget.js","../src/components/widgets/TextareaWidget.js","../src/components/widgets/index.js","../src/components/widgets/PasswordWidget.js","../src/components/widgets/UpDownWidget.js","../src/components/widgets/RangeWidget.js","../src/components/widgets/TextWidget.js","../src/components/widgets/DateWidget.js","../src/components/widgets/DateTimeWidget.js","../src/components/widgets/EmailWidget.js","../src/components/widgets/URLWidget.js","../src/components/widgets/HiddenWidget.js","../src/components/widgets/ColorWidget.js","../src/components/widgets/SubmitButton.js","../src/defaultRegistry.js","../src/components/Form.js","../src/withTheme.js","../src/components/ErrorList.js","../src/index.js"],"sourcesContent":["import React from \"react\";\n\nexport default function IconButton(props) {\n  const { type = \"default\", icon, className, ...otherProps } = props;\n  return (\n    <button\n      type=\"button\"\n      className={`btn btn-${type} ${className}`}\n      {...otherProps}>\n      <i className={`glyphicon glyphicon-${icon}`} />\n    </button>\n  );\n}\n","import React from \"react\";\nimport IconButton from \"./IconButton\";\n\nexport default function AddButton({ className, onClick, disabled }) {\n  return (\n    <div className=\"row\">\n      <p className={`col-xs-3 col-xs-offset-9 text-right ${className}`}>\n        <IconButton\n          type=\"info\"\n          icon=\"plus\"\n          className=\"btn-add col-xs-12\"\n          aria-label=\"Add\"\n          tabIndex=\"0\"\n          onClick={onClick}\n          disabled={disabled}\n        />\n      </p>\n    </div>\n  );\n}\n","import PropTypes from \"prop-types\";\n\nexport const registry = PropTypes.shape({\n  ArrayFieldTemplate: PropTypes.elementType,\n  FieldTemplate: PropTypes.elementType,\n  ObjectFieldTemplate: PropTypes.elementType,\n  definitions: PropTypes.object.isRequired,\n  rootSchema: PropTypes.object,\n  fields: PropTypes.objectOf(PropTypes.elementType).isRequired,\n  formContext: PropTypes.object.isRequired,\n  widgets: PropTypes.objectOf(\n    PropTypes.oneOfType([PropTypes.func, PropTypes.object])\n  ).isRequired,\n});\n\nexport const fieldProps = {\n  autofocus: PropTypes.bool,\n  disabled: PropTypes.bool,\n  errorSchema: PropTypes.object,\n  formData: PropTypes.any,\n  idSchema: PropTypes.object,\n  onBlur: PropTypes.func,\n  onChange: PropTypes.func.isRequired,\n  onFocus: PropTypes.func,\n  rawErrors: PropTypes.arrayOf(PropTypes.string),\n  readonly: PropTypes.bool,\n  registry: registry.isRequired,\n  required: PropTypes.bool,\n  schema: PropTypes.object.isRequired,\n  uiSchema: PropTypes.shape({\n    \"ui:options\": PropTypes.shape({\n      addable: PropTypes.bool,\n      orderable: PropTypes.bool,\n      removable: PropTypes.bool,\n    }),\n  }),\n};\n","import toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nlet ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\n\nlet formerCustomFormats = null;\nlet formerMetaSchema = null;\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  const ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\",\n  });\n\n  // add custom formats\n  ajv.addFormat(\n    \"data-url\",\n    /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/\n  );\n  ajv.addFormat(\n    \"color\",\n    /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/\n  );\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n  return errors.reduce((errorSchema, error) => {\n    const { property, message } = error;\n    const path = toPath(property);\n    let parent = errorSchema;\n\n    // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    for (const segment of path.slice(0)) {\n      if (!(segment in parent)) {\n        parent[segment] = {};\n      }\n      parent = parent[segment];\n    }\n\n    if (Array.isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema, fieldName = \"root\") {\n  // XXX: We should transform fieldName as a full field path string.\n  let errorList = [];\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema.__errors.map(stack => {\n        return {\n          stack: `${fieldName}: ${stack}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  const handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError(message) {\n      this.__errors.push(message);\n    },\n  };\n  if (isObject(formData)) {\n    return Object.keys(formData).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formData[key]) };\n    }, handler);\n  }\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return { ...acc, [key]: errorHandler[key] };\n    }\n    return { ...acc, [key]: unwrapErrorHandler(errorHandler[key]) };\n  }, {});\n}\n\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\nfunction transformAjvErrors(errors = []) {\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(e => {\n    const { dataPath, keyword, message, params, schemaPath } = e;\n    let property = `${dataPath}`;\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack: `${property} ${message}`.trim(),\n      schemaPath,\n    };\n  });\n}\n\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\nexport default function validateFormData(\n  formData,\n  schema,\n  customValidate,\n  transformErrors,\n  additionalMetaSchemas = [],\n  customFormats = {}\n) {\n  // Include form data with undefined values, which is required for validation.\n  const rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n\n  const newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  const newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  }\n\n  // add more schemas to validate against\n  if (\n    additionalMetaSchemas &&\n    newMetaSchemas &&\n    Array.isArray(additionalMetaSchemas)\n  ) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  }\n\n  // add more custom formats to validate against\n  if (customFormats && newFormats && isObject(customFormats)) {\n    Object.keys(customFormats).forEach(formatName => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n\n    formerCustomFormats = customFormats;\n  }\n\n  let validationError = null;\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  let errors = transformAjvErrors(ajv.errors);\n  // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n\n  const noProperMetaSchema =\n    validationError &&\n    validationError.message &&\n    typeof validationError.message === \"string\" &&\n    validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [\n      ...errors,\n      {\n        stack: validationError.message,\n      },\n    ];\n  }\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  let errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = {\n      ...errorSchema,\n      ...{\n        $schema: {\n          __errors: [validationError.message],\n        },\n      },\n    };\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return { errors, errorSchema };\n  }\n\n  const errorHandler = customValidate(formData, createErrorHandler(formData));\n  const userErrorSchema = unwrapErrorHandler(errorHandler);\n  const newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true);\n  // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n  const newErrors = toErrorList(newErrorSchema);\n\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema,\n  };\n}\n\n/**\n * Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n * This is used in isValid to make references to the rootSchema\n */\nexport function withIdRefPrefix(schemaNode) {\n  let obj = schemaNode;\n  if (schemaNode.constructor === Object) {\n    obj = { ...schemaNode };\n    for (const key in obj) {\n      const value = obj[key];\n      if (\n        key === \"$ref\" &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        obj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        obj[key] = withIdRefPrefix(value);\n      }\n    }\n  } else if (Array.isArray(schemaNode)) {\n    obj = [...schemaNode];\n    for (var i = 0; i < obj.length; i++) {\n      obj[i] = withIdRefPrefix(obj[i]);\n    }\n  }\n  return obj;\n}\n\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\nexport function isValid(schema, data, rootSchema) {\n  try {\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n    // then rewrite the schema ref's to point to the rootSchema\n    // this accounts for the case where schema have references to models\n    // that lives in the rootSchema but not in the schema in question.\n    return ajv\n      .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n      .validate(withIdRefPrefix(schema), data);\n  } catch (e) {\n    return false;\n  } finally {\n    // make sure we remove the rootSchema from the global ajv instance\n    ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n  }\n}\n","import React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js-pure/features/array/fill\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nimport validateFormData, { isValid } from \"./validate\";\n\nexport const ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\n\nconst widgetMap = {\n  boolean: {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\",\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\",\n  },\n};\n\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable } = getUiOptions(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n\n/* Gets the type of a given schema. */\nexport function getSchemaType(schema) {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(type => type !== \"null\");\n  }\n\n  return type;\n}\n\nexport function getWidget(schema, widget, registeredWidgets = {}) {\n  const type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      const defaultOptions =\n        (Widget.defaultProps && Widget.defaultProps.options) || {};\n      Widget.MergedWidget = ({ options = {}, ...props }) => (\n        <Widget options={{ ...defaultOptions, ...options }} {...props} />\n      );\n    }\n    return Widget.MergedWidget;\n  }\n\n  if (\n    typeof widget === \"function\" ||\n    ReactIs.isForwardRef(React.createElement(widget)) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(`No widget for type \"${type}\"`);\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(`No widget \"${widget}\" for type \"${type}\"`);\n}\n\nexport function hasWidget(schema, widget, registeredWidgets = {}) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (\n      e.message &&\n      (e.message.startsWith(\"No widget\") ||\n        e.message.startsWith(\"Unsupported widget\"))\n    ) {\n      return false;\n    }\n    throw e;\n  }\n}\n\nfunction computeDefaults(\n  _schema,\n  parentDefaults,\n  rootSchema,\n  rawFormData = {},\n  includeUndefinedValues = false\n) {\n  let schema = isObject(_schema) ? _schema : {};\n  const formData = isObject(rawFormData) ? rawFormData : {};\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults = parentDefaults;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema.default);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema.default;\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    const refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(\n      refSchema,\n      defaults,\n      rootSchema,\n      formData,\n      includeUndefinedValues\n    );\n  } else if (\"dependencies\" in schema) {\n    const resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(\n      resolvedSchema,\n      defaults,\n      rootSchema,\n      formData,\n      includeUndefinedValues\n    );\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map((itemSchema, idx) =>\n      computeDefaults(\n        itemSchema,\n        Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rootSchema,\n        formData,\n        includeUndefinedValues\n      )\n    );\n  } else if (\"oneOf\" in schema) {\n    schema =\n      schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema =\n      schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  }\n\n  // Not defaults defined for this node, fallback to generic typed ones.\n  if (typeof defaults === \"undefined\") {\n    defaults = schema.default;\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce((acc, key) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        let computedDefault = computeDefaults(\n          schema.properties[key],\n          (defaults || {})[key],\n          rootSchema,\n          (formData || {})[key],\n          includeUndefinedValues\n        );\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          return computeDefaults(\n            schema.items[idx] || schema.additionalItems || {},\n            item,\n            rootSchema\n          );\n        });\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        defaults = rawFormData.map((item, idx) => {\n          return computeDefaults(\n            schema.items,\n            (defaults || {})[idx],\n            rootSchema,\n            item\n          );\n        });\n      }\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          const defaultsLength = defaults ? defaults.length : 0;\n          if (schema.minItems > defaultsLength) {\n            const defaultEntries = defaults || [];\n            // populate the array with the defaults\n            const fillerSchema = Array.isArray(schema.items)\n              ? schema.additionalItems\n              : schema.items;\n            const fillerEntries = fill(\n              new Array(schema.minItems - defaultsLength),\n              computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)\n            );\n            // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n  }\n  return defaults;\n}\n\nexport function getDefaultFormState(\n  _schema,\n  formData,\n  rootSchema = {},\n  includeUndefinedValues = false\n) {\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n  const schema = retrieveSchema(_schema, rootSchema, formData);\n  const defaults = computeDefaults(\n    schema,\n    _schema.default,\n    rootSchema,\n    formData,\n    includeUndefinedValues\n  );\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  if (isObject(formData) || Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n  return formData || defaults;\n}\n\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (Array.isArray(formData)) {\n    if (!Array.isArray(defaults)) {\n      defaults = [];\n    }\n    return formData.map((value, idx) => {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n      return value;\n    });\n  } else if (isObject(formData)) {\n    const acc = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData).reduce((acc, key) => {\n      acc[key] = mergeDefaultsWithFormData(\n        defaults ? defaults[key] : {},\n        formData[key]\n      );\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\n\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return Object.keys(uiSchema)\n    .filter(key => key.indexOf(\"ui:\") === 0)\n    .reduce((options, key) => {\n      const value = uiSchema[key];\n      if (key === \"ui:widget\" && isObject(value)) {\n        console.warn(\n          \"Setting options via ui:widget object is deprecated, use ui:options instead\"\n        );\n        return {\n          ...options,\n          ...(value.options || {}),\n          widget: value.component,\n        };\n      }\n      if (key === \"ui:options\" && isObject(value)) {\n        return { ...options, ...value };\n      }\n      return { ...options, [key.substring(3)]: value };\n    }, {});\n}\n\nexport function getSubmitButtonOptions(uiSchema) {\n  const uiOptions = getUiOptions(uiSchema);\n  const defaultOptions = {\n    props: {\n      disabled: false,\n    },\n    submitText: \"Submit\",\n    norender: false,\n  };\n  if (uiOptions && uiOptions[\"submitButtonOptions\"]) {\n    return Object.assign({}, defaultOptions, uiOptions[\"submitButtonOptions\"]);\n  }\n\n  return defaultOptions;\n}\n\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  const uiOptions = getUiOptions(uiSchema);\n  let { label: displayLabel = true } = uiOptions;\n  const schemaType = getSchemaType(schema);\n\n  if (schemaType === \"array\") {\n    displayLabel =\n      isMultiSelect(schema, rootSchema) ||\n      isFilesArray(schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === \"object\") {\n    displayLabel = false;\n  }\n  if (schemaType === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n\nexport function mergeObjects(obj1, obj2, concatArrays = false) {\n  // Recursively merge deeply nested objects.\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n  const n = Number(value);\n  const valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\n\nexport function orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = arr =>\n    arr.reduce((prev, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = arr =>\n    arr.length > 1\n      ? `properties '${arr.join(\"', '\")}'`\n      : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter(\n    prop => prop === \"*\" || propertyHash[prop]\n  );\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter(prop => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf(\"*\");\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\n        `uiSchema order list does not contain ${errorPropList(rest)}`\n      );\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\nexport function isConstant(schema) {\n  return (\n    (Array.isArray(schema.enum) && schema.enum.length === 1) ||\n    schema.hasOwnProperty(\"const\")\n  );\n}\n\nexport function toConstant(schema) {\n  if (Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema.const;\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\n\nexport function isSelect(_schema, rootSchema = {}) {\n  const schema = retrieveSchema(_schema, rootSchema);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  } else if (Array.isArray(altSchemas)) {\n    return altSchemas.every(altSchemas => isConstant(altSchemas));\n  }\n  return false;\n}\n\nexport function isMultiSelect(schema, rootSchema = {}) {\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n  return isSelect(schema.items, rootSchema);\n}\n\nexport function isFilesArray(schema, uiSchema, rootSchema = {}) {\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    const itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n  return false;\n}\n\nexport function isFixedItems(schema) {\n  return (\n    Array.isArray(schema.items) &&\n    schema.items.length > 0 &&\n    schema.items.every(item => isObject(item))\n  );\n}\n\nexport function isCustomWidget(uiSchema) {\n  return (\n    // TODO: Remove the `&& uiSchema[\"ui:widget\"] !== \"hidden\"` once we support hidden widgets for arrays.\n    // https://react-jsonschema-form.readthedocs.io/en/latest/usage/widgets/#hidden-widgets\n    \"widget\" in getUiOptions(uiSchema) &&\n    getUiOptions(uiSchema)[\"widget\"] !== \"hidden\"\n  );\n}\n\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n  return isObject(schema.additionalItems);\n}\n\nexport function optionsList(schema) {\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schema.enumNames && schema.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  } else {\n    const altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(schema => {\n      const value = toConstant(schema);\n      const label = schema.title || String(value);\n      return {\n        schema,\n        label,\n        value,\n      };\n    });\n  }\n}\n\nexport function findSchemaDefinition($ref, rootSchema = {}) {\n  const origRef = $ref;\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${origRef}.`);\n  }\n  const current = jsonpointer.get(rootSchema, $ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${origRef}.`);\n  }\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n  return current;\n}\n\n// In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\nexport const guessType = function guessType(value) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (typeof value === \"object\") {\n    return \"object\";\n  }\n  // Default to string if we can't figure it out\n  return \"string\";\n};\n\n// This function will create new \"properties\" items for each key in our formData\nexport function stubExistingAdditionalProperties(\n  schema,\n  rootSchema = {},\n  formData = {}\n) {\n  // Clone the schema so we don't ruin the consumer's original\n  schema = {\n    ...schema,\n    properties: { ...schema.properties },\n  };\n\n  // make sure formData is an object\n  formData = isObject(formData) ? formData : {};\n\n  Object.keys(formData).forEach(key => {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties;\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema(\n        { $ref: schema.additionalProperties[\"$ref\"] },\n        rootSchema,\n        formData\n      );\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = { ...schema.additionalProperties };\n    } else {\n      additionalProperties = { type: guessType(formData[key]) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n\n  return schema;\n}\n\n/**\n * Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch with the rest of the schema\n */\nconst resolveCondition = (schema, rootSchema, formData) => {\n  let {\n    if: expression,\n    then,\n    else: otherwise,\n    ...resolvedSchemaLessConditional\n  } = schema;\n\n  const conditionalSchema = isValid(expression, formData, rootSchema)\n    ? then\n    : otherwise;\n\n  if (conditionalSchema) {\n    return retrieveSchema(\n      mergeSchemas(\n        resolvedSchemaLessConditional,\n        retrieveSchema(conditionalSchema, rootSchema, formData)\n      ),\n      rootSchema,\n      formData\n    );\n  } else {\n    return retrieveSchema(resolvedSchemaLessConditional, rootSchema, formData);\n  }\n};\n\n/**\n * Resolves references and dependencies within a schema and its 'allOf' children.\n *\n * Called internally by retrieveSchema.\n */\nexport function resolveSchema(schema, rootSchema = {}, formData = {}) {\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    const resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return {\n      ...schema,\n      allOf: schema.allOf.map(allOfSubschema =>\n        retrieveSchema(allOfSubschema, rootSchema, formData)\n      ),\n    };\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  const $refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchema(\n    { ...$refSchema, ...localSchema },\n    rootSchema,\n    formData\n  );\n}\n\nexport function retrieveSchema(schema, rootSchema = {}, formData = {}) {\n  if (!isObject(schema)) {\n    return {};\n  }\n  let resolvedSchema = resolveSchema(schema, rootSchema, formData);\n\n  if (schema.hasOwnProperty(\"if\")) {\n    return resolveCondition(schema, rootSchema, formData);\n  }\n\n  // For each level of the dependency, we need to recursively determine the appropriate resolved schema given the current state of formData.\n  // Otherwise, nested allOf subschemas will not be correctly displayed.\n  if (resolvedSchema.properties) {\n    const properties = {};\n\n    Object.entries(resolvedSchema.properties).forEach(entries => {\n      const propName = entries[0];\n      const propSchema = entries[1];\n      const rawPropData = formData && formData[propName];\n      const propData = isObject(rawPropData) ? rawPropData : {};\n      const resolvedPropSchema = retrieveSchema(\n        propSchema,\n        rootSchema,\n        propData\n      );\n\n      properties[propName] = resolvedPropSchema;\n\n      if (\n        propSchema !== resolvedPropSchema &&\n        resolvedSchema.properties !== properties\n      ) {\n        resolvedSchema = { ...resolvedSchema, properties };\n      }\n    });\n  }\n\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf({\n        ...resolvedSchema,\n        allOf: resolvedSchema.allOf,\n      });\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n      const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n  const hasAdditionalProperties =\n    resolvedSchema.hasOwnProperty(\"additionalProperties\") &&\n    resolvedSchema.additionalProperties !== false;\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(\n      resolvedSchema,\n      rootSchema,\n      formData\n    );\n  }\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  let { dependencies = {}, ...resolvedSchema } = schema;\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema =\n      resolvedSchema.oneOf[\n        getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)\n      ];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema =\n      resolvedSchema.anyOf[\n        getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)\n      ];\n  }\n  return processDependencies(\n    dependencies,\n    resolvedSchema,\n    rootSchema,\n    formData\n  );\n}\nfunction processDependencies(\n  dependencies,\n  resolvedSchema,\n  rootSchema,\n  formData\n) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (\n      resolvedSchema.properties &&\n      !(dependencyKey in resolvedSchema.properties)\n    ) {\n      continue;\n    }\n    const {\n      [dependencyKey]: dependencyValue,\n      ...remainingDependencies\n    } = dependencies;\n    if (Array.isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(\n        resolvedSchema,\n        rootSchema,\n        formData,\n        dependencyKey,\n        dependencyValue\n      );\n    }\n    return processDependencies(\n      remainingDependencies,\n      resolvedSchema,\n      rootSchema,\n      formData\n    );\n  }\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\nfunction withDependentSchema(\n  schema,\n  rootSchema,\n  formData,\n  dependencyKey,\n  dependencyValue\n) {\n  let { oneOf, ...dependentSchema } = retrieveSchema(\n    dependencyValue,\n    rootSchema,\n    formData\n  );\n  schema = mergeSchemas(schema, dependentSchema);\n  // Since it does not contain oneOf, we return the original schema.\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!Array.isArray(oneOf)) {\n    throw new Error(`invalid: it is some ${typeof oneOf} instead of an array`);\n  }\n  // Resolve $refs inside oneOf.\n  const resolvedOneOf = oneOf.map(subschema =>\n    subschema.hasOwnProperty(\"$ref\")\n      ? resolveReference(subschema, rootSchema, formData)\n      : subschema\n  );\n  return withExactlyOneSubschema(\n    schema,\n    rootSchema,\n    formData,\n    dependencyKey,\n    resolvedOneOf\n  );\n}\n\nfunction withExactlyOneSubschema(\n  schema,\n  rootSchema,\n  formData,\n  dependencyKey,\n  oneOf\n) {\n  const validSubschemas = oneOf.filter(subschema => {\n    if (!subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema = {\n        type: \"object\",\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      };\n      const { errors } = validateFormData(formData, conditionSchema);\n      return errors.length === 0;\n    }\n  });\n  if (validSubschemas.length !== 1) {\n    console.warn(\n      \"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\"\n    );\n    return schema;\n  }\n  const subschema = validSubschemas[0];\n  const {\n    [dependencyKey]: conditionPropertySchema,\n    ...dependentSubschema\n  } = subschema.properties;\n  const dependentSchema = { ...subschema, properties: dependentSubschema };\n  return mergeSchemas(\n    schema,\n    retrieveSchema(dependentSchema, rootSchema, formData)\n  );\n}\n\n// Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\nexport function mergeSchemas(obj1, obj2) {\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") &&\n      key === \"required\" &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b, ca = [], cb = []) {\n  // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (typeof a !== \"object\" || typeof b !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return (\n      a.source === b.source &&\n      a.global === b.global &&\n      a.multiline === b.multiline &&\n      a.lastIndex === b.lastIndex &&\n      a.ignoreCase === b.ignoreCase\n    );\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n    let slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    let ka = Object.keys(a);\n    let kb = Object.keys(b);\n    // don't bother with stack acrobatics if there's nothing there\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    let cal = ca.length;\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n    ca.push(a);\n    cb.push(b);\n\n    ka.sort();\n    kb.sort();\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    let key;\n    for (let k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n      if (!deepEquals(a[key], b[key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n\n    return true;\n  }\n}\n\nexport function shouldRender(comp, nextProps, nextState) {\n  const { props, state } = comp;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n\nexport function toIdSchema(\n  schema,\n  id,\n  rootSchema,\n  formData = {},\n  idPrefix = \"root\",\n  idSeparator = \"_\"\n) {\n  const idSchema = {\n    $id: id || idPrefix,\n  };\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    const _schema = retrieveSchema(schema, rootSchema, formData);\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix, idSeparator);\n  }\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(\n      schema.items,\n      id,\n      rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n  for (const name in schema.properties || {}) {\n    const field = schema.properties[name];\n    const fieldId = idSchema.$id + idSeparator + name;\n    idSchema[name] = toIdSchema(\n      isObject(field) ? field : {},\n      fieldId,\n      rootSchema,\n      // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[name],\n      idPrefix,\n      idSeparator\n    );\n  }\n  return idSchema;\n}\n\nexport function toPathSchema(schema, name = \"\", rootSchema, formData = {}) {\n  const pathSchema = {\n    $name: name.replace(/^\\./, \"\"),\n  };\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    const _schema = retrieveSchema(schema, rootSchema, formData);\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && Array.isArray(formData)) {\n    formData.forEach((element, i) => {\n      pathSchema[i] = toPathSchema(\n        schema.items,\n        `${name}.${i}`,\n        rootSchema,\n        element\n      );\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (const property in schema.properties) {\n      pathSchema[property] = toPathSchema(\n        schema.properties[property],\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        (formData || {})[property]\n      );\n    }\n  }\n  return pathSchema;\n}\n\nexport function parseDateString(dateString, includeTime = true) {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n\nexport function toDateString(\n  { year, month, day, hour = 0, minute = 0, second = 0 },\n  time = true\n) {\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  }\n\n  // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\n\nexport function pad(num, size) {\n  let s = String(num);\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n  return s;\n}\n\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  const splitted = dataURI.split(\",\");\n  // Split params\n  const params = splitted[0].split(\";\");\n  // Get mime-type from params\n  const type = params[0].replace(\"data:\", \"\");\n  // Filter the name property from params\n  const properties = params.filter(param => {\n    return param.split(\"=\")[0] === \"name\";\n  });\n  // Look for the name and use unknown if no name property.\n  let name;\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  const binary = atob(splitted[1]);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  // Create the blob object\n  const blob = new window.Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n\nexport function rangeSpec(schema) {\n  const spec = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n\nexport function getMatchingOption(formData, options, rootSchema) {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map(key => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n\n// Check to see if a schema specifies that a value must be true\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}\n","import AddButton from \"../AddButton\";\nimport IconButton from \"../IconButton\";\nimport React, { Component } from \"react\";\nimport includes from \"core-js-pure/es/array/includes\";\nimport * as types from \"../../types\";\n\nimport {\n  getWidget,\n  getDefaultFormState,\n  getUiOptions,\n  isMultiSelect,\n  isFilesArray,\n  isFixedItems,\n  allowAdditionalItems,\n  isCustomWidget,\n  optionsList,\n  retrieveSchema,\n  toIdSchema,\n} from \"../../utils\";\nimport { nanoid } from \"nanoid\";\n\nfunction ArrayFieldTitle({ TitleField, idSchema, title, required }) {\n  if (!title) {\n    return null;\n  }\n  const id = `${idSchema.$id}__title`;\n  return <TitleField id={id} title={title} required={required} />;\n}\n\nfunction ArrayFieldDescription({ DescriptionField, idSchema, description }) {\n  if (!description) {\n    return null;\n  }\n  const id = `${idSchema.$id}__description`;\n  return <DescriptionField id={id} description={description} />;\n}\n\n// Used in the two templates\nfunction DefaultArrayItem(props) {\n  const btnStyle = {\n    flex: 1,\n    paddingLeft: 6,\n    paddingRight: 6,\n    fontWeight: \"bold\",\n  };\n  return (\n    <div key={props.key} className={props.className}>\n      <div className={props.hasToolbar ? \"col-xs-9\" : \"col-xs-12\"}>\n        {props.children}\n      </div>\n\n      {props.hasToolbar && (\n        <div className=\"col-xs-3 array-item-toolbox\">\n          <div\n            className=\"btn-group\"\n            style={{\n              display: \"flex\",\n              justifyContent: \"space-around\",\n            }}>\n            {(props.hasMoveUp || props.hasMoveDown) && (\n              <IconButton\n                icon=\"arrow-up\"\n                aria-label=\"Move up\"\n                className=\"array-item-move-up\"\n                tabIndex=\"-1\"\n                style={btnStyle}\n                disabled={props.disabled || props.readonly || !props.hasMoveUp}\n                onClick={props.onReorderClick(props.index, props.index - 1)}\n              />\n            )}\n\n            {(props.hasMoveUp || props.hasMoveDown) && (\n              <IconButton\n                icon=\"arrow-down\"\n                className=\"array-item-move-down\"\n                aria-label=\"Move down\"\n                tabIndex=\"-1\"\n                style={btnStyle}\n                disabled={\n                  props.disabled || props.readonly || !props.hasMoveDown\n                }\n                onClick={props.onReorderClick(props.index, props.index + 1)}\n              />\n            )}\n\n            {props.hasRemove && (\n              <IconButton\n                type=\"danger\"\n                icon=\"remove\"\n                aria-label=\"Remove\"\n                className=\"array-item-remove\"\n                tabIndex=\"-1\"\n                style={btnStyle}\n                disabled={props.disabled || props.readonly}\n                onClick={props.onDropIndexClick(props.index)}\n              />\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction DefaultFixedArrayFieldTemplate(props) {\n  return (\n    <fieldset className={props.className} id={props.idSchema.$id}>\n      <ArrayFieldTitle\n        key={`array-field-title-${props.idSchema.$id}`}\n        TitleField={props.TitleField}\n        idSchema={props.idSchema}\n        title={props.uiSchema[\"ui:title\"] || props.title}\n        required={props.required}\n      />\n\n      {(props.uiSchema[\"ui:description\"] || props.schema.description) && (\n        <div\n          className=\"field-description\"\n          key={`field-description-${props.idSchema.$id}`}>\n          {props.uiSchema[\"ui:description\"] || props.schema.description}\n        </div>\n      )}\n\n      <div\n        className=\"row array-item-list\"\n        key={`array-item-list-${props.idSchema.$id}`}>\n        {props.items && props.items.map(DefaultArrayItem)}\n      </div>\n\n      {props.canAdd && (\n        <AddButton\n          className=\"array-item-add\"\n          onClick={props.onAddClick}\n          disabled={props.disabled || props.readonly}\n        />\n      )}\n    </fieldset>\n  );\n}\n\nfunction DefaultNormalArrayFieldTemplate(props) {\n  return (\n    <fieldset className={props.className} id={props.idSchema.$id}>\n      <ArrayFieldTitle\n        key={`array-field-title-${props.idSchema.$id}`}\n        TitleField={props.TitleField}\n        idSchema={props.idSchema}\n        title={props.uiSchema[\"ui:title\"] || props.title}\n        required={props.required}\n      />\n\n      {(props.uiSchema[\"ui:description\"] || props.schema.description) && (\n        <ArrayFieldDescription\n          key={`array-field-description-${props.idSchema.$id}`}\n          DescriptionField={props.DescriptionField}\n          idSchema={props.idSchema}\n          description={\n            props.uiSchema[\"ui:description\"] || props.schema.description\n          }\n        />\n      )}\n\n      <div\n        className=\"row array-item-list\"\n        key={`array-item-list-${props.idSchema.$id}`}>\n        {props.items && props.items.map(p => DefaultArrayItem(p))}\n      </div>\n\n      {props.canAdd && (\n        <AddButton\n          className=\"array-item-add\"\n          onClick={props.onAddClick}\n          disabled={props.disabled || props.readonly}\n        />\n      )}\n    </fieldset>\n  );\n}\n\nfunction generateRowId() {\n  return nanoid();\n}\n\nfunction generateKeyedFormData(formData) {\n  return !Array.isArray(formData)\n    ? []\n    : formData.map(item => {\n        return {\n          key: generateRowId(),\n          item,\n        };\n      });\n}\n\nfunction keyedToPlainFormData(keyedFormData) {\n  return keyedFormData.map(keyedItem => keyedItem.item);\n}\n\nclass ArrayField extends Component {\n  static defaultProps = {\n    uiSchema: {},\n    formData: [],\n    idSchema: {},\n    required: false,\n    disabled: false,\n    readonly: false,\n    autofocus: false,\n  };\n\n  constructor(props) {\n    super(props);\n    const { formData } = props;\n    const keyedFormData = generateKeyedFormData(formData);\n    this.state = {\n      keyedFormData,\n      updatedKeyedFormData: false,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Don't call getDerivedStateFromProps if keyed formdata was just updated.\n    if (prevState.updatedKeyedFormData) {\n      return {\n        updatedKeyedFormData: false,\n      };\n    }\n    const nextFormData = nextProps.formData || [];\n    const previousKeyedFormData = prevState.keyedFormData || [];\n    const newKeyedFormData =\n      nextFormData.length === previousKeyedFormData.length\n        ? previousKeyedFormData.map((previousKeyedFormDatum, index) => {\n            return {\n              key: previousKeyedFormDatum.key,\n              item: nextFormData[index],\n            };\n          })\n        : generateKeyedFormData(nextFormData);\n    return {\n      keyedFormData: newKeyedFormData,\n    };\n  }\n\n  get itemTitle() {\n    const { schema } = this.props;\n    return schema.items.title || schema.items.description || \"Item\";\n  }\n\n  isItemRequired(itemSchema) {\n    if (Array.isArray(itemSchema.type)) {\n      // While we don't yet support composite/nullable jsonschema types, it's\n      // future-proof to check for requirement against these.\n      return !includes(itemSchema.type, \"null\");\n    }\n    // All non-null array item types are inherently required by design\n    return itemSchema.type !== \"null\";\n  }\n\n  canAddItem(formItems) {\n    const { schema, uiSchema } = this.props;\n    let { addable } = getUiOptions(uiSchema);\n    if (addable !== false) {\n      // if ui:options.addable was not explicitly set to false, we can add\n      // another item if we have not exceeded maxItems yet\n      if (schema.maxItems !== undefined) {\n        addable = formItems.length < schema.maxItems;\n      } else {\n        addable = true;\n      }\n    }\n    return addable;\n  }\n\n  _getNewFormDataRow = () => {\n    const { schema, registry } = this.props;\n    const { rootSchema } = registry;\n    let itemSchema = schema.items;\n    if (isFixedItems(schema) && allowAdditionalItems(schema)) {\n      itemSchema = schema.additionalItems;\n    }\n    return getDefaultFormState(itemSchema, undefined, rootSchema);\n  };\n\n  onAddClick = event => {\n    if (event) {\n      event.preventDefault();\n    }\n\n    const { onChange } = this.props;\n    const newKeyedFormDataRow = {\n      key: generateRowId(),\n      item: this._getNewFormDataRow(),\n    };\n    const newKeyedFormData = [...this.state.keyedFormData, newKeyedFormDataRow];\n    this.setState(\n      {\n        keyedFormData: newKeyedFormData,\n        updatedKeyedFormData: true,\n      },\n      () => onChange(keyedToPlainFormData(newKeyedFormData))\n    );\n  };\n\n  onAddIndexClick = index => {\n    return event => {\n      if (event) {\n        event.preventDefault();\n      }\n      const { onChange } = this.props;\n      const newKeyedFormDataRow = {\n        key: generateRowId(),\n        item: this._getNewFormDataRow(),\n      };\n      let newKeyedFormData = [...this.state.keyedFormData];\n      newKeyedFormData.splice(index, 0, newKeyedFormDataRow);\n\n      this.setState(\n        {\n          keyedFormData: newKeyedFormData,\n          updatedKeyedFormData: true,\n        },\n        () => onChange(keyedToPlainFormData(newKeyedFormData))\n      );\n    };\n  };\n\n  onDropIndexClick = index => {\n    return event => {\n      if (event) {\n        event.preventDefault();\n      }\n      const { onChange } = this.props;\n      const { keyedFormData } = this.state;\n      // refs #195: revalidate to ensure properly reindexing errors\n      let newErrorSchema;\n      if (this.props.errorSchema) {\n        newErrorSchema = {};\n        const errorSchema = this.props.errorSchema;\n        for (let i in errorSchema) {\n          i = parseInt(i);\n          if (i < index) {\n            newErrorSchema[i] = errorSchema[i];\n          } else if (i > index) {\n            newErrorSchema[i - 1] = errorSchema[i];\n          }\n        }\n      }\n      const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);\n      this.setState(\n        {\n          keyedFormData: newKeyedFormData,\n          updatedKeyedFormData: true,\n        },\n        () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema)\n      );\n    };\n  };\n\n  onReorderClick = (index, newIndex) => {\n    return event => {\n      if (event) {\n        event.preventDefault();\n        event.target.blur();\n      }\n      const { onChange } = this.props;\n      let newErrorSchema;\n      if (this.props.errorSchema) {\n        newErrorSchema = {};\n        const errorSchema = this.props.errorSchema;\n        for (let i in errorSchema) {\n          if (i == index) {\n            newErrorSchema[newIndex] = errorSchema[index];\n          } else if (i == newIndex) {\n            newErrorSchema[index] = errorSchema[newIndex];\n          } else {\n            newErrorSchema[i] = errorSchema[i];\n          }\n        }\n      }\n\n      const { keyedFormData } = this.state;\n      function reOrderArray() {\n        // Copy item\n        let _newKeyedFormData = keyedFormData.slice();\n\n        // Moves item from index to newIndex\n        _newKeyedFormData.splice(index, 1);\n        _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);\n\n        return _newKeyedFormData;\n      }\n      const newKeyedFormData = reOrderArray();\n      this.setState(\n        {\n          keyedFormData: newKeyedFormData,\n        },\n        () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema)\n      );\n    };\n  };\n\n  onChangeForIndex = index => {\n    return (value, errorSchema) => {\n      const { formData, onChange } = this.props;\n      const newFormData = formData.map((item, i) => {\n        // We need to treat undefined items as nulls to have validation.\n        // See https://github.com/tdegrunt/jsonschema/issues/206\n        const jsonValue = typeof value === \"undefined\" ? null : value;\n        return index === i ? jsonValue : item;\n      });\n      onChange(\n        newFormData,\n        errorSchema &&\n          this.props.errorSchema && {\n            ...this.props.errorSchema,\n            [index]: errorSchema,\n          }\n      );\n    };\n  };\n\n  onSelectChange = value => {\n    this.props.onChange(value);\n  };\n\n  render() {\n    const { schema, uiSchema, idSchema, registry } = this.props;\n    const { rootSchema } = registry;\n    if (!schema.hasOwnProperty(\"items\")) {\n      const { fields } = registry;\n      const { UnsupportedField } = fields;\n\n      return (\n        <UnsupportedField\n          schema={schema}\n          idSchema={idSchema}\n          reason=\"Missing items definition\"\n        />\n      );\n    }\n    if (isMultiSelect(schema, rootSchema)) {\n      // If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.\n      return this.renderMultiSelect();\n    }\n    if (isCustomWidget(uiSchema)) {\n      return this.renderCustomWidget();\n    }\n    if (isFixedItems(schema)) {\n      return this.renderFixedArray();\n    }\n    if (isFilesArray(schema, uiSchema, rootSchema)) {\n      return this.renderFiles();\n    }\n    return this.renderNormalArray();\n  }\n\n  renderNormalArray() {\n    const {\n      schema,\n      uiSchema,\n      errorSchema,\n      idSchema,\n      name,\n      required,\n      disabled,\n      readonly,\n      hideError,\n      autofocus,\n      registry,\n      onBlur,\n      onFocus,\n      idPrefix,\n      idSeparator = \"_\",\n      rawErrors,\n    } = this.props;\n    const title = schema.title === undefined ? name : schema.title;\n    const { ArrayFieldTemplate, rootSchema, fields, formContext } = registry;\n    const { TitleField, DescriptionField } = fields;\n    const itemsSchema = retrieveSchema(schema.items, rootSchema);\n    const formData = keyedToPlainFormData(this.state.keyedFormData);\n    const arrayProps = {\n      canAdd: this.canAddItem(formData),\n      items: this.state.keyedFormData.map((keyedItem, index) => {\n        const { key, item } = keyedItem;\n        const itemSchema = retrieveSchema(schema.items, rootSchema, item);\n        const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\n        const itemIdSchema = toIdSchema(\n          itemSchema,\n          itemIdPrefix,\n          rootSchema,\n          item,\n          idPrefix,\n          idSeparator\n        );\n        return this.renderArrayFieldItem({\n          key,\n          index,\n          canMoveUp: index > 0,\n          canMoveDown: index < formData.length - 1,\n          itemSchema: itemSchema,\n          itemIdSchema,\n          itemErrorSchema,\n          itemData: item,\n          itemUiSchema: uiSchema.items,\n          autofocus: autofocus && index === 0,\n          onBlur,\n          onFocus,\n        });\n      }),\n      className: `field field-array field-array-of-${itemsSchema.type}`,\n      DescriptionField,\n      disabled,\n      idSchema,\n      uiSchema,\n      onAddClick: this.onAddClick,\n      readonly,\n      hideError,\n      required,\n      schema,\n      title,\n      TitleField,\n      formContext,\n      formData,\n      rawErrors,\n      registry,\n    };\n\n    // Check if a custom render function was passed in\n    const Component =\n      uiSchema[\"ui:ArrayFieldTemplate\"] ||\n      ArrayFieldTemplate ||\n      DefaultNormalArrayFieldTemplate;\n    return <Component {...arrayProps} />;\n  }\n\n  renderCustomWidget() {\n    const {\n      schema,\n      idSchema,\n      uiSchema,\n      disabled,\n      readonly,\n      hideError,\n      required,\n      placeholder,\n      autofocus,\n      onBlur,\n      onFocus,\n      formData: items,\n      registry,\n      rawErrors,\n      name,\n    } = this.props;\n    const { widgets, formContext } = registry;\n    const title = schema.title || name;\n\n    const { widget, ...options } = {\n      ...getUiOptions(uiSchema),\n    };\n    const Widget = getWidget(schema, widget, widgets);\n    return (\n      <Widget\n        id={idSchema && idSchema.$id}\n        multiple\n        onChange={this.onSelectChange}\n        onBlur={onBlur}\n        onFocus={onFocus}\n        options={options}\n        schema={schema}\n        uiSchema={uiSchema}\n        registry={registry}\n        value={items}\n        disabled={disabled}\n        readonly={readonly}\n        hideError={hideError}\n        required={required}\n        label={title}\n        placeholder={placeholder}\n        formContext={formContext}\n        autofocus={autofocus}\n        rawErrors={rawErrors}\n      />\n    );\n  }\n\n  renderMultiSelect() {\n    const {\n      schema,\n      idSchema,\n      uiSchema,\n      formData,\n      disabled,\n      readonly,\n      required,\n      placeholder,\n      autofocus,\n      onBlur,\n      onFocus,\n      registry,\n      rawErrors,\n      name,\n    } = this.props;\n    const items = this.props.formData;\n    const { widgets, rootSchema, formContext } = registry;\n    const itemsSchema = retrieveSchema(schema.items, rootSchema, formData);\n    const title = schema.title || name;\n    const enumOptions = optionsList(itemsSchema);\n    const { widget = \"select\", ...options } = {\n      ...getUiOptions(uiSchema),\n      enumOptions,\n    };\n    const Widget = getWidget(schema, widget, widgets);\n    return (\n      <Widget\n        id={idSchema && idSchema.$id}\n        multiple\n        onChange={this.onSelectChange}\n        onBlur={onBlur}\n        onFocus={onFocus}\n        options={options}\n        schema={schema}\n        uiSchema={uiSchema}\n        registry={registry}\n        value={items}\n        disabled={disabled}\n        readonly={readonly}\n        required={required}\n        label={title}\n        placeholder={placeholder}\n        formContext={formContext}\n        autofocus={autofocus}\n        rawErrors={rawErrors}\n      />\n    );\n  }\n\n  renderFiles() {\n    const {\n      schema,\n      uiSchema,\n      idSchema,\n      name,\n      disabled,\n      readonly,\n      autofocus,\n      onBlur,\n      onFocus,\n      registry,\n      rawErrors,\n    } = this.props;\n    const title = schema.title || name;\n    const items = this.props.formData;\n    const { widgets, formContext } = registry;\n    const { widget = \"files\", ...options } = getUiOptions(uiSchema);\n    const Widget = getWidget(schema, widget, widgets);\n    return (\n      <Widget\n        options={options}\n        id={idSchema && idSchema.$id}\n        multiple\n        onChange={this.onSelectChange}\n        onBlur={onBlur}\n        onFocus={onFocus}\n        schema={schema}\n        uiSchema={uiSchema}\n        title={title}\n        value={items}\n        disabled={disabled}\n        readonly={readonly}\n        registry={registry}\n        formContext={formContext}\n        autofocus={autofocus}\n        rawErrors={rawErrors}\n      />\n    );\n  }\n\n  renderFixedArray() {\n    const {\n      schema,\n      uiSchema,\n      formData,\n      errorSchema,\n      idPrefix,\n      idSeparator = \"_\",\n      idSchema,\n      name,\n      required,\n      disabled,\n      readonly,\n      autofocus,\n      registry,\n      onBlur,\n      onFocus,\n      rawErrors,\n    } = this.props;\n    const title = schema.title || name;\n    let items = this.props.formData;\n    const { ArrayFieldTemplate, rootSchema, fields, formContext } = registry;\n    const { TitleField } = fields;\n    const itemSchemas = schema.items.map((item, index) =>\n      retrieveSchema(item, rootSchema, formData[index])\n    );\n    const additionalSchema = allowAdditionalItems(schema)\n      ? retrieveSchema(schema.additionalItems, rootSchema, formData)\n      : null;\n\n    if (!items || items.length < itemSchemas.length) {\n      // to make sure at least all fixed items are generated\n      items = items || [];\n      items = items.concat(new Array(itemSchemas.length - items.length));\n    }\n\n    // These are the props passed into the render function\n    const arrayProps = {\n      canAdd: this.canAddItem(items) && additionalSchema,\n      className: \"field field-array field-array-fixed-items\",\n      disabled,\n      idSchema,\n      formData,\n      items: this.state.keyedFormData.map((keyedItem, index) => {\n        const { key, item } = keyedItem;\n        const additional = index >= itemSchemas.length;\n        const itemSchema = additional\n          ? retrieveSchema(schema.additionalItems, rootSchema, item)\n          : itemSchemas[index];\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\n        const itemIdSchema = toIdSchema(\n          itemSchema,\n          itemIdPrefix,\n          rootSchema,\n          item,\n          idPrefix,\n          idSeparator\n        );\n        const itemUiSchema = additional\n          ? uiSchema.additionalItems || {}\n          : Array.isArray(uiSchema.items)\n          ? uiSchema.items[index]\n          : uiSchema.items || {};\n        const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;\n\n        return this.renderArrayFieldItem({\n          key,\n          index,\n          canRemove: additional,\n          canMoveUp: index >= itemSchemas.length + 1,\n          canMoveDown: additional && index < items.length - 1,\n          itemSchema,\n          itemData: item,\n          itemUiSchema,\n          itemIdSchema,\n          itemErrorSchema,\n          autofocus: autofocus && index === 0,\n          onBlur,\n          onFocus,\n        });\n      }),\n      onAddClick: this.onAddClick,\n      readonly,\n      required,\n      registry,\n      schema,\n      uiSchema,\n      title,\n      TitleField,\n      formContext,\n      rawErrors,\n    };\n\n    // Check if a custom template template was passed in\n    const Template =\n      uiSchema[\"ui:ArrayFieldTemplate\"] ||\n      ArrayFieldTemplate ||\n      DefaultFixedArrayFieldTemplate;\n    return <Template {...arrayProps} />;\n  }\n\n  renderArrayFieldItem(props) {\n    const {\n      key,\n      index,\n      canRemove = true,\n      canMoveUp = true,\n      canMoveDown = true,\n      itemSchema,\n      itemData,\n      itemUiSchema,\n      itemIdSchema,\n      itemErrorSchema,\n      autofocus,\n      onBlur,\n      onFocus,\n      rawErrors,\n    } = props;\n    const { disabled, readonly, uiSchema, registry } = this.props;\n    const {\n      fields: { SchemaField },\n    } = registry;\n    const { orderable = true, removable = true } = getUiOptions(uiSchema);\n    const has = {\n      moveUp: orderable && canMoveUp,\n      moveDown: orderable && canMoveDown,\n      remove: removable && canRemove,\n    };\n    has.toolbar = Object.keys(has).some(key => has[key]);\n\n    return {\n      children: (\n        <SchemaField\n          index={index}\n          schema={itemSchema}\n          uiSchema={itemUiSchema}\n          formData={itemData}\n          errorSchema={itemErrorSchema}\n          idPrefix={this.props.idPrefix}\n          idSeparator={this.props.idSeparator}\n          idSchema={itemIdSchema}\n          required={this.isItemRequired(itemSchema)}\n          onChange={this.onChangeForIndex(index)}\n          onBlur={onBlur}\n          onFocus={onFocus}\n          registry={this.props.registry}\n          disabled={this.props.disabled}\n          readonly={this.props.readonly}\n          hideError={this.props.hideError}\n          autofocus={autofocus}\n          rawErrors={rawErrors}\n        />\n      ),\n      className: \"array-item\",\n      disabled,\n      hasToolbar: has.toolbar,\n      hasMoveUp: has.moveUp,\n      hasMoveDown: has.moveDown,\n      hasRemove: has.remove,\n      index,\n      key,\n      onAddIndexClick: this.onAddIndexClick,\n      onDropIndexClick: this.onDropIndexClick,\n      onReorderClick: this.onReorderClick,\n      readonly,\n    };\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  ArrayField.propTypes = types.fieldProps;\n}\n\nexport default ArrayField;\n","import React from \"react\";\nimport * as types from \"../../types\";\n\nimport { getWidget, getUiOptions, optionsList } from \"../../utils\";\n\nfunction BooleanField(props) {\n  const {\n    schema,\n    name,\n    uiSchema,\n    idSchema,\n    formData,\n    registry,\n    required,\n    disabled,\n    readonly,\n    autofocus,\n    onChange,\n    onFocus,\n    onBlur,\n    rawErrors,\n  } = props;\n  const { title } = schema;\n  const { widgets, formContext, fields } = registry;\n  const { widget = \"checkbox\", ...options } = getUiOptions(uiSchema);\n  const Widget = getWidget(schema, widget, widgets);\n\n  let enumOptions;\n\n  if (Array.isArray(schema.oneOf)) {\n    enumOptions = optionsList({\n      oneOf: schema.oneOf.map(option => ({\n        ...option,\n        title: option.title || (option.const === true ? \"Yes\" : \"No\"),\n      })),\n    });\n  } else {\n    enumOptions = optionsList({\n      enum: schema.enum || [true, false],\n      enumNames:\n        schema.enumNames ||\n        (schema.enum && schema.enum[0] === false\n          ? [\"No\", \"Yes\"]\n          : [\"Yes\", \"No\"]),\n    });\n  }\n\n  return (\n    <Widget\n      options={{ ...options, enumOptions }}\n      schema={schema}\n      uiSchema={uiSchema}\n      id={idSchema && idSchema.$id}\n      onChange={onChange}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      label={title === undefined ? name : title}\n      value={formData}\n      required={required}\n      disabled={disabled}\n      readonly={readonly}\n      registry={registry}\n      formContext={formContext}\n      autofocus={autofocus}\n      rawErrors={rawErrors}\n      DescriptionField={fields.DescriptionField}\n    />\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  BooleanField.propTypes = types.fieldProps;\n}\n\nBooleanField.defaultProps = {\n  uiSchema: {},\n  disabled: false,\n  readonly: false,\n  autofocus: false,\n};\n\nexport default BooleanField;\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport * as types from \"../../types\";\nimport {\n  getUiOptions,\n  getWidget,\n  guessType,\n  retrieveSchema,\n  getDefaultFormState,\n  getMatchingOption,\n  deepEquals,\n} from \"../../utils\";\n\nclass AnyOfField extends Component {\n  constructor(props) {\n    super(props);\n\n    const { formData, options } = this.props;\n\n    this.state = {\n      selectedOption: this.getMatchingOption(formData, options),\n    };\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (\n      !deepEquals(this.props.formData, prevProps.formData) &&\n      this.props.idSchema.$id === prevProps.idSchema.$id\n    ) {\n      const matchingOption = this.getMatchingOption(\n        this.props.formData,\n        this.props.options\n      );\n\n      if (!prevState || matchingOption === this.state.selectedOption) {\n        return;\n      }\n\n      this.setState({\n        selectedOption: matchingOption,\n      });\n    }\n  }\n\n  getMatchingOption(formData, options) {\n    const { rootSchema } = this.props.registry;\n\n    let option = getMatchingOption(formData, options, rootSchema);\n    if (option !== 0) {\n      return option;\n    }\n    // If the form data matches none of the options, use the currently selected\n    // option, assuming it's available; otherwise use the first option\n    return this && this.state ? this.state.selectedOption : 0;\n  }\n\n  onOptionChange = option => {\n    const selectedOption = parseInt(option, 10);\n    const { formData, onChange, options, registry } = this.props;\n    const { rootSchema } = registry;\n    const newOption = retrieveSchema(\n      options[selectedOption],\n      rootSchema,\n      formData\n    );\n\n    // If the new option is of type object and the current data is an object,\n    // discard properties added using the old option.\n    let newFormData = undefined;\n    if (\n      guessType(formData) === \"object\" &&\n      (newOption.type === \"object\" || newOption.properties)\n    ) {\n      newFormData = Object.assign({}, formData);\n\n      const optionsToDiscard = options.slice();\n      optionsToDiscard.splice(selectedOption, 1);\n\n      // Discard any data added using other options\n      for (const option of optionsToDiscard) {\n        if (option.properties) {\n          for (const key in option.properties) {\n            if (newFormData.hasOwnProperty(key)) {\n              delete newFormData[key];\n            }\n          }\n        }\n      }\n    }\n    // Call getDefaultFormState to make sure defaults are populated on change.\n    onChange(\n      getDefaultFormState(options[selectedOption], newFormData, rootSchema)\n    );\n\n    this.setState({\n      selectedOption: parseInt(option, 10),\n    });\n  };\n\n  render() {\n    const {\n      baseType,\n      disabled,\n      readonly,\n      hideError,\n      errorSchema,\n      formData,\n      idPrefix,\n      idSeparator,\n      idSchema,\n      onBlur,\n      onChange,\n      onFocus,\n      options,\n      registry,\n      uiSchema,\n      schema,\n    } = this.props;\n\n    const _SchemaField = registry.fields.SchemaField;\n    const { widgets } = registry;\n    const { selectedOption } = this.state;\n    const { widget = \"select\", ...uiOptions } = getUiOptions(uiSchema);\n    const Widget = getWidget({ type: \"number\" }, widget, widgets);\n\n    const option = options[selectedOption] || null;\n    let optionSchema;\n\n    if (option) {\n      // If the subschema doesn't declare a type, infer the type from the\n      // parent schema\n      optionSchema = option.type\n        ? option\n        : Object.assign({}, option, { type: baseType });\n    }\n\n    const enumOptions = options.map((option, index) => ({\n      label: option.title || `Option ${index + 1}`,\n      value: index,\n    }));\n\n    return (\n      <div className=\"panel panel-default panel-body\">\n        <div className=\"form-group\">\n          <Widget\n            id={`${idSchema.$id}${\n              schema.oneOf ? \"__oneof_select\" : \"__anyof_select\"\n            }`}\n            schema={{ type: \"number\", default: 0 }}\n            onChange={this.onOptionChange}\n            onBlur={onBlur}\n            onFocus={onFocus}\n            value={selectedOption}\n            options={{ enumOptions }}\n            registry={registry}\n            {...uiOptions}\n          />\n        </div>\n\n        {option !== null && (\n          <_SchemaField\n            schema={optionSchema}\n            uiSchema={uiSchema}\n            errorSchema={errorSchema}\n            idSchema={idSchema}\n            idPrefix={idPrefix}\n            idSeparator={idSeparator}\n            formData={formData}\n            onChange={onChange}\n            onBlur={onBlur}\n            onFocus={onFocus}\n            registry={registry}\n            disabled={disabled}\n            readonly={readonly}\n            hideError={hideError}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nAnyOfField.defaultProps = {\n  disabled: false,\n  readonly: false,\n  hideError: false,\n  errorSchema: {},\n  idSchema: {},\n  uiSchema: {},\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  AnyOfField.propTypes = {\n    options: PropTypes.arrayOf(PropTypes.object).isRequired,\n    baseType: PropTypes.string,\n    uiSchema: PropTypes.object,\n    idSchema: PropTypes.object,\n    formData: PropTypes.any,\n    errorSchema: PropTypes.object,\n    registry: types.registry.isRequired,\n  };\n}\n\nexport default AnyOfField;\n","import React from \"react\";\n\nimport * as types from \"../../types\";\nimport { asNumber } from \"../../utils\";\n\n// Matches a string that ends in a . character, optionally followed by a sequence of\n// digits followed by any number of 0 characters up until the end of the line.\n// Ensuring that there is at least one prefixed character is important so that\n// you don't incorrectly match against \"0\".\nconst trailingCharMatcherWithPrefix = /\\.([0-9]*0)*$/;\n\n// This is used for trimming the trailing 0 and . characters without affecting\n// the rest of the string. Its possible to use one RegEx with groups for this\n// functionality, but it is fairly complex compared to simply defining two\n// different matchers.\nconst trailingCharMatcher = /[0.]0*$/;\n\n/**\n * The NumberField class has some special handling for dealing with trailing\n * decimal points and/or zeroes. This logic is designed to allow trailing values\n * to be visible in the input element, but not be represented in the\n * corresponding form data.\n *\n * The algorithm is as follows:\n *\n * 1. When the input value changes the value is cached in the component state\n *\n * 2. The value is then normalized, removing trailing decimal points and zeros,\n *    then passed to the \"onChange\" callback\n *\n * 3. When the component is rendered, the formData value is checked against the\n *    value cached in the state. If it matches the cached value, the cached\n *    value is passed to the input instead of the formData value\n */\nclass NumberField extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      lastValue: props.value,\n    };\n  }\n\n  handleChange = value => {\n    // Cache the original value in component state\n    this.setState({ lastValue: value });\n\n    // Normalize decimals that don't start with a zero character in advance so\n    // that the rest of the normalization logic is simpler\n    if (`${value}`.charAt(0) === \".\") {\n      value = `0${value}`;\n    }\n\n    // Check that the value is a string (this can happen if the widget used is a\n    // <select>, due to an enum declaration etc) then, if the value ends in a\n    // trailing decimal point or multiple zeroes, strip the trailing values\n    let processed =\n      typeof value === \"string\" && value.match(trailingCharMatcherWithPrefix)\n        ? asNumber(value.replace(trailingCharMatcher, \"\"))\n        : asNumber(value);\n\n    this.props.onChange(processed);\n  };\n\n  render() {\n    const { StringField } = this.props.registry.fields;\n    const { formData, ...props } = this.props;\n    const { lastValue } = this.state;\n\n    let value = formData;\n\n    if (typeof lastValue === \"string\" && typeof value === \"number\") {\n      // Construct a regular expression that checks for a string that consists\n      // of the formData value suffixed with zero or one '.' characters and zero\n      // or more '0' characters\n      const re = new RegExp(`${value}`.replace(\".\", \"\\\\.\") + \"\\\\.?0*$\");\n\n      // If the cached \"lastValue\" is a match, use that instead of the formData\n      // value to prevent the input value from changing in the UI\n      if (lastValue.match(re)) {\n        value = lastValue;\n      }\n    }\n\n    return (\n      <StringField {...props} formData={value} onChange={this.handleChange} />\n    );\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  NumberField.propTypes = types.fieldProps;\n}\n\nNumberField.defaultProps = {\n  uiSchema: {},\n};\n\nexport default NumberField;\n","import AddButton from \"../AddButton\";\nimport React, { Component } from \"react\";\nimport * as types from \"../../types\";\n\nimport {\n  orderProperties,\n  retrieveSchema,\n  canExpand,\n  ADDITIONAL_PROPERTY_FLAG,\n} from \"../../utils\";\n\nfunction DefaultObjectFieldTemplate(props) {\n  const { TitleField, DescriptionField } = props;\n  return (\n    <fieldset id={props.idSchema.$id}>\n      {(props.uiSchema[\"ui:title\"] || props.title) && (\n        <TitleField\n          id={`${props.idSchema.$id}__title`}\n          title={props.title || props.uiSchema[\"ui:title\"]}\n          required={props.required}\n          formContext={props.formContext}\n        />\n      )}\n      {props.description && (\n        <DescriptionField\n          id={`${props.idSchema.$id}__description`}\n          description={props.description}\n          formContext={props.formContext}\n        />\n      )}\n      {props.properties.map(prop => prop.content)}\n      {canExpand(props.schema, props.uiSchema, props.formData) && (\n        <AddButton\n          className=\"object-property-expand\"\n          onClick={props.onAddClick(props.schema)}\n          disabled={props.disabled || props.readonly}\n        />\n      )}\n    </fieldset>\n  );\n}\n\nclass ObjectField extends Component {\n  static defaultProps = {\n    uiSchema: {},\n    formData: {},\n    errorSchema: {},\n    idSchema: {},\n    required: false,\n    disabled: false,\n    readonly: false,\n  };\n\n  state = {\n    wasPropertyKeyModified: false,\n    additionalProperties: {},\n  };\n\n  isRequired(name) {\n    const schema = this.props.schema;\n    return (\n      Array.isArray(schema.required) && schema.required.indexOf(name) !== -1\n    );\n  }\n\n  onPropertyChange = (name, addedByAdditionalProperties = false) => {\n    return (value, errorSchema) => {\n      if (value === undefined && addedByAdditionalProperties) {\n        // Don't set value = undefined for fields added by\n        // additionalProperties. Doing so removes them from the\n        // formData, which causes them to completely disappear\n        // (including the input field for the property name). Unlike\n        // fields which are \"mandated\" by the schema, these fields can\n        // be set to undefined by clicking a \"delete field\" button, so\n        // set empty values to the empty string.\n        value = \"\";\n      }\n      const newFormData = { ...this.props.formData, [name]: value };\n      this.props.onChange(\n        newFormData,\n        errorSchema &&\n          this.props.errorSchema && {\n            ...this.props.errorSchema,\n            [name]: errorSchema,\n          }\n      );\n    };\n  };\n\n  onDropPropertyClick = key => {\n    return event => {\n      event.preventDefault();\n      const { onChange, formData } = this.props;\n      const copiedFormData = { ...formData };\n      delete copiedFormData[key];\n      onChange(copiedFormData);\n    };\n  };\n\n  getAvailableKey = (preferredKey, formData) => {\n    var index = 0;\n    var newKey = preferredKey;\n    while (formData.hasOwnProperty(newKey)) {\n      newKey = `${preferredKey}-${++index}`;\n    }\n    return newKey;\n  };\n\n  onKeyChange = oldValue => {\n    return (value, errorSchema) => {\n      if (oldValue === value) {\n        return;\n      }\n\n      value = this.getAvailableKey(value, this.props.formData);\n      const newFormData = { ...this.props.formData };\n      const newKeys = { [oldValue]: value };\n      const keyValues = Object.keys(newFormData).map(key => {\n        const newKey = newKeys[key] || key;\n        return { [newKey]: newFormData[key] };\n      });\n      const renamedObj = Object.assign({}, ...keyValues);\n\n      this.setState({ wasPropertyKeyModified: true });\n\n      this.props.onChange(\n        renamedObj,\n        errorSchema &&\n          this.props.errorSchema && {\n            ...this.props.errorSchema,\n            [value]: errorSchema,\n          }\n      );\n    };\n  };\n\n  getDefaultValue(type) {\n    switch (type) {\n      case \"string\":\n        return \"New Value\";\n      case \"array\":\n        return [];\n      case \"boolean\":\n        return false;\n      case \"null\":\n        return null;\n      case \"number\":\n        return 0;\n      case \"object\":\n        return {};\n      default:\n        // We don't have a datatype for some reason (perhaps additionalProperties was true)\n        return \"New Value\";\n    }\n  }\n\n  handleAddClick = schema => () => {\n    let type = schema.additionalProperties.type;\n    const newFormData = { ...this.props.formData };\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      const { registry } = this.props;\n      const refSchema = retrieveSchema(\n        { $ref: schema.additionalProperties[\"$ref\"] },\n        registry.rootSchema,\n        this.props.formData\n      );\n\n      type = refSchema.type;\n    }\n\n    newFormData[\n      this.getAvailableKey(\"newKey\", newFormData)\n    ] = this.getDefaultValue(type);\n\n    this.props.onChange(newFormData);\n  };\n\n  render() {\n    const {\n      uiSchema,\n      formData,\n      errorSchema,\n      idSchema,\n      name,\n      required,\n      disabled,\n      readonly,\n      hideError,\n      idPrefix,\n      idSeparator,\n      onBlur,\n      onFocus,\n      registry,\n    } = this.props;\n\n    const { rootSchema, fields, formContext } = registry;\n    const { SchemaField, TitleField, DescriptionField } = fields;\n    const schema = retrieveSchema(this.props.schema, rootSchema, formData);\n\n    const title = schema.title === undefined ? name : schema.title;\n    const description = uiSchema[\"ui:description\"] || schema.description;\n    let orderedProperties;\n    try {\n      const properties = Object.keys(schema.properties || {});\n      orderedProperties = orderProperties(properties, uiSchema[\"ui:order\"]);\n    } catch (err) {\n      return (\n        <div>\n          <p className=\"config-error\" style={{ color: \"red\" }}>\n            Invalid {name || \"root\"} object field configuration:\n            <em>{err.message}</em>.\n          </p>\n          <pre>{JSON.stringify(schema)}</pre>\n        </div>\n      );\n    }\n\n    const Template =\n      uiSchema[\"ui:ObjectFieldTemplate\"] ||\n      registry.ObjectFieldTemplate ||\n      DefaultObjectFieldTemplate;\n\n    const templateProps = {\n      title: uiSchema[\"ui:title\"] || title,\n      description,\n      TitleField,\n      DescriptionField,\n      properties: orderedProperties.map(name => {\n        const addedByAdditionalProperties = schema.properties[\n          name\n        ].hasOwnProperty(ADDITIONAL_PROPERTY_FLAG);\n        const fieldUiSchema = addedByAdditionalProperties\n          ? uiSchema.additionalProperties\n          : uiSchema[name];\n        const hidden = fieldUiSchema && fieldUiSchema[\"ui:widget\"] === \"hidden\";\n\n        return {\n          content: (\n            <SchemaField\n              key={name}\n              name={name}\n              required={this.isRequired(name)}\n              schema={schema.properties[name]}\n              uiSchema={fieldUiSchema}\n              errorSchema={errorSchema[name]}\n              idSchema={idSchema[name]}\n              idPrefix={idPrefix}\n              idSeparator={idSeparator}\n              formData={(formData || {})[name]}\n              wasPropertyKeyModified={this.state.wasPropertyKeyModified}\n              onKeyChange={this.onKeyChange(name)}\n              onChange={this.onPropertyChange(\n                name,\n                addedByAdditionalProperties\n              )}\n              onBlur={onBlur}\n              onFocus={onFocus}\n              registry={registry}\n              disabled={disabled}\n              readonly={readonly}\n              hideError={hideError}\n              onDropPropertyClick={this.onDropPropertyClick}\n            />\n          ),\n          name,\n          readonly,\n          disabled,\n          required,\n          hidden,\n        };\n      }),\n      readonly,\n      disabled,\n      required,\n      idSchema,\n      uiSchema,\n      schema,\n      formData,\n      formContext,\n      registry,\n    };\n    return <Template {...templateProps} onAddClick={this.handleAddClick} />;\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  ObjectField.propTypes = types.fieldProps;\n}\n\nexport default ObjectField;\n","import IconButton from \"../IconButton\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport * as types from \"../../types\";\n\nimport {\n  ADDITIONAL_PROPERTY_FLAG,\n  isSelect,\n  retrieveSchema,\n  toIdSchema,\n  mergeObjects,\n  deepEquals,\n  getSchemaType,\n  getDisplayLabel,\n} from \"../../utils\";\n\nconst REQUIRED_FIELD_SYMBOL = \"*\";\nconst COMPONENT_TYPES = {\n  array: \"ArrayField\",\n  boolean: \"BooleanField\",\n  integer: \"NumberField\",\n  number: \"NumberField\",\n  object: \"ObjectField\",\n  string: \"StringField\",\n  null: \"NullField\",\n};\n\nfunction getFieldComponent(schema, uiSchema, idSchema, fields) {\n  const field = uiSchema[\"ui:field\"];\n  if (typeof field === \"function\") {\n    return field;\n  }\n  if (typeof field === \"string\" && field in fields) {\n    return fields[field];\n  }\n\n  const componentName = COMPONENT_TYPES[getSchemaType(schema)];\n\n  // If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't\n  // render a field and let the MultiSchemaField component handle the form display\n  if (!componentName && (schema.anyOf || schema.oneOf)) {\n    return () => null;\n  }\n\n  return componentName in fields\n    ? fields[componentName]\n    : () => {\n        const { UnsupportedField } = fields;\n\n        return (\n          <UnsupportedField\n            schema={schema}\n            idSchema={idSchema}\n            reason={`Unknown field type ${schema.type}`}\n          />\n        );\n      };\n}\n\nfunction Label(props) {\n  const { label, required, id } = props;\n  if (!label) {\n    return null;\n  }\n  return (\n    <label className=\"control-label\" htmlFor={id}>\n      {label}\n      {required && <span className=\"required\">{REQUIRED_FIELD_SYMBOL}</span>}\n    </label>\n  );\n}\n\nfunction LabelInput(props) {\n  const { id, label, onChange } = props;\n  return (\n    <input\n      className=\"form-control\"\n      type=\"text\"\n      id={id}\n      onBlur={event => onChange(event.target.value)}\n      defaultValue={label}\n    />\n  );\n}\n\nfunction Help(props) {\n  const { id, help } = props;\n  if (!help) {\n    return null;\n  }\n  if (typeof help === \"string\") {\n    return (\n      <p id={id} className=\"help-block\">\n        {help}\n      </p>\n    );\n  }\n  return (\n    <div id={id} className=\"help-block\">\n      {help}\n    </div>\n  );\n}\n\nfunction ErrorList(props) {\n  const { errors = [] } = props;\n  if (errors.length === 0) {\n    return null;\n  }\n\n  return (\n    <div>\n      <ul className=\"error-detail bs-callout bs-callout-info\">\n        {errors\n          .filter(elem => !!elem)\n          .map((error, index) => {\n            return (\n              <li className=\"text-danger\" key={index}>\n                {error}\n              </li>\n            );\n          })}\n      </ul>\n    </div>\n  );\n}\nfunction DefaultTemplate(props) {\n  const {\n    id,\n    label,\n    children,\n    errors,\n    help,\n    description,\n    hidden,\n    required,\n    displayLabel,\n  } = props;\n  if (hidden) {\n    return <div className=\"hidden\">{children}</div>;\n  }\n\n  return (\n    <WrapIfAdditional {...props}>\n      {displayLabel && <Label label={label} required={required} id={id} />}\n      {displayLabel && description ? description : null}\n      {children}\n      {errors}\n      {help}\n    </WrapIfAdditional>\n  );\n}\nif (process.env.NODE_ENV !== \"production\") {\n  DefaultTemplate.propTypes = {\n    id: PropTypes.string,\n    classNames: PropTypes.string,\n    label: PropTypes.string,\n    children: PropTypes.node.isRequired,\n    errors: PropTypes.element,\n    rawErrors: PropTypes.arrayOf(PropTypes.string),\n    help: PropTypes.element,\n    rawHelp: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    description: PropTypes.element,\n    rawDescription: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    hidden: PropTypes.bool,\n    required: PropTypes.bool,\n    readonly: PropTypes.bool,\n    displayLabel: PropTypes.bool,\n    fields: PropTypes.object,\n    formContext: PropTypes.object,\n  };\n}\n\nDefaultTemplate.defaultProps = {\n  hidden: false,\n  readonly: false,\n  required: false,\n  displayLabel: true,\n};\n\nfunction WrapIfAdditional(props) {\n  const {\n    id,\n    classNames,\n    disabled,\n    label,\n    onKeyChange,\n    onDropPropertyClick,\n    readonly,\n    required,\n    schema,\n  } = props;\n  const keyLabel = `${label} Key`; // i18n ?\n  const additional = schema.hasOwnProperty(ADDITIONAL_PROPERTY_FLAG);\n\n  if (!additional) {\n    return <div className={classNames}>{props.children}</div>;\n  }\n\n  return (\n    <div className={classNames}>\n      <div className=\"row\">\n        <div className=\"col-xs-5 form-additional\">\n          <div className=\"form-group\">\n            <Label label={keyLabel} required={required} id={`${id}-key`} />\n            <LabelInput\n              label={label}\n              required={required}\n              id={`${id}-key`}\n              onChange={onKeyChange}\n            />\n          </div>\n        </div>\n        <div className=\"form-additional form-group col-xs-5\">\n          {props.children}\n        </div>\n        <div className=\"col-xs-2\">\n          <IconButton\n            type=\"danger\"\n            icon=\"remove\"\n            className=\"array-item-remove btn-block\"\n            tabIndex=\"-1\"\n            style={{ border: \"0\" }}\n            disabled={disabled || readonly}\n            onClick={onDropPropertyClick(label)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction SchemaFieldRender(props) {\n  const {\n    uiSchema,\n    formData,\n    errorSchema,\n    idPrefix,\n    idSeparator,\n    name,\n    onChange,\n    onKeyChange,\n    onDropPropertyClick,\n    required,\n    registry,\n    wasPropertyKeyModified = false,\n  } = props;\n  const { rootSchema, fields, formContext } = registry;\n  const FieldTemplate =\n    uiSchema[\"ui:FieldTemplate\"] || registry.FieldTemplate || DefaultTemplate;\n  let idSchema = props.idSchema;\n  const schema = retrieveSchema(props.schema, rootSchema, formData);\n  idSchema = mergeObjects(\n    toIdSchema(schema, null, rootSchema, formData, idPrefix, idSeparator),\n    idSchema\n  );\n  const FieldComponent = getFieldComponent(schema, uiSchema, idSchema, fields);\n  const { DescriptionField } = fields;\n  const disabled = Boolean(props.disabled || uiSchema[\"ui:disabled\"]);\n  const readonly = Boolean(\n    props.readonly ||\n      uiSchema[\"ui:readonly\"] ||\n      props.schema.readOnly ||\n      schema.readOnly\n  );\n  const uiSchemaHideError = uiSchema[\"ui:hideError\"];\n  // Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children\n  const hideError =\n    uiSchemaHideError === undefined\n      ? props.hideError\n      : Boolean(uiSchemaHideError);\n  const autofocus = Boolean(props.autofocus || uiSchema[\"ui:autofocus\"]);\n  if (Object.keys(schema).length === 0) {\n    return null;\n  }\n\n  const displayLabel = getDisplayLabel(schema, uiSchema, rootSchema);\n\n  const { __errors, ...fieldErrorSchema } = errorSchema;\n\n  // See #439: uiSchema: Don't pass consumed class names to child components\n  const field = (\n    <FieldComponent\n      {...props}\n      idSchema={idSchema}\n      schema={schema}\n      uiSchema={{ ...uiSchema, classNames: undefined }}\n      disabled={disabled}\n      readonly={readonly}\n      hideError={hideError}\n      autofocus={autofocus}\n      errorSchema={fieldErrorSchema}\n      formContext={formContext}\n      rawErrors={__errors}\n    />\n  );\n\n  const id = idSchema.$id;\n\n  // If this schema has a title defined, but the user has set a new key/label, retain their input.\n  let label;\n  if (wasPropertyKeyModified) {\n    label = name;\n  } else {\n    label = uiSchema[\"ui:title\"] || props.schema.title || schema.title || name;\n  }\n\n  const description =\n    uiSchema[\"ui:description\"] ||\n    props.schema.description ||\n    schema.description;\n  const errors = __errors;\n  const help = uiSchema[\"ui:help\"];\n  const hidden = uiSchema[\"ui:widget\"] === \"hidden\";\n\n  let classNames = [\"form-group\", \"field\", `field-${schema.type}`];\n  if (!hideError && errors && errors.length > 0) {\n    classNames.push(\"field-error has-error has-danger\");\n  }\n  classNames.push(uiSchema.classNames);\n  classNames = classNames.join(\" \").trim();\n\n  const fieldProps = {\n    description: (\n      <DescriptionField\n        id={id + \"__description\"}\n        description={description}\n        formContext={formContext}\n      />\n    ),\n    rawDescription: description,\n    help: <Help id={id + \"__help\"} help={help} />,\n    rawHelp: typeof help === \"string\" ? help : undefined,\n    errors: hideError ? undefined : <ErrorList errors={errors} />,\n    rawErrors: hideError ? undefined : errors,\n    id,\n    label,\n    hidden,\n    onChange,\n    onKeyChange,\n    onDropPropertyClick,\n    required,\n    disabled,\n    readonly,\n    hideError,\n    displayLabel,\n    classNames,\n    formContext,\n    formData,\n    fields,\n    schema,\n    uiSchema,\n    registry,\n  };\n\n  const _AnyOfField = registry.fields.AnyOfField;\n  const _OneOfField = registry.fields.OneOfField;\n\n  return (\n    <FieldTemplate {...fieldProps}>\n      <React.Fragment>\n        {field}\n\n        {/*\n        If the schema `anyOf` or 'oneOf' can be rendered as a select control, don't\n        render the selection and let `StringField` component handle\n        rendering\n      */}\n        {schema.anyOf && !isSelect(schema) && (\n          <_AnyOfField\n            disabled={disabled}\n            readonly={readonly}\n            hideError={hideError}\n            errorSchema={errorSchema}\n            formData={formData}\n            idPrefix={idPrefix}\n            idSchema={idSchema}\n            idSeparator={idSeparator}\n            onBlur={props.onBlur}\n            onChange={props.onChange}\n            onFocus={props.onFocus}\n            options={schema.anyOf.map(_schema =>\n              retrieveSchema(_schema, rootSchema, formData)\n            )}\n            baseType={schema.type}\n            registry={registry}\n            schema={schema}\n            uiSchema={uiSchema}\n          />\n        )}\n\n        {schema.oneOf && !isSelect(schema) && (\n          <_OneOfField\n            disabled={disabled}\n            readonly={readonly}\n            hideError={hideError}\n            errorSchema={errorSchema}\n            formData={formData}\n            idPrefix={idPrefix}\n            idSchema={idSchema}\n            idSeparator={idSeparator}\n            onBlur={props.onBlur}\n            onChange={props.onChange}\n            onFocus={props.onFocus}\n            options={schema.oneOf.map(_schema =>\n              retrieveSchema(_schema, rootSchema, formData)\n            )}\n            baseType={schema.type}\n            registry={registry}\n            schema={schema}\n            uiSchema={uiSchema}\n          />\n        )}\n      </React.Fragment>\n    </FieldTemplate>\n  );\n}\n\nclass SchemaField extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return !deepEquals(this.props, nextProps);\n  }\n\n  render() {\n    return SchemaFieldRender(this.props);\n  }\n}\n\nSchemaField.defaultProps = {\n  uiSchema: {},\n  errorSchema: {},\n  idSchema: {},\n  disabled: false,\n  readonly: false,\n  autofocus: false,\n  hideError: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  SchemaField.propTypes = {\n    schema: PropTypes.object.isRequired,\n    uiSchema: PropTypes.object,\n    idSchema: PropTypes.object,\n    formData: PropTypes.any,\n    errorSchema: PropTypes.object,\n    registry: types.registry.isRequired,\n  };\n}\n\nexport default SchemaField;\n","import React from \"react\";\nimport * as types from \"../../types\";\n\nimport {\n  getWidget,\n  getUiOptions,\n  isSelect,\n  optionsList,\n  hasWidget,\n} from \"../../utils\";\n\nfunction StringField(props) {\n  const {\n    schema,\n    name,\n    uiSchema,\n    idSchema,\n    formData,\n    required,\n    disabled,\n    readonly,\n    autofocus,\n    onChange,\n    onBlur,\n    onFocus,\n    registry,\n    rawErrors,\n  } = props;\n  const { title, format } = schema;\n  const { widgets, formContext } = registry;\n  const enumOptions = isSelect(schema) && optionsList(schema);\n  let defaultWidget = enumOptions ? \"select\" : \"text\";\n  if (format && hasWidget(schema, format, widgets)) {\n    defaultWidget = format;\n  }\n  const { widget = defaultWidget, placeholder = \"\", ...options } = getUiOptions(\n    uiSchema\n  );\n  const Widget = getWidget(schema, widget, widgets);\n  return (\n    <Widget\n      options={{ ...options, enumOptions }}\n      schema={schema}\n      uiSchema={uiSchema}\n      id={idSchema && idSchema.$id}\n      label={title === undefined ? name : title}\n      value={formData}\n      onChange={onChange}\n      onBlur={onBlur}\n      onFocus={onFocus}\n      required={required}\n      disabled={disabled}\n      readonly={readonly}\n      formContext={formContext}\n      autofocus={autofocus}\n      registry={registry}\n      placeholder={placeholder}\n      rawErrors={rawErrors}\n    />\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  StringField.propTypes = types.fieldProps;\n}\n\nStringField.defaultProps = {\n  uiSchema: {},\n  disabled: false,\n  readonly: false,\n  autofocus: false,\n};\n\nexport default StringField;\n","import ArrayField from \"./ArrayField\";\nimport BooleanField from \"./BooleanField\";\nimport DescriptionField from \"./DescriptionField\";\nimport MultiSchemaField from \"./MultiSchemaField\";\nimport NumberField from \"./NumberField\";\nimport ObjectField from \"./ObjectField\";\nimport SchemaField from \"./SchemaField\";\nimport StringField from \"./StringField\";\nimport TitleField from \"./TitleField\";\nimport NullField from \"./NullField\";\nimport UnsupportedField from \"./UnsupportedField\";\n\nexport default {\n  AnyOfField: MultiSchemaField,\n  ArrayField,\n  BooleanField,\n  DescriptionField,\n  NumberField,\n  ObjectField,\n  OneOfField: MultiSchemaField,\n  SchemaField,\n  StringField,\n  TitleField,\n  NullField,\n  UnsupportedField,\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction DescriptionField(props) {\n  const { id, description } = props;\n  if (!description) {\n    return null;\n  }\n  if (typeof description === \"string\") {\n    return (\n      <p id={id} className=\"field-description\">\n        {description}\n      </p>\n    );\n  } else {\n    return (\n      <div id={id} className=\"field-description\">\n        {description}\n      </div>\n    );\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  DescriptionField.propTypes = {\n    id: PropTypes.string,\n    description: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n  };\n}\n\nexport default DescriptionField;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nconst REQUIRED_FIELD_SYMBOL = \"*\";\n\nfunction TitleField(props) {\n  const { id, title, required } = props;\n  return (\n    <legend id={id}>\n      {title}\n      {required && <span className=\"required\">{REQUIRED_FIELD_SYMBOL}</span>}\n    </legend>\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  TitleField.propTypes = {\n    id: PropTypes.string,\n    title: PropTypes.string,\n    required: PropTypes.bool,\n  };\n}\n\nexport default TitleField;\n","import { Component } from \"react\";\nimport * as types from \"../../types\";\n\nclass NullField extends Component {\n  componentDidMount() {\n    if (this.props.formData === undefined) {\n      this.props.onChange(null);\n    }\n  }\n\n  render() {\n    return null;\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  NullField.propTypes = types.fieldProps;\n}\n\nexport default NullField;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction UnsupportedField({ schema, idSchema, reason }) {\n  return (\n    <div className=\"unsupported-field\">\n      <p>\n        Unsupported field schema\n        {idSchema && idSchema.$id && (\n          <span>\n            {\" for\"} field <code>{idSchema.$id}</code>\n          </span>\n        )}\n        {reason && <em>: {reason}</em>}.\n      </p>\n      {schema && <pre>{JSON.stringify(schema, null, 2)}</pre>}\n    </div>\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  UnsupportedField.propTypes = {\n    schema: PropTypes.object.isRequired,\n    idSchema: PropTypes.object,\n    reason: PropTypes.string,\n  };\n}\n\nexport default UnsupportedField;\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { shouldRender, parseDateString, toDateString, pad } from \"../../utils\";\n\nfunction rangeOptions(start, stop) {\n  let options = [];\n  for (let i = start; i <= stop; i++) {\n    options.push({ value: i, label: pad(i, 2) });\n  }\n  return options;\n}\n\nfunction readyForChange(state) {\n  return Object.keys(state).every(key => state[key] !== -1);\n}\n\nfunction DateElement(props) {\n  const {\n    type,\n    range,\n    value,\n    select,\n    rootId,\n    disabled,\n    readonly,\n    autofocus,\n    registry,\n    onBlur,\n  } = props;\n  const id = rootId + \"_\" + type;\n  const { SelectWidget } = registry.widgets;\n  return (\n    <SelectWidget\n      schema={{ type: \"integer\" }}\n      id={id}\n      className=\"form-control\"\n      options={{ enumOptions: rangeOptions(range[0], range[1]) }}\n      placeholder={type}\n      value={value}\n      disabled={disabled}\n      readonly={readonly}\n      autofocus={autofocus}\n      onChange={value => select(type, value)}\n      onBlur={onBlur}\n    />\n  );\n}\n\nclass AltDateWidget extends Component {\n  static defaultProps = {\n    time: false,\n    disabled: false,\n    readonly: false,\n    autofocus: false,\n    options: {\n      yearsRange: [1900, new Date().getFullYear() + 2],\n    },\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = parseDateString(props.value, props.time);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (\n      prevProps.value &&\n      prevProps.value !== parseDateString(this.props.value, this.props.time)\n    ) {\n      this.setState(parseDateString(this.props.value, this.props.time));\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return shouldRender(this, nextProps, nextState);\n  }\n\n  onChange = (property, value) => {\n    this.setState(\n      { [property]: typeof value === \"undefined\" ? -1 : value },\n      () => {\n        // Only propagate to parent state if we have a complete date{time}\n        if (readyForChange(this.state)) {\n          this.props.onChange(toDateString(this.state, this.props.time));\n        }\n      }\n    );\n  };\n\n  setNow = event => {\n    event.preventDefault();\n    const { time, disabled, readonly, onChange } = this.props;\n    if (disabled || readonly) {\n      return;\n    }\n    const nowDateObj = parseDateString(new Date().toJSON(), time);\n    this.setState(nowDateObj, () => onChange(toDateString(this.state, time)));\n  };\n\n  clear = event => {\n    event.preventDefault();\n    const { time, disabled, readonly, onChange } = this.props;\n    if (disabled || readonly) {\n      return;\n    }\n    this.setState(parseDateString(\"\", time), () => onChange(undefined));\n  };\n\n  get dateElementProps() {\n    const { time, options } = this.props;\n    const { year, month, day, hour, minute, second } = this.state;\n    const data = [\n      {\n        type: \"year\",\n        range: options.yearsRange,\n        value: year,\n      },\n      { type: \"month\", range: [1, 12], value: month },\n      { type: \"day\", range: [1, 31], value: day },\n    ];\n    if (time) {\n      data.push(\n        { type: \"hour\", range: [0, 23], value: hour },\n        { type: \"minute\", range: [0, 59], value: minute },\n        { type: \"second\", range: [0, 59], value: second }\n      );\n    }\n    return data;\n  }\n\n  render() {\n    const {\n      id,\n      disabled,\n      readonly,\n      autofocus,\n      registry,\n      onBlur,\n      options,\n    } = this.props;\n    return (\n      <ul className=\"list-inline\">\n        {this.dateElementProps.map((elemProps, i) => (\n          <li key={i}>\n            <DateElement\n              rootId={id}\n              select={this.onChange}\n              {...elemProps}\n              disabled={disabled}\n              readonly={readonly}\n              registry={registry}\n              onBlur={onBlur}\n              autofocus={autofocus && i === 0}\n            />\n          </li>\n        ))}\n        {(options.hideNowButton !== \"undefined\"\n          ? !options.hideNowButton\n          : true) && (\n          <li>\n            <a href=\"#\" className=\"btn btn-info btn-now\" onClick={this.setNow}>\n              Now\n            </a>\n          </li>\n        )}\n        {(options.hideClearButton !== \"undefined\"\n          ? !options.hideClearButton\n          : true) && (\n          <li>\n            <a\n              href=\"#\"\n              className=\"btn btn-warning btn-clear\"\n              onClick={this.clear}>\n              Clear\n            </a>\n          </li>\n        )}\n      </ul>\n    );\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  AltDateWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    value: PropTypes.string,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n    onBlur: PropTypes.func,\n    time: PropTypes.bool,\n    options: PropTypes.object,\n  };\n}\n\nexport default AltDateWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport AltDateWidget from \"./AltDateWidget\";\n\nfunction AltDateTimeWidget(props) {\n  const { AltDateWidget } = props.registry.widgets;\n  return <AltDateWidget time {...props} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  AltDateTimeWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    value: PropTypes.string,\n    required: PropTypes.bool,\n    onChange: PropTypes.func,\n    options: PropTypes.object,\n  };\n}\n\nAltDateTimeWidget.defaultProps = {\n  ...AltDateWidget.defaultProps,\n  time: true,\n};\n\nexport default AltDateTimeWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction BaseInput(props) {\n  // Note: since React 15.2.0 we can't forward unknown element attributes, so we\n  // exclude the \"options\" and \"schema\" ones here.\n  if (!props.id) {\n    console.log(\"No id for\", props);\n    throw new Error(`no id for props ${JSON.stringify(props)}`);\n  }\n  const {\n    value,\n    readonly,\n    disabled,\n    autofocus,\n    onBlur,\n    onFocus,\n    options,\n    schema,\n    uiSchema,\n    formContext,\n    registry,\n    rawErrors,\n    ...inputProps\n  } = props;\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!inputProps.type) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === \"number\") {\n      inputProps.type = \"number\";\n      // Setting step to 'any' fixes a bug in Safari where decimals are not\n      // allowed in number inputs\n      inputProps.step = \"any\";\n    } else if (schema.type === \"integer\") {\n      inputProps.type = \"number\";\n      // Since this is integer, you always want to step up or down in multiples\n      // of 1\n      inputProps.step = \"1\";\n    } else {\n      inputProps.type = \"text\";\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  // If multipleOf is defined, use this as the step value. This mainly improves\n  // the experience for keyboard users (who can use the up/down KB arrows).\n  if (schema.multipleOf) {\n    inputProps.step = schema.multipleOf;\n  }\n\n  if (typeof schema.minimum !== \"undefined\") {\n    inputProps.min = schema.minimum;\n  }\n\n  if (typeof schema.maximum !== \"undefined\") {\n    inputProps.max = schema.maximum;\n  }\n\n  const _onChange = ({ target: { value } }) => {\n    return props.onChange(value === \"\" ? options.emptyValue : value);\n  };\n\n  return [\n    <input\n      key={inputProps.id}\n      className=\"form-control\"\n      readOnly={readonly}\n      disabled={disabled}\n      autoFocus={autofocus}\n      value={value == null ? \"\" : value}\n      {...inputProps}\n      list={schema.examples ? `examples_${inputProps.id}` : null}\n      onChange={_onChange}\n      onBlur={onBlur && (event => onBlur(inputProps.id, event.target.value))}\n      onFocus={onFocus && (event => onFocus(inputProps.id, event.target.value))}\n    />,\n    schema.examples ? (\n      <datalist\n        key={`datalist_${inputProps.id}`}\n        id={`examples_${inputProps.id}`}>\n        {[\n          ...new Set(\n            schema.examples.concat(schema.default ? [schema.default] : [])\n          ),\n        ].map(example => (\n          <option key={example} value={example} />\n        ))}\n      </datalist>\n    ) : null,\n  ];\n}\n\nBaseInput.defaultProps = {\n  required: false,\n  disabled: false,\n  readonly: false,\n  autofocus: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  BaseInput.propTypes = {\n    id: PropTypes.string.isRequired,\n    placeholder: PropTypes.string,\n    value: PropTypes.any,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n    onBlur: PropTypes.func,\n    onFocus: PropTypes.func,\n  };\n}\n\nexport default BaseInput;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { schemaRequiresTrueValue } from \"../../utils\";\n\nfunction CheckboxWidget(props) {\n  const {\n    schema,\n    id,\n    value,\n    disabled,\n    readonly,\n    label,\n    autofocus,\n    onBlur,\n    onFocus,\n    onChange,\n    DescriptionField,\n  } = props;\n\n  // Because an unchecked checkbox will cause html5 validation to fail, only add\n  // the \"required\" attribute if the field value must be \"true\", due to the\n  // \"const\" or \"enum\" keywords\n  const required = schemaRequiresTrueValue(schema);\n\n  return (\n    <div className={`checkbox ${disabled || readonly ? \"disabled\" : \"\"}`}>\n      {schema.description && (\n        <DescriptionField description={schema.description} />\n      )}\n      <label>\n        <input\n          type=\"checkbox\"\n          id={id}\n          checked={typeof value === \"undefined\" ? false : value}\n          required={required}\n          disabled={disabled || readonly}\n          autoFocus={autofocus}\n          onChange={event => onChange(event.target.checked)}\n          onBlur={onBlur && (event => onBlur(id, event.target.checked))}\n          onFocus={onFocus && (event => onFocus(id, event.target.checked))}\n        />\n        <span>{label}</span>\n      </label>\n    </div>\n  );\n}\n\nCheckboxWidget.defaultProps = {\n  autofocus: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  CheckboxWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    value: PropTypes.bool,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\nexport default CheckboxWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction selectValue(value, selected, all) {\n  const at = all.indexOf(value);\n  const updated = selected.slice(0, at).concat(value, selected.slice(at));\n  // As inserting values at predefined index positions doesn't work with empty\n  // arrays, we need to reorder the updated selection to match the initial order\n  return updated.sort((a, b) => all.indexOf(a) > all.indexOf(b));\n}\n\nfunction deselectValue(value, selected) {\n  return selected.filter(v => v !== value);\n}\n\nfunction CheckboxesWidget(props) {\n  const { id, disabled, options, value, autofocus, readonly, onChange } = props;\n  const { enumOptions, enumDisabled, inline } = options;\n  return (\n    <div className=\"checkboxes\" id={id}>\n      {enumOptions.map((option, index) => {\n        const checked = value.indexOf(option.value) !== -1;\n        const itemDisabled =\n          enumDisabled && enumDisabled.indexOf(option.value) != -1;\n        const disabledCls =\n          disabled || itemDisabled || readonly ? \"disabled\" : \"\";\n        const checkbox = (\n          <span>\n            <input\n              type=\"checkbox\"\n              id={`${id}_${index}`}\n              checked={checked}\n              disabled={disabled || itemDisabled || readonly}\n              autoFocus={autofocus && index === 0}\n              onChange={event => {\n                const all = enumOptions.map(({ value }) => value);\n                if (event.target.checked) {\n                  onChange(selectValue(option.value, value, all));\n                } else {\n                  onChange(deselectValue(option.value, value));\n                }\n              }}\n            />\n            <span>{option.label}</span>\n          </span>\n        );\n        return inline ? (\n          <label key={index} className={`checkbox-inline ${disabledCls}`}>\n            {checkbox}\n          </label>\n        ) : (\n          <div key={index} className={`checkbox ${disabledCls}`}>\n            <label>{checkbox}</label>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nCheckboxesWidget.defaultProps = {\n  autofocus: false,\n  options: {\n    inline: false,\n  },\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  CheckboxesWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    options: PropTypes.shape({\n      enumOptions: PropTypes.array,\n      inline: PropTypes.bool,\n    }).isRequired,\n    value: PropTypes.any,\n    required: PropTypes.bool,\n    readonly: PropTypes.bool,\n    disabled: PropTypes.bool,\n    multiple: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\nexport default CheckboxesWidget;\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { dataURItoBlob, shouldRender } from \"../../utils\";\n\nfunction addNameToDataURL(dataURL, name) {\n  return dataURL.replace(\";base64\", `;name=${encodeURIComponent(name)};base64`);\n}\n\nfunction processFile(file) {\n  const { name, size, type } = file;\n  return new Promise((resolve, reject) => {\n    const reader = new window.FileReader();\n    reader.onerror = reject;\n    reader.onload = event => {\n      resolve({\n        dataURL: addNameToDataURL(event.target.result, name),\n        name,\n        size,\n        type,\n      });\n    };\n    reader.readAsDataURL(file);\n  });\n}\n\nfunction processFiles(files) {\n  return Promise.all([].map.call(files, processFile));\n}\n\nfunction FilesInfo(props) {\n  const { filesInfo } = props;\n  if (filesInfo.length === 0) {\n    return null;\n  }\n  return (\n    <ul className=\"file-info\">\n      {filesInfo.map((fileInfo, key) => {\n        const { name, size, type } = fileInfo;\n        return (\n          <li key={key}>\n            <strong>{name}</strong> ({type}, {size} bytes)\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n\nfunction extractFileInfo(dataURLs) {\n  return dataURLs\n    .filter(dataURL => typeof dataURL !== \"undefined\")\n    .map(dataURL => {\n      const { blob, name } = dataURItoBlob(dataURL);\n      return {\n        name: name,\n        size: blob.size,\n        type: blob.type,\n      };\n    });\n}\n\nclass FileWidget extends Component {\n  constructor(props) {\n    super(props);\n    const { value } = props;\n    const values = Array.isArray(value) ? value : [value];\n    this.state = { values, filesInfo: extractFileInfo(values) };\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return shouldRender(this, nextProps, nextState);\n  }\n\n  onChange = event => {\n    const { multiple, onChange } = this.props;\n    processFiles(event.target.files).then(filesInfo => {\n      const state = {\n        values: filesInfo.map(fileInfo => fileInfo.dataURL),\n        filesInfo,\n      };\n      this.setState(state, () => {\n        if (multiple) {\n          onChange(state.values);\n        } else {\n          onChange(state.values[0]);\n        }\n      });\n    });\n  };\n\n  render() {\n    const { multiple, id, readonly, disabled, autofocus, options } = this.props;\n    const { filesInfo } = this.state;\n    return (\n      <div>\n        <p>\n          <input\n            ref={ref => (this.inputRef = ref)}\n            id={id}\n            type=\"file\"\n            disabled={readonly || disabled}\n            onChange={this.onChange}\n            defaultValue=\"\"\n            autoFocus={autofocus}\n            multiple={multiple}\n            accept={options.accept}\n          />\n        </p>\n        <FilesInfo filesInfo={filesInfo} />\n      </div>\n    );\n  }\n}\n\nFileWidget.defaultProps = {\n  autofocus: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  FileWidget.propTypes = {\n    multiple: PropTypes.bool,\n    value: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.string),\n    ]),\n    autofocus: PropTypes.bool,\n  };\n}\n\nexport default FileWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction RadioWidget(props) {\n  const {\n    options,\n    value,\n    required,\n    disabled,\n    readonly,\n    autofocus,\n    onBlur,\n    onFocus,\n    onChange,\n    id,\n  } = props;\n  // Generating a unique field name to identify this set of radio buttons\n  const name = Math.random().toString();\n  const { enumOptions, enumDisabled, inline } = options;\n  // checked={checked} has been moved above name={name}, As mentioned in #349;\n  // this is a temporary fix for radio button rendering bug in React, facebook/react#7630.\n  return (\n    <div className=\"field-radio-group\" id={id}>\n      {enumOptions.map((option, i) => {\n        const checked = option.value === value;\n        const itemDisabled =\n          enumDisabled && enumDisabled.indexOf(option.value) != -1;\n        const disabledCls =\n          disabled || itemDisabled || readonly ? \"disabled\" : \"\";\n        const radio = (\n          <span>\n            <input\n              type=\"radio\"\n              checked={checked}\n              name={name}\n              required={required}\n              value={option.value}\n              disabled={disabled || itemDisabled || readonly}\n              autoFocus={autofocus && i === 0}\n              onChange={_ => onChange(option.value)}\n              onBlur={onBlur && (event => onBlur(id, event.target.value))}\n              onFocus={onFocus && (event => onFocus(id, event.target.value))}\n            />\n            <span>{option.label}</span>\n          </span>\n        );\n\n        return inline ? (\n          <label key={i} className={`radio-inline ${disabledCls}`}>\n            {radio}\n          </label>\n        ) : (\n          <div key={i} className={`radio ${disabledCls}`}>\n            <label>{radio}</label>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nRadioWidget.defaultProps = {\n  autofocus: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  RadioWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    options: PropTypes.shape({\n      enumOptions: PropTypes.array,\n      inline: PropTypes.bool,\n    }).isRequired,\n    value: PropTypes.any,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\nexport default RadioWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { asNumber, guessType } from \"../../utils\";\n\nconst nums = new Set([\"number\", \"integer\"]);\n\n/**\n * This is a silly limitation in the DOM where option change event values are\n * always retrieved as strings.\n */\nfunction processValue(schema, value) {\n  // \"enum\" is a reserved word, so only \"type\" and \"items\" can be destructured\n  const { type, items } = schema;\n  if (value === \"\") {\n    return undefined;\n  } else if (type === \"array\" && items && nums.has(items.type)) {\n    return value.map(asNumber);\n  } else if (type === \"boolean\") {\n    return value === \"true\";\n  } else if (type === \"number\") {\n    return asNumber(value);\n  }\n\n  // If type is undefined, but an enum is present, try and infer the type from\n  // the enum values\n  if (schema.enum) {\n    if (schema.enum.every(x => guessType(x) === \"number\")) {\n      return asNumber(value);\n    } else if (schema.enum.every(x => guessType(x) === \"boolean\")) {\n      return value === \"true\";\n    }\n  }\n\n  return value;\n}\n\nfunction getValue(event, multiple) {\n  if (multiple) {\n    return [].slice\n      .call(event.target.options)\n      .filter(o => o.selected)\n      .map(o => o.value);\n  } else {\n    return event.target.value;\n  }\n}\n\nfunction SelectWidget(props) {\n  const {\n    schema,\n    id,\n    options,\n    value,\n    required,\n    disabled,\n    readonly,\n    multiple,\n    autofocus,\n    onChange,\n    onBlur,\n    onFocus,\n    placeholder,\n  } = props;\n  const { enumOptions, enumDisabled } = options;\n  const emptyValue = multiple ? [] : \"\";\n  return (\n    <select\n      id={id}\n      multiple={multiple}\n      className=\"form-control\"\n      value={typeof value === \"undefined\" ? emptyValue : value}\n      required={required}\n      disabled={disabled || readonly}\n      autoFocus={autofocus}\n      onBlur={\n        onBlur &&\n        (event => {\n          const newValue = getValue(event, multiple);\n          onBlur(id, processValue(schema, newValue));\n        })\n      }\n      onFocus={\n        onFocus &&\n        (event => {\n          const newValue = getValue(event, multiple);\n          onFocus(id, processValue(schema, newValue));\n        })\n      }\n      onChange={event => {\n        const newValue = getValue(event, multiple);\n        onChange(processValue(schema, newValue));\n      }}>\n      {!multiple && schema.default === undefined && (\n        <option value=\"\">{placeholder}</option>\n      )}\n      {enumOptions.map(({ value, label }, i) => {\n        const disabled = enumDisabled && enumDisabled.indexOf(value) != -1;\n        return (\n          <option key={i} value={value} disabled={disabled}>\n            {label}\n          </option>\n        );\n      })}\n    </select>\n  );\n}\n\nSelectWidget.defaultProps = {\n  autofocus: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  SelectWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    options: PropTypes.shape({\n      enumOptions: PropTypes.array,\n    }).isRequired,\n    value: PropTypes.any,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    multiple: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n    onBlur: PropTypes.func,\n    onFocus: PropTypes.func,\n  };\n}\n\nexport default SelectWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction TextareaWidget(props) {\n  const {\n    id,\n    options,\n    placeholder,\n    value,\n    required,\n    disabled,\n    readonly,\n    autofocus,\n    onChange,\n    onBlur,\n    onFocus,\n  } = props;\n  const _onChange = ({ target: { value } }) => {\n    return onChange(value === \"\" ? options.emptyValue : value);\n  };\n  return (\n    <textarea\n      id={id}\n      className=\"form-control\"\n      value={value ? value : \"\"}\n      placeholder={placeholder}\n      required={required}\n      disabled={disabled}\n      readOnly={readonly}\n      autoFocus={autofocus}\n      rows={options.rows}\n      onBlur={onBlur && (event => onBlur(id, event.target.value))}\n      onFocus={onFocus && (event => onFocus(id, event.target.value))}\n      onChange={_onChange}\n    />\n  );\n}\n\nTextareaWidget.defaultProps = {\n  autofocus: false,\n  options: {},\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  TextareaWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    placeholder: PropTypes.string,\n    options: PropTypes.shape({\n      rows: PropTypes.number,\n    }),\n    value: PropTypes.string,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n    onBlur: PropTypes.func,\n    onFocus: PropTypes.func,\n  };\n}\n\nexport default TextareaWidget;\n","import AltDateWidget from \"./AltDateWidget\";\nimport AltDateTimeWidget from \"./AltDateTimeWidget\";\nimport BaseInput from \"./BaseInput\";\nimport CheckboxWidget from \"./CheckboxWidget\";\nimport CheckboxesWidget from \"./CheckboxesWidget\";\nimport ColorWidget from \"./ColorWidget\";\nimport DateWidget from \"./DateWidget\";\nimport DateTimeWidget from \"./DateTimeWidget\";\nimport EmailWidget from \"./EmailWidget\";\nimport FileWidget from \"./FileWidget\";\nimport HiddenWidget from \"./HiddenWidget\";\nimport PasswordWidget from \"./PasswordWidget\";\nimport RadioWidget from \"./RadioWidget\";\nimport RangeWidget from \"./RangeWidget\";\nimport SelectWidget from \"./SelectWidget\";\nimport TextareaWidget from \"./TextareaWidget\";\nimport TextWidget from \"./TextWidget\";\nimport URLWidget from \"./URLWidget\";\nimport UpDownWidget from \"./UpDownWidget\";\nimport SubmitButton from \"./SubmitButton\";\nexport default {\n  BaseInput,\n  PasswordWidget,\n  RadioWidget,\n  UpDownWidget,\n  RangeWidget,\n  SelectWidget,\n  TextWidget,\n  DateWidget,\n  DateTimeWidget,\n  AltDateWidget,\n  AltDateTimeWidget,\n  EmailWidget,\n  URLWidget,\n  TextareaWidget,\n  HiddenWidget,\n  ColorWidget,\n  FileWidget,\n  CheckboxWidget,\n  CheckboxesWidget,\n  SubmitButton,\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction PasswordWidget(props) {\n  const { BaseInput } = props.registry.widgets;\n  return <BaseInput type=\"password\" {...props} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  PasswordWidget.propTypes = {\n    value: PropTypes.string,\n  };\n}\n\nexport default PasswordWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { rangeSpec } from \"../../utils\";\n\nfunction UpDownWidget(props) {\n  const {\n    registry: {\n      widgets: { BaseInput },\n    },\n  } = props;\n  return <BaseInput type=\"number\" {...props} {...rangeSpec(props.schema)} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  UpDownWidget.propTypes = {\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  };\n}\n\nexport default UpDownWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { rangeSpec } from \"../../utils\";\n\nfunction RangeWidget(props) {\n  const {\n    schema,\n    value,\n    registry: {\n      widgets: { BaseInput },\n    },\n  } = props;\n  return (\n    <div className=\"field-range-wrapper\">\n      <BaseInput type=\"range\" {...props} {...rangeSpec(schema)} />\n      <span className=\"range-view\">{value}</span>\n    </div>\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  RangeWidget.propTypes = {\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  };\n}\n\nexport default RangeWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction TextWidget(props) {\n  const { BaseInput } = props.registry.widgets;\n  return <BaseInput {...props} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  TextWidget.propTypes = {\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    id: PropTypes.string,\n  };\n}\n\nexport default TextWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction DateWidget(props) {\n  const {\n    onChange,\n    registry: {\n      widgets: { BaseInput },\n    },\n  } = props;\n  return (\n    <BaseInput\n      type=\"date\"\n      {...props}\n      onChange={value => onChange(value || undefined)}\n    />\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  DateWidget.propTypes = {\n    value: PropTypes.string,\n  };\n}\n\nexport default DateWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { utcToLocal, localToUTC } from \"../../utils\";\n\nfunction DateTimeWidget(props) {\n  const {\n    value,\n    onChange,\n    registry: {\n      widgets: { BaseInput },\n    },\n  } = props;\n  return (\n    <BaseInput\n      type=\"datetime-local\"\n      {...props}\n      value={utcToLocal(value)}\n      onChange={value => onChange(localToUTC(value))}\n    />\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  DateTimeWidget.propTypes = {\n    value: PropTypes.string,\n  };\n}\n\nexport default DateTimeWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction EmailWidget(props) {\n  const { BaseInput } = props.registry.widgets;\n  return <BaseInput type=\"email\" {...props} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  EmailWidget.propTypes = {\n    value: PropTypes.string,\n  };\n}\n\nexport default EmailWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction URLWidget(props) {\n  const { BaseInput } = props.registry.widgets;\n  return <BaseInput type=\"url\" {...props} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  URLWidget.propTypes = {\n    value: PropTypes.string,\n  };\n}\n\nexport default URLWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction HiddenWidget({ id, value }) {\n  return (\n    <input\n      type=\"hidden\"\n      id={id}\n      value={typeof value === \"undefined\" ? \"\" : value}\n    />\n  );\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  HiddenWidget.propTypes = {\n    id: PropTypes.string.isRequired,\n    value: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.number,\n      PropTypes.bool,\n    ]),\n  };\n}\n\nexport default HiddenWidget;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction ColorWidget(props) {\n  const {\n    disabled,\n    readonly,\n    registry: {\n      widgets: { BaseInput },\n    },\n  } = props;\n  return <BaseInput type=\"color\" {...props} disabled={disabled || readonly} />;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  ColorWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    value: PropTypes.string,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\nexport default ColorWidget;\n","import React from \"react\";\nimport { getSubmitButtonOptions } from \".././../utils\";\n\nexport default function SubmitButton({ uiSchema }) {\n  const {\n    submitText,\n    norender,\n    props: submitButtonProps,\n  } = getSubmitButtonOptions(uiSchema);\n  return (\n    <div>\n      {!norender && (\n        <button type=\"submit\" {...submitButtonProps} className=\"btn btn-info\">\n          {submitText}\n        </button>\n      )}\n    </div>\n  );\n}\n","import fields from \"./components/fields\";\nimport widgets from \"./components/widgets\";\n\nexport function getDefaultRegistry() {\n  return {\n    fields,\n    widgets,\n    definitions: {},\n    rootSchema: {},\n    formContext: {},\n  };\n}\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport _pick from \"lodash/pick\";\nimport _get from \"lodash/get\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport { getDefaultRegistry } from \"../defaultRegistry\";\n\nimport { default as DefaultErrorList } from \"./ErrorList\";\nimport {\n  getDefaultFormState,\n  retrieveSchema,\n  shouldRender,\n  toIdSchema,\n  deepEquals,\n  toPathSchema,\n  isObject,\n} from \"../utils\";\nimport validateFormData, { toErrorList } from \"../validate\";\nimport { mergeObjects } from \"../utils\";\n\nexport default class Form extends Component {\n  static defaultProps = {\n    uiSchema: {},\n    noValidate: false,\n    liveValidate: false,\n    disabled: false,\n    readonly: false,\n    noHtml5Validate: false,\n    ErrorList: DefaultErrorList,\n    omitExtraData: false,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = this.getStateFromProps(props, props.formData);\n    if (\n      this.props.onChange &&\n      !deepEquals(this.state.formData, this.props.formData)\n    ) {\n      this.props.onChange(this.state);\n    }\n    this.formElement = null;\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const nextState = this.getStateFromProps(nextProps, nextProps.formData);\n    if (\n      !deepEquals(nextState.formData, nextProps.formData) &&\n      !deepEquals(nextState.formData, this.state.formData) &&\n      this.props.onChange\n    ) {\n      this.props.onChange(nextState);\n    }\n    this.setState(nextState);\n  }\n\n  getStateFromProps(props, inputFormData) {\n    const state = this.state || {};\n    const schema = \"schema\" in props ? props.schema : this.props.schema;\n    const uiSchema = \"uiSchema\" in props ? props.uiSchema : this.props.uiSchema;\n    const edit = typeof inputFormData !== \"undefined\";\n    const liveValidate =\n      \"liveValidate\" in props ? props.liveValidate : this.props.liveValidate;\n    const mustValidate = edit && !props.noValidate && liveValidate;\n    const rootSchema = schema;\n    const formData = getDefaultFormState(schema, inputFormData, rootSchema);\n    const retrievedSchema = retrieveSchema(schema, rootSchema, formData);\n    const customFormats = props.customFormats;\n    const additionalMetaSchemas = props.additionalMetaSchemas;\n\n    const getCurrentErrors = () => {\n      if (props.noValidate) {\n        return { errors: [], errorSchema: {} };\n      } else if (!props.liveValidate) {\n        return {\n          errors: state.schemaValidationErrors || [],\n          errorSchema: state.schemaValidationErrorSchema || {},\n        };\n      }\n      return {\n        errors: state.errors || [],\n        errorSchema: state.errorSchema || {},\n      };\n    };\n\n    let errors,\n      errorSchema,\n      schemaValidationErrors,\n      schemaValidationErrorSchema;\n    if (mustValidate) {\n      const schemaValidation = this.validate(\n        formData,\n        schema,\n        additionalMetaSchemas,\n        customFormats\n      );\n      errors = schemaValidation.errors;\n      errorSchema = schemaValidation.errorSchema;\n      schemaValidationErrors = errors;\n      schemaValidationErrorSchema = errorSchema;\n    } else {\n      const currentErrors = getCurrentErrors();\n      errors = currentErrors.errors;\n      errorSchema = currentErrors.errorSchema;\n      schemaValidationErrors = state.schemaValidationErrors;\n      schemaValidationErrorSchema = state.schemaValidationErrorSchema;\n    }\n    if (props.extraErrors) {\n      errorSchema = mergeObjects(\n        errorSchema,\n        props.extraErrors,\n        !!\"concat arrays\"\n      );\n      errors = toErrorList(errorSchema);\n    }\n    const idSchema = toIdSchema(\n      retrievedSchema,\n      uiSchema[\"ui:rootFieldId\"],\n      rootSchema,\n      formData,\n      props.idPrefix,\n      props.idSeparator\n    );\n    const nextState = {\n      schema,\n      uiSchema,\n      idSchema,\n      formData,\n      edit,\n      errors,\n      errorSchema,\n      additionalMetaSchemas,\n    };\n    if (schemaValidationErrors) {\n      nextState.schemaValidationErrors = schemaValidationErrors;\n      nextState.schemaValidationErrorSchema = schemaValidationErrorSchema;\n    }\n    return nextState;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return shouldRender(this, nextProps, nextState);\n  }\n\n  validate(\n    formData,\n    schema = this.props.schema,\n    additionalMetaSchemas = this.props.additionalMetaSchemas,\n    customFormats = this.props.customFormats\n  ) {\n    const { validate, transformErrors } = this.props;\n    const { rootSchema } = this.getRegistry();\n    const resolvedSchema = retrieveSchema(schema, rootSchema, formData);\n    return validateFormData(\n      formData,\n      resolvedSchema,\n      validate,\n      transformErrors,\n      additionalMetaSchemas,\n      customFormats\n    );\n  }\n\n  renderErrors() {\n    const { errors, errorSchema, schema, uiSchema } = this.state;\n    const { ErrorList, showErrorList, formContext } = this.props;\n\n    if (errors.length && showErrorList != false) {\n      return (\n        <ErrorList\n          errors={errors}\n          errorSchema={errorSchema}\n          schema={schema}\n          uiSchema={uiSchema}\n          formContext={formContext}\n        />\n      );\n    }\n    return null;\n  }\n\n  getUsedFormData = (formData, fields) => {\n    //for the case of a single input form\n    if (fields.length === 0 && typeof formData !== \"object\") {\n      return formData;\n    }\n\n    let data = _pick(formData, fields);\n    if (Array.isArray(formData)) {\n      return Object.keys(data).map(key => data[key]);\n    }\n\n    return data;\n  };\n\n  getFieldNames = (pathSchema, formData) => {\n    const getAllPaths = (_obj, acc = [], paths = [\"\"]) => {\n      Object.keys(_obj).forEach(key => {\n        if (typeof _obj[key] === \"object\") {\n          let newPaths = paths.map(path => `${path}.${key}`);\n          // If an object is marked with additionalProperties, all its keys are valid\n          if (_obj[key].__rjsf_additionalProperties && _obj[key].$name !== \"\") {\n            acc.push(_obj[key].$name);\n          } else {\n            getAllPaths(_obj[key], acc, newPaths);\n          }\n        } else if (key === \"$name\" && _obj[key] !== \"\") {\n          paths.forEach(path => {\n            path = path.replace(/^\\./, \"\");\n            const formValue = _get(formData, path);\n            // adds path to fieldNames if it points to a value\n            // or an empty object/array\n            if (typeof formValue !== \"object\" || _isEmpty(formValue)) {\n              acc.push(path);\n            }\n          });\n        }\n      });\n      return acc;\n    };\n\n    return getAllPaths(pathSchema);\n  };\n\n  onChange = (formData, newErrorSchema) => {\n    if (isObject(formData) || Array.isArray(formData)) {\n      const newState = this.getStateFromProps(this.props, formData);\n      formData = newState.formData;\n    }\n    const mustValidate = !this.props.noValidate && this.props.liveValidate;\n    let state = { formData };\n    let newFormData = formData;\n\n    if (this.props.omitExtraData === true && this.props.liveOmit === true) {\n      const retrievedSchema = retrieveSchema(\n        this.state.schema,\n        this.state.schema,\n        formData\n      );\n      const pathSchema = toPathSchema(\n        retrievedSchema,\n        \"\",\n        this.state.schema,\n        formData\n      );\n\n      const fieldNames = this.getFieldNames(pathSchema, formData);\n\n      newFormData = this.getUsedFormData(formData, fieldNames);\n      state = {\n        formData: newFormData,\n      };\n    }\n\n    if (mustValidate) {\n      let schemaValidation = this.validate(newFormData);\n      let errors = schemaValidation.errors;\n      let errorSchema = schemaValidation.errorSchema;\n      const schemaValidationErrors = errors;\n      const schemaValidationErrorSchema = errorSchema;\n      if (this.props.extraErrors) {\n        errorSchema = mergeObjects(\n          errorSchema,\n          this.props.extraErrors,\n          !!\"concat arrays\"\n        );\n        errors = toErrorList(errorSchema);\n      }\n      state = {\n        formData: newFormData,\n        errors,\n        errorSchema,\n        schemaValidationErrors,\n        schemaValidationErrorSchema,\n      };\n    } else if (!this.props.noValidate && newErrorSchema) {\n      const errorSchema = this.props.extraErrors\n        ? mergeObjects(\n            newErrorSchema,\n            this.props.extraErrors,\n            !!\"concat arrays\"\n          )\n        : newErrorSchema;\n      state = {\n        formData: newFormData,\n        errorSchema: errorSchema,\n        errors: toErrorList(errorSchema),\n      };\n    }\n    this.setState(\n      state,\n      () => this.props.onChange && this.props.onChange(this.state)\n    );\n  };\n\n  onBlur = (...args) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(...args);\n    }\n  };\n\n  onFocus = (...args) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(...args);\n    }\n  };\n\n  onSubmit = event => {\n    event.preventDefault();\n    if (event.target !== event.currentTarget) {\n      return;\n    }\n\n    event.persist();\n    let newFormData = this.state.formData;\n\n    if (this.props.omitExtraData === true) {\n      const retrievedSchema = retrieveSchema(\n        this.state.schema,\n        this.state.schema,\n        newFormData\n      );\n      const pathSchema = toPathSchema(\n        retrievedSchema,\n        \"\",\n        this.state.schema,\n        newFormData\n      );\n\n      const fieldNames = this.getFieldNames(pathSchema, newFormData);\n\n      newFormData = this.getUsedFormData(newFormData, fieldNames);\n    }\n\n    if (!this.props.noValidate) {\n      let schemaValidation = this.validate(newFormData);\n      let errors = schemaValidation.errors;\n      let errorSchema = schemaValidation.errorSchema;\n      const schemaValidationErrors = errors;\n      const schemaValidationErrorSchema = errorSchema;\n      if (Object.keys(errors).length > 0) {\n        if (this.props.extraErrors) {\n          errorSchema = mergeObjects(\n            errorSchema,\n            this.props.extraErrors,\n            !!\"concat arrays\"\n          );\n          errors = toErrorList(errorSchema);\n        }\n        this.setState(\n          {\n            errors,\n            errorSchema,\n            schemaValidationErrors,\n            schemaValidationErrorSchema,\n          },\n          () => {\n            if (this.props.onError) {\n              this.props.onError(errors);\n            } else {\n              console.error(\"Form validation failed\", errors);\n            }\n          }\n        );\n        return;\n      }\n    }\n\n    // There are no errors generated through schema validation.\n    // Check for user provided errors and update state accordingly.\n    let errorSchema;\n    let errors;\n    if (this.props.extraErrors) {\n      errorSchema = this.props.extraErrors;\n      errors = toErrorList(errorSchema);\n    } else {\n      errorSchema = {};\n      errors = [];\n    }\n\n    this.setState(\n      {\n        formData: newFormData,\n        errors: errors,\n        errorSchema: errorSchema,\n        schemaValidationErrors: [],\n        schemaValidationErrorSchema: {},\n      },\n      () => {\n        if (this.props.onSubmit) {\n          this.props.onSubmit(\n            { ...this.state, formData: newFormData, status: \"submitted\" },\n            event\n          );\n        }\n      }\n    );\n  };\n\n  getRegistry() {\n    // For BC, accept passed SchemaField and TitleField props and pass them to\n    // the \"fields\" registry one.\n    const { fields, widgets } = getDefaultRegistry();\n    return {\n      fields: { ...fields, ...this.props.fields },\n      widgets: { ...widgets, ...this.props.widgets },\n      ArrayFieldTemplate: this.props.ArrayFieldTemplate,\n      ObjectFieldTemplate: this.props.ObjectFieldTemplate,\n      FieldTemplate: this.props.FieldTemplate,\n      definitions: this.props.schema.definitions || {},\n      rootSchema: this.props.schema,\n      formContext: this.props.formContext || {},\n    };\n  }\n\n  submit() {\n    if (this.formElement) {\n      this.formElement.dispatchEvent(\n        new CustomEvent(\"submit\", {\n          cancelable: true,\n        })\n      );\n    }\n  }\n\n  render() {\n    const {\n      children,\n      id,\n      idPrefix,\n      idSeparator,\n      className,\n      tagName,\n      name,\n      method,\n      target,\n      action,\n      autocomplete: deprecatedAutocomplete,\n      autoComplete: currentAutoComplete,\n      enctype,\n      acceptcharset,\n      noHtml5Validate,\n      disabled,\n      readonly,\n      formContext,\n      /**\n       * _internalFormWrapper is currently used by the material-ui and semantic-ui themes to provide a custom wrapper\n       * around `<Form />` that supports the proper rendering of those themes. To use this prop, one must pass a\n       * component that takes two props: `children` and `as`. That component, at minimum, should render the `children`\n       * inside of a <form /> tag unless `as` is provided, in which case, use the `as` prop in place of `<form />`.\n       * i.e.:\n       * ```\n       * export default function InternalForm({ children, as}) {\n       *   const FormTag = as || 'form';\n       *   return <FormTag>{children}</FormTag>;\n       * }\n       * ```\n       */\n      _internalFormWrapper,\n    } = this.props;\n\n    const { schema, uiSchema, formData, errorSchema, idSchema } = this.state;\n    const registry = this.getRegistry();\n    const _SchemaField = registry.fields.SchemaField;\n    // The `semantic-ui` and `material-ui` themes have `_internalFormWrapper`s that take an `as` prop that is the\n    // PropTypes.elementType to use for the inner tag so we'll need to pass `tagName` along if it is provided.\n    // NOTE, the `as` prop is native to `semantic-ui` and is emulated in the `material-ui` theme\n    const as = _internalFormWrapper ? tagName : undefined;\n    const FormTag = _internalFormWrapper || tagName || \"form\";\n    const SubmitButton = registry.widgets.SubmitButton;\n    if (deprecatedAutocomplete) {\n      console.warn(\n        \"Using autocomplete property of Form is deprecated, use autoComplete instead.\"\n      );\n    }\n    const autoComplete = currentAutoComplete\n      ? currentAutoComplete\n      : deprecatedAutocomplete;\n\n    return (\n      <FormTag\n        className={className ? className : \"rjsf\"}\n        id={id}\n        name={name}\n        method={method}\n        target={target}\n        action={action}\n        autoComplete={autoComplete}\n        encType={enctype}\n        acceptCharset={acceptcharset}\n        noValidate={noHtml5Validate}\n        onSubmit={this.onSubmit}\n        as={as}\n        ref={form => {\n          this.formElement = form;\n        }}>\n        {this.renderErrors()}\n        <_SchemaField\n          schema={schema}\n          uiSchema={uiSchema}\n          errorSchema={errorSchema}\n          idSchema={idSchema}\n          idPrefix={idPrefix}\n          idSeparator={idSeparator}\n          formContext={formContext}\n          formData={formData}\n          onChange={this.onChange}\n          onBlur={this.onBlur}\n          onFocus={this.onFocus}\n          registry={registry}\n          disabled={disabled}\n          readonly={readonly}\n        />\n        {children ? children : <SubmitButton uiSchema={uiSchema} />}\n      </FormTag>\n    );\n  }\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  Form.propTypes = {\n    schema: PropTypes.object.isRequired,\n    uiSchema: PropTypes.object,\n    formData: PropTypes.any,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    widgets: PropTypes.objectOf(\n      PropTypes.oneOfType([PropTypes.func, PropTypes.object])\n    ),\n    fields: PropTypes.objectOf(PropTypes.elementType),\n    ArrayFieldTemplate: PropTypes.elementType,\n    ObjectFieldTemplate: PropTypes.elementType,\n    FieldTemplate: PropTypes.elementType,\n    ErrorList: PropTypes.func,\n    onChange: PropTypes.func,\n    onError: PropTypes.func,\n    showErrorList: PropTypes.bool,\n    onSubmit: PropTypes.func,\n    id: PropTypes.string,\n    className: PropTypes.string,\n    tagName: PropTypes.elementType,\n    _internalFormWrapper: PropTypes.elementType,\n    name: PropTypes.string,\n    method: PropTypes.string,\n    target: PropTypes.string,\n    action: PropTypes.string,\n    autocomplete: PropTypes.string,\n    autoComplete: PropTypes.string,\n    enctype: PropTypes.string,\n    acceptcharset: PropTypes.string,\n    noValidate: PropTypes.bool,\n    noHtml5Validate: PropTypes.bool,\n    liveValidate: PropTypes.bool,\n    validate: PropTypes.func,\n    transformErrors: PropTypes.func,\n    formContext: PropTypes.object,\n    customFormats: PropTypes.object,\n    additionalMetaSchemas: PropTypes.arrayOf(PropTypes.object),\n    omitExtraData: PropTypes.bool,\n    extraErrors: PropTypes.object,\n  };\n}\n","import React, { forwardRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Form from \"./\";\n\nfunction withTheme(themeProps) {\n  return forwardRef(({ fields, widgets, ...directProps }, ref) => {\n    fields = { ...themeProps.fields, ...fields };\n    widgets = { ...themeProps.widgets, ...widgets };\n\n    return (\n      <Form\n        {...themeProps}\n        {...directProps}\n        fields={fields}\n        widgets={widgets}\n        ref={ref}\n      />\n    );\n  });\n}\n\nwithTheme.propTypes = {\n  widgets: PropTypes.object,\n  fields: PropTypes.object,\n};\n\nexport default withTheme;\n","import React from \"react\";\n\nexport default function ErrorList(props) {\n  const { errors } = props;\n  return (\n    <div className=\"panel panel-danger errors\">\n      <div className=\"panel-heading\">\n        <h3 className=\"panel-title\">Errors</h3>\n      </div>\n      <ul className=\"list-group\">\n        {errors.map((error, i) => {\n          return (\n            <li key={i} className=\"list-group-item text-danger\">\n              {error.stack}\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n}\n","import Form from \"./components/Form\";\nimport withTheme from \"./withTheme\";\nimport * as _utils from \"./utils\";\nimport { getDefaultRegistry } from \"./defaultRegistry\";\n\nconst utils = {\n  ..._utils,\n  getDefaultRegistry,\n};\n\nexport { withTheme, utils };\nexport default Form;\n"],"names":["IconButton","props","type","icon","className","otherProps","React","AddButton","tabIndex","onClick","disabled","ajv","createAjvInstance","formerCustomFormats","formerMetaSchema","Ajv","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","addFormat","toErrorList","errorSchema","fieldName","errorList","concat","__errors","map","stack","Object","keys","reduce","acc","key","validateFormData","formData","schema","customValidate","transformErrors","additionalMetaSchemas","customFormats","getDefaultFormState","newMetaSchemas","deepEquals","newFormats","Array","isArray","addMetaSchema","isObject","forEach","formatName","validationError","validate","err","errors","e","message","schemaPath","property","dataPath","name","keyword","params","trim","transformAjvErrors","noProperMetaSchema","includes","length","error","path","toPath","parent","splice","slice","segment","toErrorSchema","$schema","newErrorSchema","mergeObjects","unwrapErrorHandler","errorHandler","createErrorHandler","handler","addError","push","value","isValid","data","rootSchema","addSchema","withIdRefPrefix","schemaNode","obj","constructor","startsWith","i","removeSchema","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","array","checkboxes","files","canExpand","uiSchema","additionalProperties","expandable","getUiOptions","undefined","maxProperties","getSchemaType","guessType","properties","find","getWidget","widget","registeredWidgets","ReactIs","createElement","Widget","MergedWidget","defaultOptions","defaultProps","options","mergeOptions","Error","hasOwnProperty","hasWidget","_schema","includeUndefinedValues","defaults","computeDefaults","parentDefaults","rawFormData","findSchemaDefinition","$ref","resolveDependencies","isFixedItems","items","itemSchema","idx","oneOf","getMatchingOption","anyOf","computedDefault","item","additionalItems","minItems","isMultiSelect","defaultsLength","defaultEntries","fillerSchema","fillerEntries","fill","retrieveSchema","mergeDefaultsWithFormData","assign","filter","indexOf","console","warn","component","substring","getSubmitButtonOptions","uiOptions","submitText","norender","getDisplayLabel","label","displayLabel","schemaType","isFilesArray","isCustomWidget","thing","File","obj1","obj2","concatArrays","left","right","asNumber","test","n","Number","valid","isNaN","orderProperties","order","arr","arrayToHash","prev","curr","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","join","lastIndexOf","complete","isConstant","toConstant","isSelect","altSchemas","every","uniqueItems","itemsSchema","format","allowAdditionalItems","optionsList","enumNames","String","title","origRef","decodeURIComponent","current","jsonpointer","get","stubExistingAdditionalProperties","resolveSchema","resolveReference","allOf","allOfSubschema","resolvedSchema","expression","then","otherwise","resolvedSchemaLessConditional","conditionalSchema","mergeSchemas","resolveCondition","entries","propName","propSchema","rawPropData","propData","resolvedPropSchema","mergeAllOf","dependencies","processDependencies","dependencyKey","dependencyValue","remainingDependencies","withDependentProperties","withDependentSchema","additionallyRequired","required","from","Set","resolvedOneOf","subschema","validSubschemas","conditionPropertySchema","conditionSchema","withExactlyOneSubschema","union","isArguments","object","prototype","toString","call","a","b","ca","cb","Date","getTime","RegExp","source","global","multiline","lastIndex","ignoreCase","ka","kb","cal","sort","j","k","pop","shouldRender","comp","nextProps","nextState","state","toIdSchema","id","idPrefix","idSeparator","idSchema","$id","field","fieldId","toPathSchema","pathSchema","$name","replace","__rjsf_additionalProperties","element","parseDateString","dateString","includeTime","year","month","day","hour","minute","second","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","toDateString","time","utcTime","UTC","toJSON","utcToLocal","jsonDate","pad","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","localToUTC","num","size","s","dataURItoBlob","dataURI","splitted","split","param","binary","atob","charCodeAt","blob","window","Blob","Uint8Array","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","option","requiresAnyOf","augmentedSchema","shallowClone","schemaRequiresTrueValue","some","ArrayFieldTitle","TitleField","ArrayFieldDescription","description","DescriptionField","DefaultArrayItem","btnStyle","flex","paddingLeft","paddingRight","fontWeight","hasToolbar","children","style","display","justifyContent","hasMoveUp","hasMoveDown","readonly","onReorderClick","index","hasRemove","onDropIndexClick","DefaultFixedArrayFieldTemplate","canAdd","onAddClick","DefaultNormalArrayFieldTemplate","p","generateRowId","nanoid","generateKeyedFormData","keyedToPlainFormData","keyedFormData","keyedItem","ArrayField","_getNewFormDataRow","_this","registry","event","preventDefault","onChange","newKeyedFormDataRow","newKeyedFormData","setState","updatedKeyedFormData","onAddIndexClick","parseInt","_","newIndex","target","blur","_newKeyedFormData","onChangeForIndex","onSelectChange","getDerivedStateFromProps","prevState","nextFormData","previousKeyedFormData","previousKeyedFormDatum","isItemRequired","canAddItem","formItems","this","addable","maxItems","render","renderMultiSelect","renderCustomWidget","renderFixedArray","renderFiles","renderNormalArray","fields","UnsupportedField","reason","hideError","autofocus","onBlur","onFocus","rawErrors","ArrayFieldTemplate","formContext","arrayProps","itemErrorSchema","itemIdSchema","_this2","renderArrayFieldItem","canMoveUp","canMoveDown","itemData","itemUiSchema","placeholder","widgets","multiple","enumOptions","itemSchemas","additionalSchema","additional","_this3","canRemove","SchemaField","orderable","removable","has","moveUp","moveDown","remove","toolbar","Component","BooleanField","AnyOfField","onOptionChange","selectedOption","newOption","newFormData","optionsToDiscard","componentDidUpdate","prevProps","matchingOption","optionSchema","baseType","_SchemaField","trailingCharMatcherWithPrefix","trailingCharMatcher","NumberField","handleChange","lastValue","charAt","processed","match","StringField","re","DefaultObjectFieldTemplate","content","ObjectField","wasPropertyKeyModified","onPropertyChange","addedByAdditionalProperties","onDropPropertyClick","copiedFormData","getAvailableKey","preferredKey","newKey","onKeyChange","oldValue","newKeys","keyValues","renamedObj","handleAddClick","getDefaultValue","isRequired","orderedProperties","JSON","stringify","Template","ObjectFieldTemplate","templateProps","fieldUiSchema","COMPONENT_TYPES","Label","htmlFor","LabelInput","defaultValue","Help","help","ErrorList","elem","DefaultTemplate","WrapIfAdditional","classNames","keyLabel","border","shouldComponentUpdate","FieldTemplate","FieldComponent","componentName","getFieldComponent","Boolean","readOnly","uiSchemaHideError","fieldErrorSchema","_AnyOfField","_OneOfField","OneOfField","rawDescription","rawHelp","Fragment","SchemaFieldRender","defaultWidget","MultiSchemaField","NullField","componentDidMount","rangeOptions","start","stop","DateElement","SelectWidget","rootId","AltDateWidget","setNow","nowDateObj","clear","dateElementProps","elemProps","hideNowButton","href","hideClearButton","yearsRange","AltDateTimeWidget","BaseInput","log","inputType","inputProps","autocomplete","autoComplete","autoFocus","list","examples","emptyValue","example","CheckboxWidget","checked","CheckboxesWidget","enumDisabled","inline","itemDisabled","disabledCls","all","selected","at","selectValue","v","deselectValue","addNameToDataURL","dataURL","encodeURIComponent","processFile","Promise","resolve","reject","reader","FileReader","onerror","onload","result","readAsDataURL","FilesInfo","filesInfo","fileInfo","FileWidget","values","dataURLs","ref","inputRef","accept","RadioWidget","Math","random","nums","processValue","x","getValue","o","newValue","TextareaWidget","rows","PasswordWidget","UpDownWidget","RangeWidget","TextWidget","DateWidget","DateTimeWidget","EmailWidget","URLWidget","HiddenWidget","ColorWidget","SubmitButton","getDefaultRegistry","definitions","Form","getUsedFormData","_pick","getFieldNames","getAllPaths","_obj","paths","newPaths","formValue","_get","_isEmpty","getStateFromProps","mustValidate","noValidate","liveValidate","omitExtraData","liveOmit","fieldNames","schemaValidation","schemaValidationErrors","schemaValidationErrorSchema","extraErrors","onSubmit","currentTarget","persist","onError","status","formElement","UNSAFE_componentWillReceiveProps","inputFormData","edit","retrievedSchema","currentErrors","getRegistry","renderErrors","showErrorList","submit","dispatchEvent","CustomEvent","cancelable","tagName","method","action","deprecatedAutocomplete","currentAutoComplete","enctype","acceptcharset","noHtml5Validate","_internalFormWrapper","as","FormTag","encType","acceptCharset","form","withTheme","themeProps","forwardRef","directProps","propTypes","PropTypes","utils","_utils"],"mappings":"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"}