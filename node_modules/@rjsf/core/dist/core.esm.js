import React, { Component, forwardRef } from 'react';
import PropTypes from 'prop-types';
import _pick from 'lodash-es/pick';
import _get from 'lodash-es/get';
import _isEmpty from 'lodash-es/isEmpty';
import includes from 'core-js-pure/es/array/includes';
import { isForwardRef, isMemo } from 'react-is';
import mergeAllOf from 'json-schema-merge-allof';
import fill from 'core-js-pure/features/array/fill';
import union from 'lodash-es/union';
import jsonpointer from 'jsonpointer';
import toPath from 'lodash-es/toPath';
import Ajv from 'ajv';
import { nanoid } from 'nanoid';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];

  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }

  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");

  return typeof key === "symbol" ? key : String(key);
}

function IconButton(props) {
  var _props$type = props.type,
      type = _props$type === void 0 ? "default" : _props$type,
      icon = props.icon,
      className = props.className,
      otherProps = _objectWithoutPropertiesLoose(props, ["type", "icon", "className"]);

  return /*#__PURE__*/React.createElement("button", _extends({
    type: "button",
    className: "btn btn-" + type + " " + className
  }, otherProps), /*#__PURE__*/React.createElement("i", {
    className: "glyphicon glyphicon-" + icon
  }));
}

function AddButton(_ref) {
  var className = _ref.className,
      onClick = _ref.onClick,
      disabled = _ref.disabled;
  return /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("p", {
    className: "col-xs-3 col-xs-offset-9 text-right " + className
  }, /*#__PURE__*/React.createElement(IconButton, {
    type: "info",
    icon: "plus",
    className: "btn-add col-xs-12",
    "aria-label": "Add",
    tabIndex: "0",
    onClick: onClick,
    disabled: disabled
  })));
}

var registry = /*#__PURE__*/PropTypes.shape({
  ArrayFieldTemplate: PropTypes.elementType,
  FieldTemplate: PropTypes.elementType,
  ObjectFieldTemplate: PropTypes.elementType,
  definitions: PropTypes.object.isRequired,
  rootSchema: PropTypes.object,
  fields: /*#__PURE__*/PropTypes.objectOf(PropTypes.elementType).isRequired,
  formContext: PropTypes.object.isRequired,
  widgets: /*#__PURE__*/PropTypes.objectOf( /*#__PURE__*/PropTypes.oneOfType([PropTypes.func, PropTypes.object])).isRequired
});
var fieldProps = {
  autofocus: PropTypes.bool,
  disabled: PropTypes.bool,
  errorSchema: PropTypes.object,
  formData: PropTypes.any,
  idSchema: PropTypes.object,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  rawErrors: /*#__PURE__*/PropTypes.arrayOf(PropTypes.string),
  readonly: PropTypes.bool,
  registry: registry.isRequired,
  required: PropTypes.bool,
  schema: PropTypes.object.isRequired,
  uiSchema: /*#__PURE__*/PropTypes.shape({
    "ui:options": /*#__PURE__*/PropTypes.shape({
      addable: PropTypes.bool,
      orderable: PropTypes.bool,
      removable: PropTypes.bool
    })
  })
};

var ajv = /*#__PURE__*/createAjvInstance();
var formerCustomFormats = null;
var formerMetaSchema = null;
var ROOT_SCHEMA_PREFIX = "__rjsf_rootSchema";

function createAjvInstance() {
  var ajv = new Ajv({
    errorDataPath: "property",
    allErrors: true,
    multipleOfPrecision: 8,
    schemaId: "auto",
    unknownFormats: "ignore"
  }); // add custom formats

  ajv.addFormat("data-url", /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/);
  ajv.addFormat("color", /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/);
  return ajv;
}

function toErrorSchema(errors) {
  // Transforms a ajv validation errors list:
  // [
  //   {property: ".level1.level2[2].level3", message: "err a"},
  //   {property: ".level1.level2[2].level3", message: "err b"},
  //   {property: ".level1.level2[4].level3", message: "err b"},
  // ]
  // Into an error tree:
  // {
  //   level1: {
  //     level2: {
  //       2: {level3: {errors: ["err a", "err b"]}},
  //       4: {level3: {errors: ["err b"]}},
  //     }
  //   }
  // };
  if (!errors.length) {
    return {};
  }

  return errors.reduce(function (errorSchema, error) {
    var property = error.property,
        message = error.message;
    var path = toPath(property);
    var parent = errorSchema; // If the property is at the root (.level1) then toPath creates
    // an empty array element at the first index. Remove it.

    if (path.length > 0 && path[0] === "") {
      path.splice(0, 1);
    }

    for (var _iterator = path.slice(0), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var segment = _ref;

      if (!(segment in parent)) {
        parent[segment] = {};
      }

      parent = parent[segment];
    }

    if (Array.isArray(parent.__errors)) {
      // We store the list of errors for this node in a property named __errors
      // to avoid name collision with a possible sub schema field named
      // "errors" (see `validate.createErrorHandler`).
      parent.__errors = parent.__errors.concat(message);
    } else {
      if (message) {
        parent.__errors = [message];
      }
    }

    return errorSchema;
  }, {});
}

function toErrorList(errorSchema, fieldName) {
  if (fieldName === void 0) {
    fieldName = "root";
  }

  // XXX: We should transform fieldName as a full field path string.
  var errorList = [];

  if ("__errors" in errorSchema) {
    errorList = errorList.concat(errorSchema.__errors.map(function (stack) {
      return {
        stack: fieldName + ": " + stack
      };
    }));
  }

  return Object.keys(errorSchema).reduce(function (acc, key) {
    if (key !== "__errors") {
      acc = acc.concat(toErrorList(errorSchema[key], key));
    }

    return acc;
  }, errorList);
}

function createErrorHandler(formData) {
  var handler = {
    // We store the list of errors for this node in a property named __errors
    // to avoid name collision with a possible sub schema field named
    // "errors" (see `utils.toErrorSchema`).
    __errors: [],
    addError: function addError(message) {
      this.__errors.push(message);
    }
  };

  if (isObject(formData)) {
    return Object.keys(formData).reduce(function (acc, key) {
      var _extends2;

      return _extends({}, acc, (_extends2 = {}, _extends2[key] = createErrorHandler(formData[key]), _extends2));
    }, handler);
  }

  if (Array.isArray(formData)) {
    return formData.reduce(function (acc, value, key) {
      var _extends3;

      return _extends({}, acc, (_extends3 = {}, _extends3[key] = createErrorHandler(value), _extends3));
    }, handler);
  }

  return handler;
}

function unwrapErrorHandler(errorHandler) {
  return Object.keys(errorHandler).reduce(function (acc, key) {
    var _extends5;

    if (key === "addError") {
      return acc;
    } else if (key === "__errors") {
      var _extends4;

      return _extends({}, acc, (_extends4 = {}, _extends4[key] = errorHandler[key], _extends4));
    }

    return _extends({}, acc, (_extends5 = {}, _extends5[key] = unwrapErrorHandler(errorHandler[key]), _extends5));
  }, {});
}
/**
 * Transforming the error output from ajv to format used by jsonschema.
 * At some point, components should be updated to support ajv.
 */


function transformAjvErrors(errors) {
  if (errors === void 0) {
    errors = [];
  }

  if (errors === null) {
    return [];
  }

  return errors.map(function (e) {
    var dataPath = e.dataPath,
        keyword = e.keyword,
        message = e.message,
        params = e.params,
        schemaPath = e.schemaPath;
    var property = "" + dataPath; // put data in expected format

    return {
      name: keyword,
      property: property,
      message: message,
      params: params,
      // specific to ajv
      stack: (property + " " + message).trim(),
      schemaPath: schemaPath
    };
  });
}
/**
 * This function processes the formData with a user `validate` contributed
 * function, which receives the form data and an `errorHandler` object that
 * will be used to add custom validation errors for each field.
 */


function validateFormData(formData, schema, customValidate, transformErrors, additionalMetaSchemas, customFormats) {
  if (additionalMetaSchemas === void 0) {
    additionalMetaSchemas = [];
  }

  if (customFormats === void 0) {
    customFormats = {};
  }

  // Include form data with undefined values, which is required for validation.
  var rootSchema = schema;
  formData = getDefaultFormState(schema, formData, rootSchema, true);
  var newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);
  var newFormats = !deepEquals(formerCustomFormats, customFormats);

  if (newMetaSchemas || newFormats) {
    ajv = createAjvInstance();
  } // add more schemas to validate against


  if (additionalMetaSchemas && newMetaSchemas && Array.isArray(additionalMetaSchemas)) {
    ajv.addMetaSchema(additionalMetaSchemas);
    formerMetaSchema = additionalMetaSchemas;
  } // add more custom formats to validate against


  if (customFormats && newFormats && isObject(customFormats)) {
    Object.keys(customFormats).forEach(function (formatName) {
      ajv.addFormat(formatName, customFormats[formatName]);
    });
    formerCustomFormats = customFormats;
  }

  var validationError = null;

  try {
    ajv.validate(schema, formData);
  } catch (err) {
    validationError = err;
  }

  var errors = transformAjvErrors(ajv.errors); // Clear errors to prevent persistent errors, see #1104

  ajv.errors = null;
  var noProperMetaSchema = validationError && validationError.message && typeof validationError.message === "string" && validationError.message.includes("no schema with key or ref ");

  if (noProperMetaSchema) {
    errors = [].concat(errors, [{
      stack: validationError.message
    }]);
  }

  if (typeof transformErrors === "function") {
    errors = transformErrors(errors);
  }

  var errorSchema = toErrorSchema(errors);

  if (noProperMetaSchema) {
    errorSchema = _extends({}, errorSchema, {
      $schema: {
        __errors: [validationError.message]
      }
    });
  }

  if (typeof customValidate !== "function") {
    return {
      errors: errors,
      errorSchema: errorSchema
    };
  }

  var errorHandler = customValidate(formData, createErrorHandler(formData));
  var userErrorSchema = unwrapErrorHandler(errorHandler);
  var newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true); // XXX: The errors list produced is not fully compliant with the format
  // exposed by the jsonschema lib, which contains full field paths and other
  // properties.

  var newErrors = toErrorList(newErrorSchema);
  return {
    errors: newErrors,
    errorSchema: newErrorSchema
  };
}
/**
 * Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`
 * This is used in isValid to make references to the rootSchema
 */

function withIdRefPrefix(schemaNode) {
  var obj = schemaNode;

  if (schemaNode.constructor === Object) {
    obj = _extends({}, schemaNode);

    for (var key in obj) {
      var value = obj[key];

      if (key === "$ref" && typeof value === "string" && value.startsWith("#")) {
        obj[key] = ROOT_SCHEMA_PREFIX + value;
      } else {
        obj[key] = withIdRefPrefix(value);
      }
    }
  } else if (Array.isArray(schemaNode)) {
    obj = [].concat(schemaNode);

    for (var i = 0; i < obj.length; i++) {
      obj[i] = withIdRefPrefix(obj[i]);
    }
  }

  return obj;
}
/**
 * Validates data against a schema, returning true if the data is valid, or
 * false otherwise. If the schema is invalid, then this function will return
 * false.
 */

function isValid(schema, data, rootSchema) {
  try {
    // add the rootSchema ROOT_SCHEMA_PREFIX as id.
    // then rewrite the schema ref's to point to the rootSchema
    // this accounts for the case where schema have references to models
    // that lives in the rootSchema but not in the schema in question.
    return ajv.addSchema(rootSchema, ROOT_SCHEMA_PREFIX).validate(withIdRefPrefix(schema), data);
  } catch (e) {
    return false;
  } finally {
    // make sure we remove the rootSchema from the global ajv instance
    ajv.removeSchema(ROOT_SCHEMA_PREFIX);
  }
}

var ADDITIONAL_PROPERTY_FLAG = "__additional_property";
var widgetMap = {
  "boolean": {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
function canExpand(schema, uiSchema, formData) {
  if (!schema.additionalProperties) {
    return false;
  }

  var _getUiOptions = getUiOptions(uiSchema),
      expandable = _getUiOptions.expandable;

  if (expandable === false) {
    return expandable;
  } // if ui:options.expandable was not explicitly set to false, we can add
  // another property if we have not exceeded maxProperties yet


  if (schema.maxProperties !== undefined) {
    return Object.keys(formData).length < schema.maxProperties;
  }

  return true;
}
/* Gets the type of a given schema. */

function getSchemaType(schema) {
  var type = schema.type;

  if (!type && schema["const"]) {
    return guessType(schema["const"]);
  }

  if (!type && schema["enum"]) {
    return "string";
  }

  if (!type && (schema.properties || schema.additionalProperties)) {
    return "object";
  }

  if (type instanceof Array && type.length === 2 && type.includes("null")) {
    return type.find(function (type) {
      return type !== "null";
    });
  }

  return type;
}
function getWidget(schema, widget, registeredWidgets) {
  if (registeredWidgets === void 0) {
    registeredWidgets = {};
  }

  var type = getSchemaType(schema);

  function mergeOptions(Widget) {
    // cache return value as property of widget for proper react reconciliation
    if (!Widget.MergedWidget) {
      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};

      Widget.MergedWidget = function (_ref) {
        var _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            props = _objectWithoutPropertiesLoose(_ref, ["options"]);

        return /*#__PURE__*/React.createElement(Widget, _extends({
          options: _extends({}, defaultOptions, options)
        }, props));
      };
    }

    return Widget.MergedWidget;
  }

  if (typeof widget === "function" || isForwardRef(React.createElement(widget)) || isMemo(widget)) {
    return mergeOptions(widget);
  }

  if (typeof widget !== "string") {
    throw new Error("Unsupported widget definition: " + typeof widget);
  }

  if (registeredWidgets.hasOwnProperty(widget)) {
    var registeredWidget = registeredWidgets[widget];
    return getWidget(schema, registeredWidget, registeredWidgets);
  }

  if (!widgetMap.hasOwnProperty(type)) {
    throw new Error("No widget for type \"" + type + "\"");
  }

  if (widgetMap[type].hasOwnProperty(widget)) {
    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];
    return getWidget(schema, _registeredWidget, registeredWidgets);
  }

  throw new Error("No widget \"" + widget + "\" for type \"" + type + "\"");
}
function hasWidget(schema, widget, registeredWidgets) {
  if (registeredWidgets === void 0) {
    registeredWidgets = {};
  }

  try {
    getWidget(schema, widget, registeredWidgets);
    return true;
  } catch (e) {
    if (e.message && (e.message.startsWith("No widget") || e.message.startsWith("Unsupported widget"))) {
      return false;
    }

    throw e;
  }
}

function computeDefaults(_schema, parentDefaults, rootSchema, rawFormData, includeUndefinedValues) {
  if (rawFormData === void 0) {
    rawFormData = {};
  }

  if (includeUndefinedValues === void 0) {
    includeUndefinedValues = false;
  }

  var schema = isObject(_schema) ? _schema : {};
  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.

  var defaults = parentDefaults;

  if (isObject(defaults) && isObject(schema["default"])) {
    // For object defaults, only override parent defaults that are defined in
    // schema.default.
    defaults = mergeObjects(defaults, schema["default"]);
  } else if ("default" in schema) {
    // Use schema defaults for this node.
    defaults = schema["default"];
  } else if ("$ref" in schema) {
    // Use referenced schema defaults for this node.
    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);
    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if ("dependencies" in schema) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if (isFixedItems(schema)) {
    defaults = schema.items.map(function (itemSchema, idx) {
      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);
    });
  } else if ("oneOf" in schema) {
    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];
  } else if ("anyOf" in schema) {
    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];
  } // Not defaults defined for this node, fallback to generic typed ones.


  if (typeof defaults === "undefined") {
    defaults = schema["default"];
  }

  switch (getSchemaType(schema)) {
    // We need to recur for object schema inner default values.
    case "object":
      return Object.keys(schema.properties || {}).reduce(function (acc, key) {
        // Compute the defaults for this node, with the parent defaults we might
        // have from a previous run: defaults[key].
        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);

        if (includeUndefinedValues || computedDefault !== undefined) {
          acc[key] = computedDefault;
        }

        return acc;
      }, {});

    case "array":
      // Inject defaults into existing array defaults
      if (Array.isArray(defaults)) {
        defaults = defaults.map(function (item, idx) {
          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);
        });
      } // Deeply inject defaults into already existing form data


      if (Array.isArray(rawFormData)) {
        defaults = rawFormData.map(function (item, idx) {
          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);
        });
      }

      if (schema.minItems) {
        if (!isMultiSelect(schema, rootSchema)) {
          var defaultsLength = defaults ? defaults.length : 0;

          if (schema.minItems > defaultsLength) {
            var defaultEntries = defaults || []; // populate the array with the defaults

            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;
            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems

            return defaultEntries.concat(fillerEntries);
          }
        } else {
          return defaults ? defaults : [];
        }
      }

  }

  return defaults;
}

function getDefaultFormState(_schema, formData, rootSchema, includeUndefinedValues) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  if (includeUndefinedValues === void 0) {
    includeUndefinedValues = false;
  }

  if (!isObject(_schema)) {
    throw new Error("Invalid schema: " + _schema);
  }

  var schema = retrieveSchema(_schema, rootSchema, formData);
  var defaults = computeDefaults(schema, _schema["default"], rootSchema, formData, includeUndefinedValues);

  if (typeof formData === "undefined") {
    // No form data? Use schema defaults.
    return defaults;
  }

  if (isObject(formData) || Array.isArray(formData)) {
    return mergeDefaultsWithFormData(defaults, formData);
  }

  if (formData === 0 || formData === false || formData === "") {
    return formData;
  }

  return formData || defaults;
}
/**
 * When merging defaults and form data, we want to merge in this specific way:
 * - objects are deeply merged
 * - arrays are merged in such a way that:
 *   - when the array is set in form data, only array entries set in form data
 *     are deeply merged; additional entries from the defaults are ignored
 *   - when the array is not set in form data, the default is copied over
 * - scalars are overwritten/set by form data
 */

function mergeDefaultsWithFormData(defaults, formData) {
  if (Array.isArray(formData)) {
    if (!Array.isArray(defaults)) {
      defaults = [];
    }

    return formData.map(function (value, idx) {
      if (defaults[idx]) {
        return mergeDefaultsWithFormData(defaults[idx], value);
      }

      return value;
    });
  } else if (isObject(formData)) {
    var acc = Object.assign({}, defaults); // Prevent mutation of source object.

    return Object.keys(formData).reduce(function (acc, key) {
      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);
      return acc;
    }, acc);
  } else {
    return formData;
  }
}
function getUiOptions(uiSchema) {
  // get all passed options from ui:widget, ui:options, and ui:<optionName>
  return Object.keys(uiSchema).filter(function (key) {
    return key.indexOf("ui:") === 0;
  }).reduce(function (options, key) {
    var _extends2;

    var value = uiSchema[key];

    if (key === "ui:widget" && isObject(value)) {
      console.warn("Setting options via ui:widget object is deprecated, use ui:options instead");
      return _extends({}, options, value.options || {}, {
        widget: value.component
      });
    }

    if (key === "ui:options" && isObject(value)) {
      return _extends({}, options, value);
    }

    return _extends({}, options, (_extends2 = {}, _extends2[key.substring(3)] = value, _extends2));
  }, {});
}
function getSubmitButtonOptions(uiSchema) {
  var uiOptions = getUiOptions(uiSchema);
  var defaultOptions = {
    props: {
      disabled: false
    },
    submitText: "Submit",
    norender: false
  };

  if (uiOptions && uiOptions["submitButtonOptions"]) {
    return Object.assign({}, defaultOptions, uiOptions["submitButtonOptions"]);
  }

  return defaultOptions;
}
function getDisplayLabel(schema, uiSchema, rootSchema) {
  var uiOptions = getUiOptions(uiSchema);
  var _uiOptions$label = uiOptions.label,
      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;
  var schemaType = getSchemaType(schema);

  if (schemaType === "array") {
    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema) || isCustomWidget(uiSchema);
  }

  if (schemaType === "object") {
    displayLabel = false;
  }

  if (schemaType === "boolean" && !uiSchema["ui:widget"]) {
    displayLabel = false;
  }

  if (uiSchema["ui:field"]) {
    displayLabel = false;
  }

  return displayLabel;
}
function isObject(thing) {
  if (typeof File !== "undefined" && thing instanceof File) {
    return false;
  }

  return typeof thing === "object" && thing !== null && !Array.isArray(thing);
}
function mergeObjects(obj1, obj2, concatArrays) {
  if (concatArrays === void 0) {
    concatArrays = false;
  }

  // Recursively merge deeply nested objects.
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeObjects(left, right, concatArrays);
    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
      acc[key] = left.concat(right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}
function asNumber(value) {
  if (value === "") {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  if (/\.$/.test(value)) {
    // "3." can't really be considered a number even if it parses in js. The
    // user is most likely entering a float.
    return value;
  }

  if (/\.0$/.test(value)) {
    // we need to return this as a string here, to allow for input like 3.07
    return value;
  }

  var n = Number(value);
  var valid = typeof n === "number" && !Number.isNaN(n);

  if (/\.\d*0$/.test(value)) {
    // It's a number, that's cool - but we need it as a string so it doesn't screw
    // with the user when entering dollar amounts or other values (such as those with
    // specific precision or number of significant digits)
    return value;
  }

  return valid ? n : value;
}
function orderProperties(properties, order) {
  if (!Array.isArray(order)) {
    return properties;
  }

  var arrayToHash = function arrayToHash(arr) {
    return arr.reduce(function (prev, curr) {
      prev[curr] = true;
      return prev;
    }, {});
  };

  var errorPropList = function errorPropList(arr) {
    return arr.length > 1 ? "properties '" + arr.join("', '") + "'" : "property '" + arr[0] + "'";
  };

  var propertyHash = arrayToHash(properties);
  var orderFiltered = order.filter(function (prop) {
    return prop === "*" || propertyHash[prop];
  });
  var orderHash = arrayToHash(orderFiltered);
  var rest = properties.filter(function (prop) {
    return !orderHash[prop];
  });
  var restIndex = orderFiltered.indexOf("*");

  if (restIndex === -1) {
    if (rest.length) {
      throw new Error("uiSchema order list does not contain " + errorPropList(rest));
    }

    return orderFiltered;
  }

  if (restIndex !== orderFiltered.lastIndexOf("*")) {
    throw new Error("uiSchema order list contains more than one wildcard item");
  }

  var complete = [].concat(orderFiltered);
  complete.splice.apply(complete, [restIndex, 1].concat(rest));
  return complete;
}
/**
 * This function checks if the given schema matches a single
 * constant value.
 */

function isConstant(schema) {
  return Array.isArray(schema["enum"]) && schema["enum"].length === 1 || schema.hasOwnProperty("const");
}
function toConstant(schema) {
  if (Array.isArray(schema["enum"]) && schema["enum"].length === 1) {
    return schema["enum"][0];
  } else if (schema.hasOwnProperty("const")) {
    return schema["const"];
  } else {
    throw new Error("schema cannot be inferred as a constant");
  }
}
function isSelect(_schema, rootSchema) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  var schema = retrieveSchema(_schema, rootSchema);
  var altSchemas = schema.oneOf || schema.anyOf;

  if (Array.isArray(schema["enum"])) {
    return true;
  } else if (Array.isArray(altSchemas)) {
    return altSchemas.every(function (altSchemas) {
      return isConstant(altSchemas);
    });
  }

  return false;
}
function isMultiSelect(schema, rootSchema) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  if (!schema.uniqueItems || !schema.items) {
    return false;
  }

  return isSelect(schema.items, rootSchema);
}
function isFilesArray(schema, uiSchema, rootSchema) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  if (uiSchema["ui:widget"] === "files") {
    return true;
  } else if (schema.items) {
    var itemsSchema = retrieveSchema(schema.items, rootSchema);
    return itemsSchema.type === "string" && itemsSchema.format === "data-url";
  }

  return false;
}
function isFixedItems(schema) {
  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {
    return isObject(item);
  });
}
function isCustomWidget(uiSchema) {
  return (// TODO: Remove the `&& uiSchema["ui:widget"] !== "hidden"` once we support hidden widgets for arrays.
    // https://react-jsonschema-form.readthedocs.io/en/latest/usage/widgets/#hidden-widgets
    "widget" in getUiOptions(uiSchema) && getUiOptions(uiSchema)["widget"] !== "hidden"
  );
}
function allowAdditionalItems(schema) {
  if (schema.additionalItems === true) {
    console.warn("additionalItems=true is currently not supported");
  }

  return isObject(schema.additionalItems);
}
function optionsList(schema) {
  if (schema["enum"]) {
    return schema["enum"].map(function (value, i) {
      var label = schema.enumNames && schema.enumNames[i] || String(value);
      return {
        label: label,
        value: value
      };
    });
  } else {
    var altSchemas = schema.oneOf || schema.anyOf;
    return altSchemas.map(function (schema) {
      var value = toConstant(schema);
      var label = schema.title || String(value);
      return {
        schema: schema,
        label: label,
        value: value
      };
    });
  }
}
function findSchemaDefinition($ref, rootSchema) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  var origRef = $ref;

  if ($ref.startsWith("#")) {
    // Decode URI fragment representation.
    $ref = decodeURIComponent($ref.substring(1));
  } else {
    throw new Error("Could not find a definition for " + origRef + ".");
  }

  var current = jsonpointer.get(rootSchema, $ref);

  if (current === undefined) {
    throw new Error("Could not find a definition for " + origRef + ".");
  }

  if (current.hasOwnProperty("$ref")) {
    return findSchemaDefinition(current.$ref, rootSchema);
  }

  return current;
} // In the case where we have to implicitly create a schema, it is useful to know what type to use
//  based on the data we are defining

var guessType = function guessType(value) {
  if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "string") {
    return "string";
  } else if (value == null) {
    return "null";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (!isNaN(value)) {
    return "number";
  } else if (typeof value === "object") {
    return "object";
  } // Default to string if we can't figure it out


  return "string";
}; // This function will create new "properties" items for each key in our formData

function stubExistingAdditionalProperties(schema, rootSchema, formData) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  if (formData === void 0) {
    formData = {};
  }

  // Clone the schema so we don't ruin the consumer's original
  schema = _extends({}, schema, {
    properties: _extends({}, schema.properties)
  }); // make sure formData is an object

  formData = isObject(formData) ? formData : {};
  Object.keys(formData).forEach(function (key) {
    if (schema.properties.hasOwnProperty(key)) {
      // No need to stub, our schema already has the property
      return;
    }

    var additionalProperties;

    if (schema.additionalProperties.hasOwnProperty("$ref")) {
      additionalProperties = retrieveSchema({
        $ref: schema.additionalProperties["$ref"]
      }, rootSchema, formData);
    } else if (schema.additionalProperties.hasOwnProperty("type")) {
      additionalProperties = _extends({}, schema.additionalProperties);
    } else {
      additionalProperties = {
        type: guessType(formData[key])
      };
    } // The type of our new key should match the additionalProperties value;


    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added

    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;
  });
  return schema;
}
/**
 * Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch with the rest of the schema
 */

var resolveCondition = function resolveCondition(schema, rootSchema, formData) {
  var expression = schema["if"],
      then = schema.then,
      otherwise = schema["else"],
      resolvedSchemaLessConditional = _objectWithoutPropertiesLoose(schema, ["if", "then", "else"]);

  var conditionalSchema = isValid(expression, formData, rootSchema) ? then : otherwise;

  if (conditionalSchema) {
    return retrieveSchema(mergeSchemas(resolvedSchemaLessConditional, retrieveSchema(conditionalSchema, rootSchema, formData)), rootSchema, formData);
  } else {
    return retrieveSchema(resolvedSchemaLessConditional, rootSchema, formData);
  }
};
/**
 * Resolves references and dependencies within a schema and its 'allOf' children.
 *
 * Called internally by retrieveSchema.
 */


function resolveSchema(schema, rootSchema, formData) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  if (formData === void 0) {
    formData = {};
  }

  if (schema.hasOwnProperty("$ref")) {
    return resolveReference(schema, rootSchema, formData);
  } else if (schema.hasOwnProperty("dependencies")) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return retrieveSchema(resolvedSchema, rootSchema, formData);
  } else if (schema.hasOwnProperty("allOf")) {
    return _extends({}, schema, {
      allOf: schema.allOf.map(function (allOfSubschema) {
        return retrieveSchema(allOfSubschema, rootSchema, formData);
      })
    });
  } else {
    // No $ref or dependencies attribute found, returning the original schema.
    return schema;
  }
}

function resolveReference(schema, rootSchema, formData) {
  // Retrieve the referenced schema definition.
  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.

  var localSchema = _objectWithoutPropertiesLoose(schema, ["$ref"]); // Update referenced schema definition with local schema properties.


  return retrieveSchema(_extends({}, $refSchema, localSchema), rootSchema, formData);
}

function retrieveSchema(schema, rootSchema, formData) {
  if (rootSchema === void 0) {
    rootSchema = {};
  }

  if (formData === void 0) {
    formData = {};
  }

  if (!isObject(schema)) {
    return {};
  }

  var resolvedSchema = resolveSchema(schema, rootSchema, formData);

  if (schema.hasOwnProperty("if")) {
    return resolveCondition(schema, rootSchema, formData);
  } // For each level of the dependency, we need to recursively determine the appropriate resolved schema given the current state of formData.
  // Otherwise, nested allOf subschemas will not be correctly displayed.


  if (resolvedSchema.properties) {
    var properties = {};
    Object.entries(resolvedSchema.properties).forEach(function (entries) {
      var propName = entries[0];
      var propSchema = entries[1];
      var rawPropData = formData && formData[propName];
      var propData = isObject(rawPropData) ? rawPropData : {};
      var resolvedPropSchema = retrieveSchema(propSchema, rootSchema, propData);
      properties[propName] = resolvedPropSchema;

      if (propSchema !== resolvedPropSchema && resolvedSchema.properties !== properties) {
        resolvedSchema = _extends({}, resolvedSchema, {
          properties: properties
        });
      }
    });
  }

  if ("allOf" in schema) {
    try {
      resolvedSchema = mergeAllOf(_extends({}, resolvedSchema, {
        allOf: resolvedSchema.allOf
      }));
    } catch (e) {
      console.warn("could not merge subschemas in allOf:\n" + e);

      var _resolvedSchema = resolvedSchema,
          resolvedSchemaWithoutAllOf = _objectWithoutPropertiesLoose(_resolvedSchema, ["allOf"]);

      return resolvedSchemaWithoutAllOf;
    }
  }

  var hasAdditionalProperties = resolvedSchema.hasOwnProperty("additionalProperties") && resolvedSchema.additionalProperties !== false;

  if (hasAdditionalProperties) {
    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function resolveDependencies(schema, rootSchema, formData) {
  // Drop the dependencies from the source schema.
  var _schema$dependencies = schema.dependencies,
      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,
      resolvedSchema = _objectWithoutPropertiesLoose(schema, ["dependencies"]);

  if ("oneOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];
  } else if ("anyOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];
  }

  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);
}

function processDependencies(dependencies, resolvedSchema, rootSchema, formData) {
  // Process dependencies updating the local schema properties as appropriate.
  for (var dependencyKey in dependencies) {
    // Skip this dependency if its trigger property is not present.
    if (formData[dependencyKey] === undefined) {
      continue;
    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)


    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
      continue;
    }

    var dependencyValue = dependencies[dependencyKey],
        remainingDependencies = _objectWithoutPropertiesLoose(dependencies, [dependencyKey].map(_toPropertyKey));

    if (Array.isArray(dependencyValue)) {
      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);
    } else if (isObject(dependencyValue)) {
      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);
    }

    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function withDependentProperties(schema, additionallyRequired) {
  if (!additionallyRequired) {
    return schema;
  }

  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(schema.required, additionallyRequired))) : additionallyRequired;
  return _extends({}, schema, {
    required: required
  });
}

function withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {
  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),
      oneOf = _retrieveSchema.oneOf,
      dependentSchema = _objectWithoutPropertiesLoose(_retrieveSchema, ["oneOf"]);

  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.

  if (oneOf === undefined) {
    return schema;
  } else if (!Array.isArray(oneOf)) {
    throw new Error("invalid: it is some " + typeof oneOf + " instead of an array");
  } // Resolve $refs inside oneOf.


  var resolvedOneOf = oneOf.map(function (subschema) {
    return subschema.hasOwnProperty("$ref") ? resolveReference(subschema, rootSchema, formData) : subschema;
  });
  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);
}

function withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {
  var validSubschemas = oneOf.filter(function (subschema) {
    if (!subschema.properties) {
      return false;
    }

    var conditionPropertySchema = subschema.properties[dependencyKey];

    if (conditionPropertySchema) {
      var _properties;

      var conditionSchema = {
        type: "object",
        properties: (_properties = {}, _properties[dependencyKey] = conditionPropertySchema, _properties)
      };

      var _validateFormData = validateFormData(formData, conditionSchema),
          errors = _validateFormData.errors;

      return errors.length === 0;
    }
  });

  if (validSubschemas.length !== 1) {
    console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
    return schema;
  }

  var subschema = validSubschemas[0];

  var _subschema$properties = subschema.properties,
      dependentSubschema = _objectWithoutPropertiesLoose(_subschema$properties, [dependencyKey].map(_toPropertyKey));

  var dependentSchema = _extends({}, subschema, {
    properties: dependentSubschema
  });

  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));
} // Recursively merge deeply nested schemas.
// The difference between mergeSchemas and mergeObjects
// is that mergeSchemas only concats arrays for
// values under the "required" keyword, and when it does,
// it doesn't include duplicate values.


function mergeSchemas(obj1, obj2) {
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeSchemas(left, right);
    } else if (obj1 && obj2 && (getSchemaType(obj1) === "object" || getSchemaType(obj2) === "object") && key === "required" && Array.isArray(left) && Array.isArray(right)) {
      // Don't include duplicate values when merging
      // "required" fields.
      acc[key] = union(left, right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}

function isArguments(object) {
  return Object.prototype.toString.call(object) === "[object Arguments]";
}

function deepEquals(a, b, ca, cb) {
  if (ca === void 0) {
    ca = [];
  }

  if (cb === void 0) {
    cb = [];
  }

  // Partially extracted from node-deeper and adapted to exclude comparison
  // checks for functions.
  // https://github.com/othiym23/node-deeper
  if (a === b) {
    return true;
  } else if (typeof a === "function" || typeof b === "function") {
    // Assume all functions are equivalent
    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255
    return true;
  } else if (typeof a !== "object" || typeof b !== "object") {
    return false;
  } else if (a === null || b === null) {
    return false;
  } else if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  } else if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;
  } else if (isArguments(a) || isArguments(b)) {
    if (!(isArguments(a) && isArguments(b))) {
      return false;
    }

    var slice = Array.prototype.slice;
    return deepEquals(slice.call(a), slice.call(b), ca, cb);
  } else {
    if (a.constructor !== b.constructor) {
      return false;
    }

    var ka = Object.keys(a);
    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there

    if (ka.length === 0 && kb.length === 0) {
      return true;
    }

    if (ka.length !== kb.length) {
      return false;
    }

    var cal = ca.length;

    while (cal--) {
      if (ca[cal] === a) {
        return cb[cal] === b;
      }
    }

    ca.push(a);
    cb.push(b);
    ka.sort();
    kb.sort();

    for (var j = ka.length - 1; j >= 0; j--) {
      if (ka[j] !== kb[j]) {
        return false;
      }
    }

    var key;

    for (var k = ka.length - 1; k >= 0; k--) {
      key = ka[k];

      if (!deepEquals(a[key], b[key], ca, cb)) {
        return false;
      }
    }

    ca.pop();
    cb.pop();
    return true;
  }
}
function shouldRender(comp, nextProps, nextState) {
  var props = comp.props,
      state = comp.state;
  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);
}
function toIdSchema(schema, id, rootSchema, formData, idPrefix, idSeparator) {
  if (formData === void 0) {
    formData = {};
  }

  if (idPrefix === void 0) {
    idPrefix = "root";
  }

  if (idSeparator === void 0) {
    idSeparator = "_";
  }

  var idSchema = {
    $id: id || idPrefix
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toIdSchema(_schema, id, rootSchema, formData, idPrefix, idSeparator);
  }

  if ("items" in schema && !schema.items.$ref) {
    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix, idSeparator);
  }

  if (schema.type !== "object") {
    return idSchema;
  }

  for (var name in schema.properties || {}) {
    var field = schema.properties[name];
    var fieldId = idSchema.$id + idSeparator + name;
    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an
    // array item has just been added, but not populated with data yet
    (formData || {})[name], idPrefix, idSeparator);
  }

  return idSchema;
}
function toPathSchema(schema, name, rootSchema, formData) {
  if (name === void 0) {
    name = "";
  }

  if (formData === void 0) {
    formData = {};
  }

  var pathSchema = {
    $name: name.replace(/^\./, "")
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toPathSchema(_schema, name, rootSchema, formData);
  }

  if (schema.hasOwnProperty("additionalProperties")) {
    pathSchema.__rjsf_additionalProperties = true;
  }

  if (schema.hasOwnProperty("items") && Array.isArray(formData)) {
    formData.forEach(function (element, i) {
      pathSchema[i] = toPathSchema(schema.items, name + "." + i, rootSchema, element);
    });
  } else if (schema.hasOwnProperty("properties")) {
    for (var property in schema.properties) {
      pathSchema[property] = toPathSchema(schema.properties[property], name + "." + property, rootSchema, // It's possible that formData is not an object -- this can happen if an
      // array item has just been added, but not populated with data yet
      (formData || {})[property]);
    }
  }

  return pathSchema;
}
function parseDateString(dateString, includeTime) {
  if (includeTime === void 0) {
    includeTime = true;
  }

  if (!dateString) {
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: includeTime ? -1 : 0,
      minute: includeTime ? -1 : 0,
      second: includeTime ? -1 : 0
    };
  }

  var date = new Date(dateString);

  if (Number.isNaN(date.getTime())) {
    throw new Error("Unable to parse date " + dateString);
  }

  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    // oh you, javascript.
    day: date.getUTCDate(),
    hour: includeTime ? date.getUTCHours() : 0,
    minute: includeTime ? date.getUTCMinutes() : 0,
    second: includeTime ? date.getUTCSeconds() : 0
  };
}
function toDateString(_ref2, time) {
  var year = _ref2.year,
      month = _ref2.month,
      day = _ref2.day,
      _ref2$hour = _ref2.hour,
      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,
      _ref2$minute = _ref2.minute,
      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,
      _ref2$second = _ref2.second,
      second = _ref2$second === void 0 ? 0 : _ref2$second;

  if (time === void 0) {
    time = true;
  }

  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);
  var datetime = new Date(utcTime).toJSON();
  return time ? datetime : datetime.slice(0, 10);
}
function utcToLocal(jsonDate) {
  if (!jsonDate) {
    return "";
  } // required format of `"yyyy-MM-ddThh:mm" followed by optional ":ss" or ":ss.SSS"
  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)
  // > should be a _valid local date and time string_ (not GMT)
  // Note - date constructor passed local ISO-8601 does not correctly
  // change time to UTC in node pre-8


  var date = new Date(jsonDate);
  var yyyy = pad(date.getFullYear(), 4);
  var MM = pad(date.getMonth() + 1, 2);
  var dd = pad(date.getDate(), 2);
  var hh = pad(date.getHours(), 2);
  var mm = pad(date.getMinutes(), 2);
  var ss = pad(date.getSeconds(), 2);
  var SSS = pad(date.getMilliseconds(), 3);
  return yyyy + "-" + MM + "-" + dd + "T" + hh + ":" + mm + ":" + ss + "." + SSS;
}
function localToUTC(dateString) {
  if (dateString) {
    return new Date(dateString).toJSON();
  }
}
function pad(num, size) {
  var s = String(num);

  while (s.length < size) {
    s = "0" + s;
  }

  return s;
}
function dataURItoBlob(dataURI) {
  // Split metadata from data
  var splitted = dataURI.split(","); // Split params

  var params = splitted[0].split(";"); // Get mime-type from params

  var type = params[0].replace("data:", ""); // Filter the name property from params

  var properties = params.filter(function (param) {
    return param.split("=")[0] === "name";
  }); // Look for the name and use unknown if no name property.

  var name;

  if (properties.length !== 1) {
    name = "unknown";
  } else {
    // Because we filtered out the other property,
    // we only have the name case here.
    name = properties[0].split("=")[1];
  } // Built the Uint8Array Blob parameter from the base64 string.


  var binary = atob(splitted[1]);
  var array = [];

  for (var i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  } // Create the blob object


  var blob = new window.Blob([new Uint8Array(array)], {
    type: type
  });
  return {
    blob: blob,
    name: name
  };
}
function rangeSpec(schema) {
  var spec = {};

  if (schema.multipleOf) {
    spec.step = schema.multipleOf;
  }

  if (schema.minimum || schema.minimum === 0) {
    spec.min = schema.minimum;
  }

  if (schema.maximum || schema.maximum === 0) {
    spec.max = schema.maximum;
  }

  return spec;
}
function getMatchingOption(formData, options, rootSchema) {
  // For performance, skip validating subschemas if formData is undefined. We just
  // want to get the first option in that case.
  if (formData === undefined) {
    return 0;
  }

  for (var i = 0; i < options.length; i++) {
    var option = options[i]; // If the schema describes an object then we need to add slightly more
    // strict matching to the schema, because unless the schema uses the
    // "requires" keyword, an object will match the schema as long as it
    // doesn't have matching keys with a conflicting type. To do this we use an
    // "anyOf" with an array of requires. This augmentation expresses that the
    // schema should match if any of the keys in the schema are present on the
    // object and pass validation.

    if (option.properties) {
      // Create an "anyOf" schema that requires at least one of the keys in the
      // "properties" object
      var requiresAnyOf = {
        anyOf: Object.keys(option.properties).map(function (key) {
          return {
            required: [key]
          };
        })
      };
      var augmentedSchema = void 0; // If the "anyOf" keyword already exists, wrap the augmentation in an "allOf"

      if (option.anyOf) {
        // Create a shallow clone of the option
        var shallowClone = _extends({}, option);

        if (!shallowClone.allOf) {
          shallowClone.allOf = [];
        } else {
          // If "allOf" already exists, shallow clone the array
          shallowClone.allOf = shallowClone.allOf.slice();
        }

        shallowClone.allOf.push(requiresAnyOf);
        augmentedSchema = shallowClone;
      } else {
        augmentedSchema = Object.assign({}, option, requiresAnyOf);
      } // Remove the "required" field as it's likely that not all fields have
      // been filled in yet, which will mean that the schema is not valid


      delete augmentedSchema.required;

      if (isValid(augmentedSchema, formData, rootSchema)) {
        return i;
      }
    } else if (isValid(option, formData, rootSchema)) {
      return i;
    }
  }

  return 0;
} // Check to see if a schema specifies that a value must be true

function schemaRequiresTrueValue(schema) {
  // Check if const is a truthy value
  if (schema["const"]) {
    return true;
  } // Check if an enum has a single value of true


  if (schema["enum"] && schema["enum"].length === 1 && schema["enum"][0] === true) {
    return true;
  } // If anyOf has a single value, evaluate the subschema


  if (schema.anyOf && schema.anyOf.length === 1) {
    return schemaRequiresTrueValue(schema.anyOf[0]);
  } // If oneOf has a single value, evaluate the subschema


  if (schema.oneOf && schema.oneOf.length === 1) {
    return schemaRequiresTrueValue(schema.oneOf[0]);
  } // Evaluate each subschema in allOf, to see if one of them requires a true
  // value


  if (schema.allOf) {
    return schema.allOf.some(schemaRequiresTrueValue);
  }

  return false;
}

var _utils = {
  __proto__: null,
  ADDITIONAL_PROPERTY_FLAG: ADDITIONAL_PROPERTY_FLAG,
  canExpand: canExpand,
  getSchemaType: getSchemaType,
  getWidget: getWidget,
  hasWidget: hasWidget,
  getDefaultFormState: getDefaultFormState,
  mergeDefaultsWithFormData: mergeDefaultsWithFormData,
  getUiOptions: getUiOptions,
  getSubmitButtonOptions: getSubmitButtonOptions,
  getDisplayLabel: getDisplayLabel,
  isObject: isObject,
  mergeObjects: mergeObjects,
  asNumber: asNumber,
  orderProperties: orderProperties,
  isConstant: isConstant,
  toConstant: toConstant,
  isSelect: isSelect,
  isMultiSelect: isMultiSelect,
  isFilesArray: isFilesArray,
  isFixedItems: isFixedItems,
  isCustomWidget: isCustomWidget,
  allowAdditionalItems: allowAdditionalItems,
  optionsList: optionsList,
  findSchemaDefinition: findSchemaDefinition,
  guessType: guessType,
  stubExistingAdditionalProperties: stubExistingAdditionalProperties,
  resolveSchema: resolveSchema,
  retrieveSchema: retrieveSchema,
  mergeSchemas: mergeSchemas,
  deepEquals: deepEquals,
  shouldRender: shouldRender,
  toIdSchema: toIdSchema,
  toPathSchema: toPathSchema,
  parseDateString: parseDateString,
  toDateString: toDateString,
  utcToLocal: utcToLocal,
  localToUTC: localToUTC,
  pad: pad,
  dataURItoBlob: dataURItoBlob,
  rangeSpec: rangeSpec,
  getMatchingOption: getMatchingOption,
  schemaRequiresTrueValue: schemaRequiresTrueValue
};

function ArrayFieldTitle(_ref) {
  var TitleField = _ref.TitleField,
      idSchema = _ref.idSchema,
      title = _ref.title,
      required = _ref.required;

  if (!title) {
    return null;
  }

  var id = idSchema.$id + "__title";
  return /*#__PURE__*/React.createElement(TitleField, {
    id: id,
    title: title,
    required: required
  });
}

function ArrayFieldDescription(_ref2) {
  var DescriptionField = _ref2.DescriptionField,
      idSchema = _ref2.idSchema,
      description = _ref2.description;

  if (!description) {
    return null;
  }

  var id = idSchema.$id + "__description";
  return /*#__PURE__*/React.createElement(DescriptionField, {
    id: id,
    description: description
  });
} // Used in the two templates


function DefaultArrayItem(props) {
  var btnStyle = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  return /*#__PURE__*/React.createElement("div", {
    key: props.key,
    className: props.className
  }, /*#__PURE__*/React.createElement("div", {
    className: props.hasToolbar ? "col-xs-9" : "col-xs-12"
  }, props.children), props.hasToolbar && /*#__PURE__*/React.createElement("div", {
    className: "col-xs-3 array-item-toolbox"
  }, /*#__PURE__*/React.createElement("div", {
    className: "btn-group",
    style: {
      display: "flex",
      justifyContent: "space-around"
    }
  }, (props.hasMoveUp || props.hasMoveDown) && /*#__PURE__*/React.createElement(IconButton, {
    icon: "arrow-up",
    "aria-label": "Move up",
    className: "array-item-move-up",
    tabIndex: "-1",
    style: btnStyle,
    disabled: props.disabled || props.readonly || !props.hasMoveUp,
    onClick: props.onReorderClick(props.index, props.index - 1)
  }), (props.hasMoveUp || props.hasMoveDown) && /*#__PURE__*/React.createElement(IconButton, {
    icon: "arrow-down",
    className: "array-item-move-down",
    "aria-label": "Move down",
    tabIndex: "-1",
    style: btnStyle,
    disabled: props.disabled || props.readonly || !props.hasMoveDown,
    onClick: props.onReorderClick(props.index, props.index + 1)
  }), props.hasRemove && /*#__PURE__*/React.createElement(IconButton, {
    type: "danger",
    icon: "remove",
    "aria-label": "Remove",
    className: "array-item-remove",
    tabIndex: "-1",
    style: btnStyle,
    disabled: props.disabled || props.readonly,
    onClick: props.onDropIndexClick(props.index)
  }))));
}

function DefaultFixedArrayFieldTemplate(props) {
  return /*#__PURE__*/React.createElement("fieldset", {
    className: props.className,
    id: props.idSchema.$id
  }, /*#__PURE__*/React.createElement(ArrayFieldTitle, {
    key: "array-field-title-" + props.idSchema.$id,
    TitleField: props.TitleField,
    idSchema: props.idSchema,
    title: props.uiSchema["ui:title"] || props.title,
    required: props.required
  }), (props.uiSchema["ui:description"] || props.schema.description) && /*#__PURE__*/React.createElement("div", {
    className: "field-description",
    key: "field-description-" + props.idSchema.$id
  }, props.uiSchema["ui:description"] || props.schema.description), /*#__PURE__*/React.createElement("div", {
    className: "row array-item-list",
    key: "array-item-list-" + props.idSchema.$id
  }, props.items && props.items.map(DefaultArrayItem)), props.canAdd && /*#__PURE__*/React.createElement(AddButton, {
    className: "array-item-add",
    onClick: props.onAddClick,
    disabled: props.disabled || props.readonly
  }));
}

function DefaultNormalArrayFieldTemplate(props) {
  return /*#__PURE__*/React.createElement("fieldset", {
    className: props.className,
    id: props.idSchema.$id
  }, /*#__PURE__*/React.createElement(ArrayFieldTitle, {
    key: "array-field-title-" + props.idSchema.$id,
    TitleField: props.TitleField,
    idSchema: props.idSchema,
    title: props.uiSchema["ui:title"] || props.title,
    required: props.required
  }), (props.uiSchema["ui:description"] || props.schema.description) && /*#__PURE__*/React.createElement(ArrayFieldDescription, {
    key: "array-field-description-" + props.idSchema.$id,
    DescriptionField: props.DescriptionField,
    idSchema: props.idSchema,
    description: props.uiSchema["ui:description"] || props.schema.description
  }), /*#__PURE__*/React.createElement("div", {
    className: "row array-item-list",
    key: "array-item-list-" + props.idSchema.$id
  }, props.items && props.items.map(function (p) {
    return DefaultArrayItem(p);
  })), props.canAdd && /*#__PURE__*/React.createElement(AddButton, {
    className: "array-item-add",
    onClick: props.onAddClick,
    disabled: props.disabled || props.readonly
  }));
}

function generateRowId() {
  return nanoid();
}

function generateKeyedFormData(formData) {
  return !Array.isArray(formData) ? [] : formData.map(function (item) {
    return {
      key: generateRowId(),
      item: item
    };
  });
}

function keyedToPlainFormData(keyedFormData) {
  return keyedFormData.map(function (keyedItem) {
    return keyedItem.item;
  });
}

var ArrayField = /*#__PURE__*/function (_Component) {
  _inheritsLoose(ArrayField, _Component);

  function ArrayField(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this._getNewFormDataRow = function () {
      var _this$props = _this.props,
          schema = _this$props.schema,
          registry = _this$props.registry;
      var rootSchema = registry.rootSchema;
      var itemSchema = schema.items;

      if (isFixedItems(schema) && allowAdditionalItems(schema)) {
        itemSchema = schema.additionalItems;
      }

      return getDefaultFormState(itemSchema, undefined, rootSchema);
    };

    _this.onAddClick = function (event) {
      if (event) {
        event.preventDefault();
      }

      var onChange = _this.props.onChange;
      var newKeyedFormDataRow = {
        key: generateRowId(),
        item: _this._getNewFormDataRow()
      };
      var newKeyedFormData = [].concat(_this.state.keyedFormData, [newKeyedFormDataRow]);

      _this.setState({
        keyedFormData: newKeyedFormData,
        updatedKeyedFormData: true
      }, function () {
        return onChange(keyedToPlainFormData(newKeyedFormData));
      });
    };

    _this.onAddIndexClick = function (index) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        var onChange = _this.props.onChange;
        var newKeyedFormDataRow = {
          key: generateRowId(),
          item: _this._getNewFormDataRow()
        };
        var newKeyedFormData = [].concat(_this.state.keyedFormData);
        newKeyedFormData.splice(index, 0, newKeyedFormDataRow);

        _this.setState({
          keyedFormData: newKeyedFormData,
          updatedKeyedFormData: true
        }, function () {
          return onChange(keyedToPlainFormData(newKeyedFormData));
        });
      };
    };

    _this.onDropIndexClick = function (index) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        var onChange = _this.props.onChange;
        var keyedFormData = _this.state.keyedFormData; // refs #195: revalidate to ensure properly reindexing errors

        var newErrorSchema;

        if (_this.props.errorSchema) {
          newErrorSchema = {};
          var errorSchema = _this.props.errorSchema;

          for (var i in errorSchema) {
            i = parseInt(i);

            if (i < index) {
              newErrorSchema[i] = errorSchema[i];
            } else if (i > index) {
              newErrorSchema[i - 1] = errorSchema[i];
            }
          }
        }

        var newKeyedFormData = keyedFormData.filter(function (_, i) {
          return i !== index;
        });

        _this.setState({
          keyedFormData: newKeyedFormData,
          updatedKeyedFormData: true
        }, function () {
          return onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema);
        });
      };
    };

    _this.onReorderClick = function (index, newIndex) {
      return function (event) {
        if (event) {
          event.preventDefault();
          event.target.blur();
        }

        var onChange = _this.props.onChange;
        var newErrorSchema;

        if (_this.props.errorSchema) {
          newErrorSchema = {};
          var errorSchema = _this.props.errorSchema;

          for (var i in errorSchema) {
            if (i == index) {
              newErrorSchema[newIndex] = errorSchema[index];
            } else if (i == newIndex) {
              newErrorSchema[index] = errorSchema[newIndex];
            } else {
              newErrorSchema[i] = errorSchema[i];
            }
          }
        }

        var keyedFormData = _this.state.keyedFormData;

        function reOrderArray() {
          // Copy item
          var _newKeyedFormData = keyedFormData.slice(); // Moves item from index to newIndex


          _newKeyedFormData.splice(index, 1);

          _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);

          return _newKeyedFormData;
        }

        var newKeyedFormData = reOrderArray();

        _this.setState({
          keyedFormData: newKeyedFormData
        }, function () {
          return onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema);
        });
      };
    };

    _this.onChangeForIndex = function (index) {
      return function (value, errorSchema) {
        var _extends2;

        var _this$props2 = _this.props,
            formData = _this$props2.formData,
            onChange = _this$props2.onChange;
        var newFormData = formData.map(function (item, i) {
          // We need to treat undefined items as nulls to have validation.
          // See https://github.com/tdegrunt/jsonschema/issues/206
          var jsonValue = typeof value === "undefined" ? null : value;
          return index === i ? jsonValue : item;
        });
        onChange(newFormData, errorSchema && _this.props.errorSchema && _extends({}, _this.props.errorSchema, (_extends2 = {}, _extends2[index] = errorSchema, _extends2)));
      };
    };

    _this.onSelectChange = function (value) {
      _this.props.onChange(value);
    };

    var _formData = props.formData;

    var _keyedFormData = generateKeyedFormData(_formData);

    _this.state = {
      keyedFormData: _keyedFormData,
      updatedKeyedFormData: false
    };
    return _this;
  }

  ArrayField.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    // Don't call getDerivedStateFromProps if keyed formdata was just updated.
    if (prevState.updatedKeyedFormData) {
      return {
        updatedKeyedFormData: false
      };
    }

    var nextFormData = nextProps.formData || [];
    var previousKeyedFormData = prevState.keyedFormData || [];
    var newKeyedFormData = nextFormData.length === previousKeyedFormData.length ? previousKeyedFormData.map(function (previousKeyedFormDatum, index) {
      return {
        key: previousKeyedFormDatum.key,
        item: nextFormData[index]
      };
    }) : generateKeyedFormData(nextFormData);
    return {
      keyedFormData: newKeyedFormData
    };
  };

  var _proto = ArrayField.prototype;

  _proto.isItemRequired = function isItemRequired(itemSchema) {
    if (Array.isArray(itemSchema.type)) {
      // While we don't yet support composite/nullable jsonschema types, it's
      // future-proof to check for requirement against these.
      return !includes(itemSchema.type, "null");
    } // All non-null array item types are inherently required by design


    return itemSchema.type !== "null";
  };

  _proto.canAddItem = function canAddItem(formItems) {
    var _this$props3 = this.props,
        schema = _this$props3.schema,
        uiSchema = _this$props3.uiSchema;

    var _getUiOptions = getUiOptions(uiSchema),
        addable = _getUiOptions.addable;

    if (addable !== false) {
      // if ui:options.addable was not explicitly set to false, we can add
      // another item if we have not exceeded maxItems yet
      if (schema.maxItems !== undefined) {
        addable = formItems.length < schema.maxItems;
      } else {
        addable = true;
      }
    }

    return addable;
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        schema = _this$props4.schema,
        uiSchema = _this$props4.uiSchema,
        idSchema = _this$props4.idSchema,
        registry = _this$props4.registry;
    var rootSchema = registry.rootSchema;

    if (!schema.hasOwnProperty("items")) {
      var fields = registry.fields;
      var UnsupportedField = fields.UnsupportedField;
      return /*#__PURE__*/React.createElement(UnsupportedField, {
        schema: schema,
        idSchema: idSchema,
        reason: "Missing items definition"
      });
    }

    if (isMultiSelect(schema, rootSchema)) {
      // If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.
      return this.renderMultiSelect();
    }

    if (isCustomWidget(uiSchema)) {
      return this.renderCustomWidget();
    }

    if (isFixedItems(schema)) {
      return this.renderFixedArray();
    }

    if (isFilesArray(schema, uiSchema, rootSchema)) {
      return this.renderFiles();
    }

    return this.renderNormalArray();
  };

  _proto.renderNormalArray = function renderNormalArray() {
    var _this2 = this;

    var _this$props5 = this.props,
        schema = _this$props5.schema,
        uiSchema = _this$props5.uiSchema,
        errorSchema = _this$props5.errorSchema,
        idSchema = _this$props5.idSchema,
        name = _this$props5.name,
        required = _this$props5.required,
        disabled = _this$props5.disabled,
        readonly = _this$props5.readonly,
        hideError = _this$props5.hideError,
        autofocus = _this$props5.autofocus,
        registry = _this$props5.registry,
        onBlur = _this$props5.onBlur,
        onFocus = _this$props5.onFocus,
        idPrefix = _this$props5.idPrefix,
        _this$props5$idSepara = _this$props5.idSeparator,
        idSeparator = _this$props5$idSepara === void 0 ? "_" : _this$props5$idSepara,
        rawErrors = _this$props5.rawErrors;
    var title = schema.title === undefined ? name : schema.title;
    var ArrayFieldTemplate = registry.ArrayFieldTemplate,
        rootSchema = registry.rootSchema,
        fields = registry.fields,
        formContext = registry.formContext;
    var TitleField = fields.TitleField,
        DescriptionField = fields.DescriptionField;
    var itemsSchema = retrieveSchema(schema.items, rootSchema);
    var formData = keyedToPlainFormData(this.state.keyedFormData);
    var arrayProps = {
      canAdd: this.canAddItem(formData),
      items: this.state.keyedFormData.map(function (keyedItem, index) {
        var key = keyedItem.key,
            item = keyedItem.item;
        var itemSchema = retrieveSchema(schema.items, rootSchema, item);
        var itemErrorSchema = errorSchema ? errorSchema[index] : undefined;
        var itemIdPrefix = idSchema.$id + idSeparator + index;
        var itemIdSchema = toIdSchema(itemSchema, itemIdPrefix, rootSchema, item, idPrefix, idSeparator);
        return _this2.renderArrayFieldItem({
          key: key,
          index: index,
          canMoveUp: index > 0,
          canMoveDown: index < formData.length - 1,
          itemSchema: itemSchema,
          itemIdSchema: itemIdSchema,
          itemErrorSchema: itemErrorSchema,
          itemData: item,
          itemUiSchema: uiSchema.items,
          autofocus: autofocus && index === 0,
          onBlur: onBlur,
          onFocus: onFocus
        });
      }),
      className: "field field-array field-array-of-" + itemsSchema.type,
      DescriptionField: DescriptionField,
      disabled: disabled,
      idSchema: idSchema,
      uiSchema: uiSchema,
      onAddClick: this.onAddClick,
      readonly: readonly,
      hideError: hideError,
      required: required,
      schema: schema,
      title: title,
      TitleField: TitleField,
      formContext: formContext,
      formData: formData,
      rawErrors: rawErrors,
      registry: registry
    }; // Check if a custom render function was passed in

    var Component = uiSchema["ui:ArrayFieldTemplate"] || ArrayFieldTemplate || DefaultNormalArrayFieldTemplate;
    return /*#__PURE__*/React.createElement(Component, arrayProps);
  };

  _proto.renderCustomWidget = function renderCustomWidget() {
    var _this$props6 = this.props,
        schema = _this$props6.schema,
        idSchema = _this$props6.idSchema,
        uiSchema = _this$props6.uiSchema,
        disabled = _this$props6.disabled,
        readonly = _this$props6.readonly,
        hideError = _this$props6.hideError,
        required = _this$props6.required,
        placeholder = _this$props6.placeholder,
        autofocus = _this$props6.autofocus,
        onBlur = _this$props6.onBlur,
        onFocus = _this$props6.onFocus,
        items = _this$props6.formData,
        registry = _this$props6.registry,
        rawErrors = _this$props6.rawErrors,
        name = _this$props6.name;
    var widgets = registry.widgets,
        formContext = registry.formContext;
    var title = schema.title || name;

    var _getUiOptions2 = _extends({}, getUiOptions(uiSchema)),
        widget = _getUiOptions2.widget,
        options = _objectWithoutPropertiesLoose(_getUiOptions2, ["widget"]);

    var Widget = getWidget(schema, widget, widgets);
    return /*#__PURE__*/React.createElement(Widget, {
      id: idSchema && idSchema.$id,
      multiple: true,
      onChange: this.onSelectChange,
      onBlur: onBlur,
      onFocus: onFocus,
      options: options,
      schema: schema,
      uiSchema: uiSchema,
      registry: registry,
      value: items,
      disabled: disabled,
      readonly: readonly,
      hideError: hideError,
      required: required,
      label: title,
      placeholder: placeholder,
      formContext: formContext,
      autofocus: autofocus,
      rawErrors: rawErrors
    });
  };

  _proto.renderMultiSelect = function renderMultiSelect() {
    var _this$props7 = this.props,
        schema = _this$props7.schema,
        idSchema = _this$props7.idSchema,
        uiSchema = _this$props7.uiSchema,
        formData = _this$props7.formData,
        disabled = _this$props7.disabled,
        readonly = _this$props7.readonly,
        required = _this$props7.required,
        placeholder = _this$props7.placeholder,
        autofocus = _this$props7.autofocus,
        onBlur = _this$props7.onBlur,
        onFocus = _this$props7.onFocus,
        registry = _this$props7.registry,
        rawErrors = _this$props7.rawErrors,
        name = _this$props7.name;
    var items = this.props.formData;
    var widgets = registry.widgets,
        rootSchema = registry.rootSchema,
        formContext = registry.formContext;
    var itemsSchema = retrieveSchema(schema.items, rootSchema, formData);
    var title = schema.title || name;
    var enumOptions = optionsList(itemsSchema);

    var _getUiOptions$enumOpt = _extends({}, getUiOptions(uiSchema), {
      enumOptions: enumOptions
    }),
        _getUiOptions$enumOpt2 = _getUiOptions$enumOpt.widget,
        widget = _getUiOptions$enumOpt2 === void 0 ? "select" : _getUiOptions$enumOpt2,
        options = _objectWithoutPropertiesLoose(_getUiOptions$enumOpt, ["widget"]);

    var Widget = getWidget(schema, widget, widgets);
    return /*#__PURE__*/React.createElement(Widget, {
      id: idSchema && idSchema.$id,
      multiple: true,
      onChange: this.onSelectChange,
      onBlur: onBlur,
      onFocus: onFocus,
      options: options,
      schema: schema,
      uiSchema: uiSchema,
      registry: registry,
      value: items,
      disabled: disabled,
      readonly: readonly,
      required: required,
      label: title,
      placeholder: placeholder,
      formContext: formContext,
      autofocus: autofocus,
      rawErrors: rawErrors
    });
  };

  _proto.renderFiles = function renderFiles() {
    var _this$props8 = this.props,
        schema = _this$props8.schema,
        uiSchema = _this$props8.uiSchema,
        idSchema = _this$props8.idSchema,
        name = _this$props8.name,
        disabled = _this$props8.disabled,
        readonly = _this$props8.readonly,
        autofocus = _this$props8.autofocus,
        onBlur = _this$props8.onBlur,
        onFocus = _this$props8.onFocus,
        registry = _this$props8.registry,
        rawErrors = _this$props8.rawErrors;
    var title = schema.title || name;
    var items = this.props.formData;
    var widgets = registry.widgets,
        formContext = registry.formContext;

    var _getUiOptions3 = getUiOptions(uiSchema),
        _getUiOptions3$widget = _getUiOptions3.widget,
        widget = _getUiOptions3$widget === void 0 ? "files" : _getUiOptions3$widget,
        options = _objectWithoutPropertiesLoose(_getUiOptions3, ["widget"]);

    var Widget = getWidget(schema, widget, widgets);
    return /*#__PURE__*/React.createElement(Widget, {
      options: options,
      id: idSchema && idSchema.$id,
      multiple: true,
      onChange: this.onSelectChange,
      onBlur: onBlur,
      onFocus: onFocus,
      schema: schema,
      uiSchema: uiSchema,
      title: title,
      value: items,
      disabled: disabled,
      readonly: readonly,
      registry: registry,
      formContext: formContext,
      autofocus: autofocus,
      rawErrors: rawErrors
    });
  };

  _proto.renderFixedArray = function renderFixedArray() {
    var _this3 = this;

    var _this$props9 = this.props,
        schema = _this$props9.schema,
        uiSchema = _this$props9.uiSchema,
        formData = _this$props9.formData,
        errorSchema = _this$props9.errorSchema,
        idPrefix = _this$props9.idPrefix,
        _this$props9$idSepara = _this$props9.idSeparator,
        idSeparator = _this$props9$idSepara === void 0 ? "_" : _this$props9$idSepara,
        idSchema = _this$props9.idSchema,
        name = _this$props9.name,
        required = _this$props9.required,
        disabled = _this$props9.disabled,
        readonly = _this$props9.readonly,
        autofocus = _this$props9.autofocus,
        registry = _this$props9.registry,
        onBlur = _this$props9.onBlur,
        onFocus = _this$props9.onFocus,
        rawErrors = _this$props9.rawErrors;
    var title = schema.title || name;
    var items = this.props.formData;
    var ArrayFieldTemplate = registry.ArrayFieldTemplate,
        rootSchema = registry.rootSchema,
        fields = registry.fields,
        formContext = registry.formContext;
    var TitleField = fields.TitleField;
    var itemSchemas = schema.items.map(function (item, index) {
      return retrieveSchema(item, rootSchema, formData[index]);
    });
    var additionalSchema = allowAdditionalItems(schema) ? retrieveSchema(schema.additionalItems, rootSchema, formData) : null;

    if (!items || items.length < itemSchemas.length) {
      // to make sure at least all fixed items are generated
      items = items || [];
      items = items.concat(new Array(itemSchemas.length - items.length));
    } // These are the props passed into the render function


    var arrayProps = {
      canAdd: this.canAddItem(items) && additionalSchema,
      className: "field field-array field-array-fixed-items",
      disabled: disabled,
      idSchema: idSchema,
      formData: formData,
      items: this.state.keyedFormData.map(function (keyedItem, index) {
        var key = keyedItem.key,
            item = keyedItem.item;
        var additional = index >= itemSchemas.length;
        var itemSchema = additional ? retrieveSchema(schema.additionalItems, rootSchema, item) : itemSchemas[index];
        var itemIdPrefix = idSchema.$id + idSeparator + index;
        var itemIdSchema = toIdSchema(itemSchema, itemIdPrefix, rootSchema, item, idPrefix, idSeparator);
        var itemUiSchema = additional ? uiSchema.additionalItems || {} : Array.isArray(uiSchema.items) ? uiSchema.items[index] : uiSchema.items || {};
        var itemErrorSchema = errorSchema ? errorSchema[index] : undefined;
        return _this3.renderArrayFieldItem({
          key: key,
          index: index,
          canRemove: additional,
          canMoveUp: index >= itemSchemas.length + 1,
          canMoveDown: additional && index < items.length - 1,
          itemSchema: itemSchema,
          itemData: item,
          itemUiSchema: itemUiSchema,
          itemIdSchema: itemIdSchema,
          itemErrorSchema: itemErrorSchema,
          autofocus: autofocus && index === 0,
          onBlur: onBlur,
          onFocus: onFocus
        });
      }),
      onAddClick: this.onAddClick,
      readonly: readonly,
      required: required,
      registry: registry,
      schema: schema,
      uiSchema: uiSchema,
      title: title,
      TitleField: TitleField,
      formContext: formContext,
      rawErrors: rawErrors
    }; // Check if a custom template template was passed in

    var Template = uiSchema["ui:ArrayFieldTemplate"] || ArrayFieldTemplate || DefaultFixedArrayFieldTemplate;
    return /*#__PURE__*/React.createElement(Template, arrayProps);
  };

  _proto.renderArrayFieldItem = function renderArrayFieldItem(props) {
    var key = props.key,
        index = props.index,
        _props$canRemove = props.canRemove,
        canRemove = _props$canRemove === void 0 ? true : _props$canRemove,
        _props$canMoveUp = props.canMoveUp,
        canMoveUp = _props$canMoveUp === void 0 ? true : _props$canMoveUp,
        _props$canMoveDown = props.canMoveDown,
        canMoveDown = _props$canMoveDown === void 0 ? true : _props$canMoveDown,
        itemSchema = props.itemSchema,
        itemData = props.itemData,
        itemUiSchema = props.itemUiSchema,
        itemIdSchema = props.itemIdSchema,
        itemErrorSchema = props.itemErrorSchema,
        autofocus = props.autofocus,
        onBlur = props.onBlur,
        onFocus = props.onFocus,
        rawErrors = props.rawErrors;
    var _this$props10 = this.props,
        disabled = _this$props10.disabled,
        readonly = _this$props10.readonly,
        uiSchema = _this$props10.uiSchema,
        registry = _this$props10.registry;
    var SchemaField = registry.fields.SchemaField;

    var _getUiOptions4 = getUiOptions(uiSchema),
        _getUiOptions4$ordera = _getUiOptions4.orderable,
        orderable = _getUiOptions4$ordera === void 0 ? true : _getUiOptions4$ordera,
        _getUiOptions4$remova = _getUiOptions4.removable,
        removable = _getUiOptions4$remova === void 0 ? true : _getUiOptions4$remova;

    var has = {
      moveUp: orderable && canMoveUp,
      moveDown: orderable && canMoveDown,
      remove: removable && canRemove
    };
    has.toolbar = Object.keys(has).some(function (key) {
      return has[key];
    });
    return {
      children: /*#__PURE__*/React.createElement(SchemaField, {
        index: index,
        schema: itemSchema,
        uiSchema: itemUiSchema,
        formData: itemData,
        errorSchema: itemErrorSchema,
        idPrefix: this.props.idPrefix,
        idSeparator: this.props.idSeparator,
        idSchema: itemIdSchema,
        required: this.isItemRequired(itemSchema),
        onChange: this.onChangeForIndex(index),
        onBlur: onBlur,
        onFocus: onFocus,
        registry: this.props.registry,
        disabled: this.props.disabled,
        readonly: this.props.readonly,
        hideError: this.props.hideError,
        autofocus: autofocus,
        rawErrors: rawErrors
      }),
      className: "array-item",
      disabled: disabled,
      hasToolbar: has.toolbar,
      hasMoveUp: has.moveUp,
      hasMoveDown: has.moveDown,
      hasRemove: has.remove,
      index: index,
      key: key,
      onAddIndexClick: this.onAddIndexClick,
      onDropIndexClick: this.onDropIndexClick,
      onReorderClick: this.onReorderClick,
      readonly: readonly
    };
  };

  _createClass(ArrayField, [{
    key: "itemTitle",
    get: function get() {
      var schema = this.props.schema;
      return schema.items.title || schema.items.description || "Item";
    }
  }]);

  return ArrayField;
}(Component);

ArrayField.defaultProps = {
  uiSchema: {},
  formData: [],
  idSchema: {},
  required: false,
  disabled: false,
  readonly: false,
  autofocus: false
};

if (process.env.NODE_ENV !== "production") {
  ArrayField.propTypes = fieldProps;
}

function BooleanField(props) {
  var schema = props.schema,
      name = props.name,
      uiSchema = props.uiSchema,
      idSchema = props.idSchema,
      formData = props.formData,
      registry = props.registry,
      required = props.required,
      disabled = props.disabled,
      readonly = props.readonly,
      autofocus = props.autofocus,
      onChange = props.onChange,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      rawErrors = props.rawErrors;
  var title = schema.title;
  var widgets = registry.widgets,
      formContext = registry.formContext,
      fields = registry.fields;

  var _getUiOptions = getUiOptions(uiSchema),
      _getUiOptions$widget = _getUiOptions.widget,
      widget = _getUiOptions$widget === void 0 ? "checkbox" : _getUiOptions$widget,
      options = _objectWithoutPropertiesLoose(_getUiOptions, ["widget"]);

  var Widget = getWidget(schema, widget, widgets);
  var enumOptions;

  if (Array.isArray(schema.oneOf)) {
    enumOptions = optionsList({
      oneOf: schema.oneOf.map(function (option) {
        return _extends({}, option, {
          title: option.title || (option["const"] === true ? "Yes" : "No")
        });
      })
    });
  } else {
    enumOptions = optionsList({
      "enum": schema["enum"] || [true, false],
      enumNames: schema.enumNames || (schema["enum"] && schema["enum"][0] === false ? ["No", "Yes"] : ["Yes", "No"])
    });
  }

  return /*#__PURE__*/React.createElement(Widget, {
    options: _extends({}, options, {
      enumOptions: enumOptions
    }),
    schema: schema,
    uiSchema: uiSchema,
    id: idSchema && idSchema.$id,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur,
    label: title === undefined ? name : title,
    value: formData,
    required: required,
    disabled: disabled,
    readonly: readonly,
    registry: registry,
    formContext: formContext,
    autofocus: autofocus,
    rawErrors: rawErrors,
    DescriptionField: fields.DescriptionField
  });
}

if (process.env.NODE_ENV !== "production") {
  BooleanField.propTypes = fieldProps;
}

BooleanField.defaultProps = {
  uiSchema: {},
  disabled: false,
  readonly: false,
  autofocus: false
};

function DescriptionField(props) {
  var id = props.id,
      description = props.description;

  if (!description) {
    return null;
  }

  if (typeof description === "string") {
    return /*#__PURE__*/React.createElement("p", {
      id: id,
      className: "field-description"
    }, description);
  } else {
    return /*#__PURE__*/React.createElement("div", {
      id: id,
      className: "field-description"
    }, description);
  }
}

if (process.env.NODE_ENV !== "production") {
  DescriptionField.propTypes = {
    id: PropTypes.string,
    description: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.element])
  };
}

var AnyOfField = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AnyOfField, _Component);

  function AnyOfField(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.onOptionChange = function (option) {
      var selectedOption = parseInt(option, 10);
      var _this$props = _this.props,
          formData = _this$props.formData,
          onChange = _this$props.onChange,
          options = _this$props.options,
          registry = _this$props.registry;
      var rootSchema = registry.rootSchema;
      var newOption = retrieveSchema(options[selectedOption], rootSchema, formData); // If the new option is of type object and the current data is an object,
      // discard properties added using the old option.

      var newFormData = undefined;

      if (guessType(formData) === "object" && (newOption.type === "object" || newOption.properties)) {
        newFormData = Object.assign({}, formData);
        var optionsToDiscard = options.slice();
        optionsToDiscard.splice(selectedOption, 1); // Discard any data added using other options

        for (var _iterator = optionsToDiscard, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var _option = _ref;

          if (_option.properties) {
            for (var key in _option.properties) {
              if (newFormData.hasOwnProperty(key)) {
                delete newFormData[key];
              }
            }
          }
        }
      } // Call getDefaultFormState to make sure defaults are populated on change.


      onChange(getDefaultFormState(options[selectedOption], newFormData, rootSchema));

      _this.setState({
        selectedOption: parseInt(option, 10)
      });
    };

    var _this$props2 = _this.props,
        _formData = _this$props2.formData,
        _options = _this$props2.options;
    _this.state = {
      selectedOption: _this.getMatchingOption(_formData, _options)
    };
    return _this;
  }

  var _proto = AnyOfField.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (!deepEquals(this.props.formData, prevProps.formData) && this.props.idSchema.$id === prevProps.idSchema.$id) {
      var matchingOption = this.getMatchingOption(this.props.formData, this.props.options);

      if (!prevState || matchingOption === this.state.selectedOption) {
        return;
      }

      this.setState({
        selectedOption: matchingOption
      });
    }
  };

  _proto.getMatchingOption = function getMatchingOption$1(formData, options) {
    var rootSchema = this.props.registry.rootSchema;

    var option = getMatchingOption(formData, options, rootSchema);

    if (option !== 0) {
      return option;
    } // If the form data matches none of the options, use the currently selected
    // option, assuming it's available; otherwise use the first option


    return this && this.state ? this.state.selectedOption : 0;
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        baseType = _this$props3.baseType,
        disabled = _this$props3.disabled,
        readonly = _this$props3.readonly,
        hideError = _this$props3.hideError,
        errorSchema = _this$props3.errorSchema,
        formData = _this$props3.formData,
        idPrefix = _this$props3.idPrefix,
        idSeparator = _this$props3.idSeparator,
        idSchema = _this$props3.idSchema,
        onBlur = _this$props3.onBlur,
        onChange = _this$props3.onChange,
        onFocus = _this$props3.onFocus,
        options = _this$props3.options,
        registry = _this$props3.registry,
        uiSchema = _this$props3.uiSchema,
        schema = _this$props3.schema;
    var _SchemaField = registry.fields.SchemaField;
    var widgets = registry.widgets;
    var selectedOption = this.state.selectedOption;

    var _getUiOptions = getUiOptions(uiSchema),
        _getUiOptions$widget = _getUiOptions.widget,
        widget = _getUiOptions$widget === void 0 ? "select" : _getUiOptions$widget,
        uiOptions = _objectWithoutPropertiesLoose(_getUiOptions, ["widget"]);

    var Widget = getWidget({
      type: "number"
    }, widget, widgets);
    var option = options[selectedOption] || null;
    var optionSchema;

    if (option) {
      // If the subschema doesn't declare a type, infer the type from the
      // parent schema
      optionSchema = option.type ? option : Object.assign({}, option, {
        type: baseType
      });
    }

    var enumOptions = options.map(function (option, index) {
      return {
        label: option.title || "Option " + (index + 1),
        value: index
      };
    });
    return /*#__PURE__*/React.createElement("div", {
      className: "panel panel-default panel-body"
    }, /*#__PURE__*/React.createElement("div", {
      className: "form-group"
    }, /*#__PURE__*/React.createElement(Widget, _extends({
      id: "" + idSchema.$id + (schema.oneOf ? "__oneof_select" : "__anyof_select"),
      schema: {
        type: "number",
        "default": 0
      },
      onChange: this.onOptionChange,
      onBlur: onBlur,
      onFocus: onFocus,
      value: selectedOption,
      options: {
        enumOptions: enumOptions
      },
      registry: registry
    }, uiOptions))), option !== null && /*#__PURE__*/React.createElement(_SchemaField, {
      schema: optionSchema,
      uiSchema: uiSchema,
      errorSchema: errorSchema,
      idSchema: idSchema,
      idPrefix: idPrefix,
      idSeparator: idSeparator,
      formData: formData,
      onChange: onChange,
      onBlur: onBlur,
      onFocus: onFocus,
      registry: registry,
      disabled: disabled,
      readonly: readonly,
      hideError: hideError
    }));
  };

  return AnyOfField;
}(Component);

AnyOfField.defaultProps = {
  disabled: false,
  readonly: false,
  hideError: false,
  errorSchema: {},
  idSchema: {},
  uiSchema: {}
};

if (process.env.NODE_ENV !== "production") {
  AnyOfField.propTypes = {
    options: /*#__PURE__*/PropTypes.arrayOf(PropTypes.object).isRequired,
    baseType: PropTypes.string,
    uiSchema: PropTypes.object,
    idSchema: PropTypes.object,
    formData: PropTypes.any,
    errorSchema: PropTypes.object,
    registry: registry.isRequired
  };
}

// digits followed by any number of 0 characters up until the end of the line.
// Ensuring that there is at least one prefixed character is important so that
// you don't incorrectly match against "0".

var trailingCharMatcherWithPrefix = /\.([0-9]*0)*$/; // This is used for trimming the trailing 0 and . characters without affecting
// the rest of the string. Its possible to use one RegEx with groups for this
// functionality, but it is fairly complex compared to simply defining two
// different matchers.

var trailingCharMatcher = /[0.]0*$/;
/**
 * The NumberField class has some special handling for dealing with trailing
 * decimal points and/or zeroes. This logic is designed to allow trailing values
 * to be visible in the input element, but not be represented in the
 * corresponding form data.
 *
 * The algorithm is as follows:
 *
 * 1. When the input value changes the value is cached in the component state
 *
 * 2. The value is then normalized, removing trailing decimal points and zeros,
 *    then passed to the "onChange" callback
 *
 * 3. When the component is rendered, the formData value is checked against the
 *    value cached in the state. If it matches the cached value, the cached
 *    value is passed to the input instead of the formData value
 */

var NumberField = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(NumberField, _React$Component);

  function NumberField(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.handleChange = function (value) {
      // Cache the original value in component state
      _this.setState({
        lastValue: value
      }); // Normalize decimals that don't start with a zero character in advance so
      // that the rest of the normalization logic is simpler


      if (("" + value).charAt(0) === ".") {
        value = "0" + value;
      } // Check that the value is a string (this can happen if the widget used is a
      // <select>, due to an enum declaration etc) then, if the value ends in a
      // trailing decimal point or multiple zeroes, strip the trailing values


      var processed = typeof value === "string" && value.match(trailingCharMatcherWithPrefix) ? asNumber(value.replace(trailingCharMatcher, "")) : asNumber(value);

      _this.props.onChange(processed);
    };

    _this.state = {
      lastValue: props.value
    };
    return _this;
  }

  var _proto = NumberField.prototype;

  _proto.render = function render() {
    var StringField = this.props.registry.fields.StringField;

    var _this$props = this.props,
        formData = _this$props.formData,
        props = _objectWithoutPropertiesLoose(_this$props, ["formData"]);

    var lastValue = this.state.lastValue;
    var value = formData;

    if (typeof lastValue === "string" && typeof value === "number") {
      // Construct a regular expression that checks for a string that consists
      // of the formData value suffixed with zero or one '.' characters and zero
      // or more '0' characters
      var re = new RegExp(("" + value).replace(".", "\\.") + "\\.?0*$"); // If the cached "lastValue" is a match, use that instead of the formData
      // value to prevent the input value from changing in the UI

      if (lastValue.match(re)) {
        value = lastValue;
      }
    }

    return /*#__PURE__*/React.createElement(StringField, _extends({}, props, {
      formData: value,
      onChange: this.handleChange
    }));
  };

  return NumberField;
}(React.Component);

if (process.env.NODE_ENV !== "production") {
  NumberField.propTypes = fieldProps;
}

NumberField.defaultProps = {
  uiSchema: {}
};

function DefaultObjectFieldTemplate(props) {
  var TitleField = props.TitleField,
      DescriptionField = props.DescriptionField;
  return /*#__PURE__*/React.createElement("fieldset", {
    id: props.idSchema.$id
  }, (props.uiSchema["ui:title"] || props.title) && /*#__PURE__*/React.createElement(TitleField, {
    id: props.idSchema.$id + "__title",
    title: props.title || props.uiSchema["ui:title"],
    required: props.required,
    formContext: props.formContext
  }), props.description && /*#__PURE__*/React.createElement(DescriptionField, {
    id: props.idSchema.$id + "__description",
    description: props.description,
    formContext: props.formContext
  }), props.properties.map(function (prop) {
    return prop.content;
  }), canExpand(props.schema, props.uiSchema, props.formData) && /*#__PURE__*/React.createElement(AddButton, {
    className: "object-property-expand",
    onClick: props.onAddClick(props.schema),
    disabled: props.disabled || props.readonly
  }));
}

var ObjectField = /*#__PURE__*/function (_Component) {
  _inheritsLoose(ObjectField, _Component);

  function ObjectField() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      wasPropertyKeyModified: false,
      additionalProperties: {}
    };

    _this.onPropertyChange = function (name, addedByAdditionalProperties) {
      if (addedByAdditionalProperties === void 0) {
        addedByAdditionalProperties = false;
      }

      return function (value, errorSchema) {
        var _extends2, _extends3;

        if (value === undefined && addedByAdditionalProperties) {
          // Don't set value = undefined for fields added by
          // additionalProperties. Doing so removes them from the
          // formData, which causes them to completely disappear
          // (including the input field for the property name). Unlike
          // fields which are "mandated" by the schema, these fields can
          // be set to undefined by clicking a "delete field" button, so
          // set empty values to the empty string.
          value = "";
        }

        var newFormData = _extends({}, _this.props.formData, (_extends2 = {}, _extends2[name] = value, _extends2));

        _this.props.onChange(newFormData, errorSchema && _this.props.errorSchema && _extends({}, _this.props.errorSchema, (_extends3 = {}, _extends3[name] = errorSchema, _extends3)));
      };
    };

    _this.onDropPropertyClick = function (key) {
      return function (event) {
        event.preventDefault();
        var _this$props = _this.props,
            onChange = _this$props.onChange,
            formData = _this$props.formData;

        var copiedFormData = _extends({}, formData);

        delete copiedFormData[key];
        onChange(copiedFormData);
      };
    };

    _this.getAvailableKey = function (preferredKey, formData) {
      var index = 0;
      var newKey = preferredKey;

      while (formData.hasOwnProperty(newKey)) {
        newKey = preferredKey + "-" + ++index;
      }

      return newKey;
    };

    _this.onKeyChange = function (oldValue) {
      return function (value, errorSchema) {
        var _newKeys, _extends4;

        if (oldValue === value) {
          return;
        }

        value = _this.getAvailableKey(value, _this.props.formData);

        var newFormData = _extends({}, _this.props.formData);

        var newKeys = (_newKeys = {}, _newKeys[oldValue] = value, _newKeys);
        var keyValues = Object.keys(newFormData).map(function (key) {
          var _ref;

          var newKey = newKeys[key] || key;
          return _ref = {}, _ref[newKey] = newFormData[key], _ref;
        });
        var renamedObj = Object.assign.apply(Object, [{}].concat(keyValues));

        _this.setState({
          wasPropertyKeyModified: true
        });

        _this.props.onChange(renamedObj, errorSchema && _this.props.errorSchema && _extends({}, _this.props.errorSchema, (_extends4 = {}, _extends4[value] = errorSchema, _extends4)));
      };
    };

    _this.handleAddClick = function (schema) {
      return function () {
        var type = schema.additionalProperties.type;

        var newFormData = _extends({}, _this.props.formData);

        if (schema.additionalProperties.hasOwnProperty("$ref")) {
          var registry = _this.props.registry;
          var refSchema = retrieveSchema({
            $ref: schema.additionalProperties["$ref"]
          }, registry.rootSchema, _this.props.formData);
          type = refSchema.type;
        }

        newFormData[_this.getAvailableKey("newKey", newFormData)] = _this.getDefaultValue(type);

        _this.props.onChange(newFormData);
      };
    };

    return _this;
  }

  var _proto = ObjectField.prototype;

  _proto.isRequired = function isRequired(name) {
    var schema = this.props.schema;
    return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;
  };

  _proto.getDefaultValue = function getDefaultValue(type) {
    switch (type) {
      case "string":
        return "New Value";

      case "array":
        return [];

      case "boolean":
        return false;

      case "null":
        return null;

      case "number":
        return 0;

      case "object":
        return {};

      default:
        // We don't have a datatype for some reason (perhaps additionalProperties was true)
        return "New Value";
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        uiSchema = _this$props2.uiSchema,
        formData = _this$props2.formData,
        errorSchema = _this$props2.errorSchema,
        idSchema = _this$props2.idSchema,
        name = _this$props2.name,
        required = _this$props2.required,
        disabled = _this$props2.disabled,
        readonly = _this$props2.readonly,
        hideError = _this$props2.hideError,
        idPrefix = _this$props2.idPrefix,
        idSeparator = _this$props2.idSeparator,
        onBlur = _this$props2.onBlur,
        onFocus = _this$props2.onFocus,
        registry = _this$props2.registry;
    var rootSchema = registry.rootSchema,
        fields = registry.fields,
        formContext = registry.formContext;
    var SchemaField = fields.SchemaField,
        TitleField = fields.TitleField,
        DescriptionField = fields.DescriptionField;
    var schema = retrieveSchema(this.props.schema, rootSchema, formData);
    var title = schema.title === undefined ? name : schema.title;
    var description = uiSchema["ui:description"] || schema.description;
    var orderedProperties;

    try {
      var properties = Object.keys(schema.properties || {});
      orderedProperties = orderProperties(properties, uiSchema["ui:order"]);
    } catch (err) {
      return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("p", {
        className: "config-error",
        style: {
          color: "red"
        }
      }, "Invalid ", name || "root", " object field configuration:", /*#__PURE__*/React.createElement("em", null, err.message), "."), /*#__PURE__*/React.createElement("pre", null, JSON.stringify(schema)));
    }

    var Template = uiSchema["ui:ObjectFieldTemplate"] || registry.ObjectFieldTemplate || DefaultObjectFieldTemplate;
    var templateProps = {
      title: uiSchema["ui:title"] || title,
      description: description,
      TitleField: TitleField,
      DescriptionField: DescriptionField,
      properties: orderedProperties.map(function (name) {
        var addedByAdditionalProperties = schema.properties[name].hasOwnProperty(ADDITIONAL_PROPERTY_FLAG);
        var fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name];
        var hidden = fieldUiSchema && fieldUiSchema["ui:widget"] === "hidden";
        return {
          content: /*#__PURE__*/React.createElement(SchemaField, {
            key: name,
            name: name,
            required: _this2.isRequired(name),
            schema: schema.properties[name],
            uiSchema: fieldUiSchema,
            errorSchema: errorSchema[name],
            idSchema: idSchema[name],
            idPrefix: idPrefix,
            idSeparator: idSeparator,
            formData: (formData || {})[name],
            wasPropertyKeyModified: _this2.state.wasPropertyKeyModified,
            onKeyChange: _this2.onKeyChange(name),
            onChange: _this2.onPropertyChange(name, addedByAdditionalProperties),
            onBlur: onBlur,
            onFocus: onFocus,
            registry: registry,
            disabled: disabled,
            readonly: readonly,
            hideError: hideError,
            onDropPropertyClick: _this2.onDropPropertyClick
          }),
          name: name,
          readonly: readonly,
          disabled: disabled,
          required: required,
          hidden: hidden
        };
      }),
      readonly: readonly,
      disabled: disabled,
      required: required,
      idSchema: idSchema,
      uiSchema: uiSchema,
      schema: schema,
      formData: formData,
      formContext: formContext,
      registry: registry
    };
    return /*#__PURE__*/React.createElement(Template, _extends({}, templateProps, {
      onAddClick: this.handleAddClick
    }));
  };

  return ObjectField;
}(Component);

ObjectField.defaultProps = {
  uiSchema: {},
  formData: {},
  errorSchema: {},
  idSchema: {},
  required: false,
  disabled: false,
  readonly: false
};

if (process.env.NODE_ENV !== "production") {
  ObjectField.propTypes = fieldProps;
}

var REQUIRED_FIELD_SYMBOL = "*";
var COMPONENT_TYPES = {
  array: "ArrayField",
  "boolean": "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  "null": "NullField"
};

function getFieldComponent(schema, uiSchema, idSchema, fields) {
  var field = uiSchema["ui:field"];

  if (typeof field === "function") {
    return field;
  }

  if (typeof field === "string" && field in fields) {
    return fields[field];
  }

  var componentName = COMPONENT_TYPES[getSchemaType(schema)]; // If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't
  // render a field and let the MultiSchemaField component handle the form display

  if (!componentName && (schema.anyOf || schema.oneOf)) {
    return function () {
      return null;
    };
  }

  return componentName in fields ? fields[componentName] : function () {
    var UnsupportedField = fields.UnsupportedField;
    return /*#__PURE__*/React.createElement(UnsupportedField, {
      schema: schema,
      idSchema: idSchema,
      reason: "Unknown field type " + schema.type
    });
  };
}

function Label(props) {
  var label = props.label,
      required = props.required,
      id = props.id;

  if (!label) {
    return null;
  }

  return /*#__PURE__*/React.createElement("label", {
    className: "control-label",
    htmlFor: id
  }, label, required && /*#__PURE__*/React.createElement("span", {
    className: "required"
  }, REQUIRED_FIELD_SYMBOL));
}

function LabelInput(props) {
  var id = props.id,
      label = props.label,
      onChange = props.onChange;
  return /*#__PURE__*/React.createElement("input", {
    className: "form-control",
    type: "text",
    id: id,
    onBlur: function onBlur(event) {
      return onChange(event.target.value);
    },
    defaultValue: label
  });
}

function Help(props) {
  var id = props.id,
      help = props.help;

  if (!help) {
    return null;
  }

  if (typeof help === "string") {
    return /*#__PURE__*/React.createElement("p", {
      id: id,
      className: "help-block"
    }, help);
  }

  return /*#__PURE__*/React.createElement("div", {
    id: id,
    className: "help-block"
  }, help);
}

function ErrorList(props) {
  var _props$errors = props.errors,
      errors = _props$errors === void 0 ? [] : _props$errors;

  if (errors.length === 0) {
    return null;
  }

  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("ul", {
    className: "error-detail bs-callout bs-callout-info"
  }, errors.filter(function (elem) {
    return !!elem;
  }).map(function (error, index) {
    return /*#__PURE__*/React.createElement("li", {
      className: "text-danger",
      key: index
    }, error);
  })));
}

function DefaultTemplate(props) {
  var id = props.id,
      label = props.label,
      children = props.children,
      errors = props.errors,
      help = props.help,
      description = props.description,
      hidden = props.hidden,
      required = props.required,
      displayLabel = props.displayLabel;

  if (hidden) {
    return /*#__PURE__*/React.createElement("div", {
      className: "hidden"
    }, children);
  }

  return /*#__PURE__*/React.createElement(WrapIfAdditional, props, displayLabel && /*#__PURE__*/React.createElement(Label, {
    label: label,
    required: required,
    id: id
  }), displayLabel && description ? description : null, children, errors, help);
}

if (process.env.NODE_ENV !== "production") {
  DefaultTemplate.propTypes = {
    id: PropTypes.string,
    classNames: PropTypes.string,
    label: PropTypes.string,
    children: PropTypes.node.isRequired,
    errors: PropTypes.element,
    rawErrors: /*#__PURE__*/PropTypes.arrayOf(PropTypes.string),
    help: PropTypes.element,
    rawHelp: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
    description: PropTypes.element,
    rawDescription: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
    hidden: PropTypes.bool,
    required: PropTypes.bool,
    readonly: PropTypes.bool,
    displayLabel: PropTypes.bool,
    fields: PropTypes.object,
    formContext: PropTypes.object
  };
}

DefaultTemplate.defaultProps = {
  hidden: false,
  readonly: false,
  required: false,
  displayLabel: true
};

function WrapIfAdditional(props) {
  var id = props.id,
      classNames = props.classNames,
      disabled = props.disabled,
      label = props.label,
      onKeyChange = props.onKeyChange,
      onDropPropertyClick = props.onDropPropertyClick,
      readonly = props.readonly,
      required = props.required,
      schema = props.schema;
  var keyLabel = label + " Key"; // i18n ?

  var additional = schema.hasOwnProperty(ADDITIONAL_PROPERTY_FLAG);

  if (!additional) {
    return /*#__PURE__*/React.createElement("div", {
      className: classNames
    }, props.children);
  }

  return /*#__PURE__*/React.createElement("div", {
    className: classNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-xs-5 form-additional"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement(Label, {
    label: keyLabel,
    required: required,
    id: id + "-key"
  }), /*#__PURE__*/React.createElement(LabelInput, {
    label: label,
    required: required,
    id: id + "-key",
    onChange: onKeyChange
  }))), /*#__PURE__*/React.createElement("div", {
    className: "form-additional form-group col-xs-5"
  }, props.children), /*#__PURE__*/React.createElement("div", {
    className: "col-xs-2"
  }, /*#__PURE__*/React.createElement(IconButton, {
    type: "danger",
    icon: "remove",
    className: "array-item-remove btn-block",
    tabIndex: "-1",
    style: {
      border: "0"
    },
    disabled: disabled || readonly,
    onClick: onDropPropertyClick(label)
  }))));
}

function SchemaFieldRender(props) {
  var uiSchema = props.uiSchema,
      formData = props.formData,
      errorSchema = props.errorSchema,
      idPrefix = props.idPrefix,
      idSeparator = props.idSeparator,
      name = props.name,
      onChange = props.onChange,
      onKeyChange = props.onKeyChange,
      onDropPropertyClick = props.onDropPropertyClick,
      required = props.required,
      registry = props.registry,
      _props$wasPropertyKey = props.wasPropertyKeyModified,
      wasPropertyKeyModified = _props$wasPropertyKey === void 0 ? false : _props$wasPropertyKey;
  var rootSchema = registry.rootSchema,
      fields = registry.fields,
      formContext = registry.formContext;
  var FieldTemplate = uiSchema["ui:FieldTemplate"] || registry.FieldTemplate || DefaultTemplate;
  var idSchema = props.idSchema;
  var schema = retrieveSchema(props.schema, rootSchema, formData);
  idSchema = mergeObjects(toIdSchema(schema, null, rootSchema, formData, idPrefix, idSeparator), idSchema);
  var FieldComponent = getFieldComponent(schema, uiSchema, idSchema, fields);
  var DescriptionField = fields.DescriptionField;
  var disabled = Boolean(props.disabled || uiSchema["ui:disabled"]);
  var readonly = Boolean(props.readonly || uiSchema["ui:readonly"] || props.schema.readOnly || schema.readOnly);
  var uiSchemaHideError = uiSchema["ui:hideError"]; // Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children

  var hideError = uiSchemaHideError === undefined ? props.hideError : Boolean(uiSchemaHideError);
  var autofocus = Boolean(props.autofocus || uiSchema["ui:autofocus"]);

  if (Object.keys(schema).length === 0) {
    return null;
  }

  var displayLabel = getDisplayLabel(schema, uiSchema, rootSchema);

  var __errors = errorSchema.__errors,
      fieldErrorSchema = _objectWithoutPropertiesLoose(errorSchema, ["__errors"]); // See #439: uiSchema: Don't pass consumed class names to child components


  var field = /*#__PURE__*/React.createElement(FieldComponent, _extends({}, props, {
    idSchema: idSchema,
    schema: schema,
    uiSchema: _extends({}, uiSchema, {
      classNames: undefined
    }),
    disabled: disabled,
    readonly: readonly,
    hideError: hideError,
    autofocus: autofocus,
    errorSchema: fieldErrorSchema,
    formContext: formContext,
    rawErrors: __errors
  }));
  var id = idSchema.$id; // If this schema has a title defined, but the user has set a new key/label, retain their input.

  var label;

  if (wasPropertyKeyModified) {
    label = name;
  } else {
    label = uiSchema["ui:title"] || props.schema.title || schema.title || name;
  }

  var description = uiSchema["ui:description"] || props.schema.description || schema.description;
  var errors = __errors;
  var help = uiSchema["ui:help"];
  var hidden = uiSchema["ui:widget"] === "hidden";
  var classNames = ["form-group", "field", "field-" + schema.type];

  if (!hideError && errors && errors.length > 0) {
    classNames.push("field-error has-error has-danger");
  }

  classNames.push(uiSchema.classNames);
  classNames = classNames.join(" ").trim();
  var fieldProps = {
    description: /*#__PURE__*/React.createElement(DescriptionField, {
      id: id + "__description",
      description: description,
      formContext: formContext
    }),
    rawDescription: description,
    help: /*#__PURE__*/React.createElement(Help, {
      id: id + "__help",
      help: help
    }),
    rawHelp: typeof help === "string" ? help : undefined,
    errors: hideError ? undefined : /*#__PURE__*/React.createElement(ErrorList, {
      errors: errors
    }),
    rawErrors: hideError ? undefined : errors,
    id: id,
    label: label,
    hidden: hidden,
    onChange: onChange,
    onKeyChange: onKeyChange,
    onDropPropertyClick: onDropPropertyClick,
    required: required,
    disabled: disabled,
    readonly: readonly,
    hideError: hideError,
    displayLabel: displayLabel,
    classNames: classNames,
    formContext: formContext,
    formData: formData,
    fields: fields,
    schema: schema,
    uiSchema: uiSchema,
    registry: registry
  };
  var _AnyOfField = registry.fields.AnyOfField;
  var _OneOfField = registry.fields.OneOfField;
  return /*#__PURE__*/React.createElement(FieldTemplate, fieldProps, /*#__PURE__*/React.createElement(React.Fragment, null, field, schema.anyOf && !isSelect(schema) && /*#__PURE__*/React.createElement(_AnyOfField, {
    disabled: disabled,
    readonly: readonly,
    hideError: hideError,
    errorSchema: errorSchema,
    formData: formData,
    idPrefix: idPrefix,
    idSchema: idSchema,
    idSeparator: idSeparator,
    onBlur: props.onBlur,
    onChange: props.onChange,
    onFocus: props.onFocus,
    options: schema.anyOf.map(function (_schema) {
      return retrieveSchema(_schema, rootSchema, formData);
    }),
    baseType: schema.type,
    registry: registry,
    schema: schema,
    uiSchema: uiSchema
  }), schema.oneOf && !isSelect(schema) && /*#__PURE__*/React.createElement(_OneOfField, {
    disabled: disabled,
    readonly: readonly,
    hideError: hideError,
    errorSchema: errorSchema,
    formData: formData,
    idPrefix: idPrefix,
    idSchema: idSchema,
    idSeparator: idSeparator,
    onBlur: props.onBlur,
    onChange: props.onChange,
    onFocus: props.onFocus,
    options: schema.oneOf.map(function (_schema) {
      return retrieveSchema(_schema, rootSchema, formData);
    }),
    baseType: schema.type,
    registry: registry,
    schema: schema,
    uiSchema: uiSchema
  })));
}

var SchemaField = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(SchemaField, _React$Component);

  function SchemaField() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = SchemaField.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    return !deepEquals(this.props, nextProps);
  };

  _proto.render = function render() {
    return SchemaFieldRender(this.props);
  };

  return SchemaField;
}(React.Component);

SchemaField.defaultProps = {
  uiSchema: {},
  errorSchema: {},
  idSchema: {},
  disabled: false,
  readonly: false,
  autofocus: false,
  hideError: false
};

if (process.env.NODE_ENV !== "production") {
  SchemaField.propTypes = {
    schema: PropTypes.object.isRequired,
    uiSchema: PropTypes.object,
    idSchema: PropTypes.object,
    formData: PropTypes.any,
    errorSchema: PropTypes.object,
    registry: registry.isRequired
  };
}

function StringField(props) {
  var schema = props.schema,
      name = props.name,
      uiSchema = props.uiSchema,
      idSchema = props.idSchema,
      formData = props.formData,
      required = props.required,
      disabled = props.disabled,
      readonly = props.readonly,
      autofocus = props.autofocus,
      onChange = props.onChange,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      registry = props.registry,
      rawErrors = props.rawErrors;
  var title = schema.title,
      format = schema.format;
  var widgets = registry.widgets,
      formContext = registry.formContext;
  var enumOptions = isSelect(schema) && optionsList(schema);
  var defaultWidget = enumOptions ? "select" : "text";

  if (format && hasWidget(schema, format, widgets)) {
    defaultWidget = format;
  }

  var _getUiOptions = getUiOptions(uiSchema),
      _getUiOptions$widget = _getUiOptions.widget,
      widget = _getUiOptions$widget === void 0 ? defaultWidget : _getUiOptions$widget,
      _getUiOptions$placeho = _getUiOptions.placeholder,
      placeholder = _getUiOptions$placeho === void 0 ? "" : _getUiOptions$placeho,
      options = _objectWithoutPropertiesLoose(_getUiOptions, ["widget", "placeholder"]);

  var Widget = getWidget(schema, widget, widgets);
  return /*#__PURE__*/React.createElement(Widget, {
    options: _extends({}, options, {
      enumOptions: enumOptions
    }),
    schema: schema,
    uiSchema: uiSchema,
    id: idSchema && idSchema.$id,
    label: title === undefined ? name : title,
    value: formData,
    onChange: onChange,
    onBlur: onBlur,
    onFocus: onFocus,
    required: required,
    disabled: disabled,
    readonly: readonly,
    formContext: formContext,
    autofocus: autofocus,
    registry: registry,
    placeholder: placeholder,
    rawErrors: rawErrors
  });
}

if (process.env.NODE_ENV !== "production") {
  StringField.propTypes = fieldProps;
}

StringField.defaultProps = {
  uiSchema: {},
  disabled: false,
  readonly: false,
  autofocus: false
};

var REQUIRED_FIELD_SYMBOL$1 = "*";

function TitleField(props) {
  var id = props.id,
      title = props.title,
      required = props.required;
  return /*#__PURE__*/React.createElement("legend", {
    id: id
  }, title, required && /*#__PURE__*/React.createElement("span", {
    className: "required"
  }, REQUIRED_FIELD_SYMBOL$1));
}

if (process.env.NODE_ENV !== "production") {
  TitleField.propTypes = {
    id: PropTypes.string,
    title: PropTypes.string,
    required: PropTypes.bool
  };
}

var NullField = /*#__PURE__*/function (_Component) {
  _inheritsLoose(NullField, _Component);

  function NullField() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = NullField.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.formData === undefined) {
      this.props.onChange(null);
    }
  };

  _proto.render = function render() {
    return null;
  };

  return NullField;
}(Component);

if (process.env.NODE_ENV !== "production") {
  NullField.propTypes = fieldProps;
}

function UnsupportedField(_ref) {
  var schema = _ref.schema,
      idSchema = _ref.idSchema,
      reason = _ref.reason;
  return /*#__PURE__*/React.createElement("div", {
    className: "unsupported-field"
  }, /*#__PURE__*/React.createElement("p", null, "Unsupported field schema", idSchema && idSchema.$id && /*#__PURE__*/React.createElement("span", null, " for", " field ", /*#__PURE__*/React.createElement("code", null, idSchema.$id)), reason && /*#__PURE__*/React.createElement("em", null, ": ", reason), "."), schema && /*#__PURE__*/React.createElement("pre", null, JSON.stringify(schema, null, 2)));
}

if (process.env.NODE_ENV !== "production") {
  UnsupportedField.propTypes = {
    schema: PropTypes.object.isRequired,
    idSchema: PropTypes.object,
    reason: PropTypes.string
  };
}

var fields = {
  AnyOfField: AnyOfField,
  ArrayField: ArrayField,
  BooleanField: BooleanField,
  DescriptionField: DescriptionField,
  NumberField: NumberField,
  ObjectField: ObjectField,
  OneOfField: AnyOfField,
  SchemaField: SchemaField,
  StringField: StringField,
  TitleField: TitleField,
  NullField: NullField,
  UnsupportedField: UnsupportedField
};

function rangeOptions(start, stop) {
  var options = [];

  for (var i = start; i <= stop; i++) {
    options.push({
      value: i,
      label: pad(i, 2)
    });
  }

  return options;
}

function readyForChange(state) {
  return Object.keys(state).every(function (key) {
    return state[key] !== -1;
  });
}

function DateElement(props) {
  var type = props.type,
      range = props.range,
      value = props.value,
      select = props.select,
      rootId = props.rootId,
      disabled = props.disabled,
      readonly = props.readonly,
      autofocus = props.autofocus,
      registry = props.registry,
      onBlur = props.onBlur;
  var id = rootId + "_" + type;
  var SelectWidget = registry.widgets.SelectWidget;
  return /*#__PURE__*/React.createElement(SelectWidget, {
    schema: {
      type: "integer"
    },
    id: id,
    className: "form-control",
    options: {
      enumOptions: rangeOptions(range[0], range[1])
    },
    placeholder: type,
    value: value,
    disabled: disabled,
    readonly: readonly,
    autofocus: autofocus,
    onChange: function onChange(value) {
      return select(type, value);
    },
    onBlur: onBlur
  });
}

var AltDateWidget = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AltDateWidget, _Component);

  function AltDateWidget(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.onChange = function (property, value) {
      var _this$setState;

      _this.setState((_this$setState = {}, _this$setState[property] = typeof value === "undefined" ? -1 : value, _this$setState), function () {
        // Only propagate to parent state if we have a complete date{time}
        if (readyForChange(_this.state)) {
          _this.props.onChange(toDateString(_this.state, _this.props.time));
        }
      });
    };

    _this.setNow = function (event) {
      event.preventDefault();
      var _this$props = _this.props,
          time = _this$props.time,
          disabled = _this$props.disabled,
          readonly = _this$props.readonly,
          onChange = _this$props.onChange;

      if (disabled || readonly) {
        return;
      }

      var nowDateObj = parseDateString(new Date().toJSON(), time);

      _this.setState(nowDateObj, function () {
        return onChange(toDateString(_this.state, time));
      });
    };

    _this.clear = function (event) {
      event.preventDefault();
      var _this$props2 = _this.props,
          time = _this$props2.time,
          disabled = _this$props2.disabled,
          readonly = _this$props2.readonly,
          onChange = _this$props2.onChange;

      if (disabled || readonly) {
        return;
      }

      _this.setState(parseDateString("", time), function () {
        return onChange(undefined);
      });
    };

    _this.state = parseDateString(props.value, props.time);
    return _this;
  }

  var _proto = AltDateWidget.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.value && prevProps.value !== parseDateString(this.props.value, this.props.time)) {
      this.setState(parseDateString(this.props.value, this.props.time));
    }
  };

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    return shouldRender(this, nextProps, nextState);
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props3 = this.props,
        id = _this$props3.id,
        disabled = _this$props3.disabled,
        readonly = _this$props3.readonly,
        autofocus = _this$props3.autofocus,
        registry = _this$props3.registry,
        onBlur = _this$props3.onBlur,
        options = _this$props3.options;
    return /*#__PURE__*/React.createElement("ul", {
      className: "list-inline"
    }, this.dateElementProps.map(function (elemProps, i) {
      return /*#__PURE__*/React.createElement("li", {
        key: i
      }, /*#__PURE__*/React.createElement(DateElement, _extends({
        rootId: id,
        select: _this2.onChange
      }, elemProps, {
        disabled: disabled,
        readonly: readonly,
        registry: registry,
        onBlur: onBlur,
        autofocus: autofocus && i === 0
      })));
    }), (options.hideNowButton !== "undefined" ? !options.hideNowButton : true) && /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("a", {
      href: "#",
      className: "btn btn-info btn-now",
      onClick: this.setNow
    }, "Now")), (options.hideClearButton !== "undefined" ? !options.hideClearButton : true) && /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("a", {
      href: "#",
      className: "btn btn-warning btn-clear",
      onClick: this.clear
    }, "Clear")));
  };

  _createClass(AltDateWidget, [{
    key: "dateElementProps",
    get: function get() {
      var _this$props4 = this.props,
          time = _this$props4.time,
          options = _this$props4.options;
      var _this$state = this.state,
          year = _this$state.year,
          month = _this$state.month,
          day = _this$state.day,
          hour = _this$state.hour,
          minute = _this$state.minute,
          second = _this$state.second;
      var data = [{
        type: "year",
        range: options.yearsRange,
        value: year
      }, {
        type: "month",
        range: [1, 12],
        value: month
      }, {
        type: "day",
        range: [1, 31],
        value: day
      }];

      if (time) {
        data.push({
          type: "hour",
          range: [0, 23],
          value: hour
        }, {
          type: "minute",
          range: [0, 59],
          value: minute
        }, {
          type: "second",
          range: [0, 59],
          value: second
        });
      }

      return data;
    }
  }]);

  return AltDateWidget;
}(Component);

AltDateWidget.defaultProps = {
  time: false,
  disabled: false,
  readonly: false,
  autofocus: false,
  options: {
    yearsRange: [1900, /*#__PURE__*/new Date().getFullYear() + 2]
  }
};

if (process.env.NODE_ENV !== "production") {
  AltDateWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    value: PropTypes.string,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    time: PropTypes.bool,
    options: PropTypes.object
  };
}

function AltDateTimeWidget(props) {
  var AltDateWidget = props.registry.widgets.AltDateWidget;
  return /*#__PURE__*/React.createElement(AltDateWidget, _extends({
    time: true
  }, props));
}

if (process.env.NODE_ENV !== "production") {
  AltDateTimeWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    value: PropTypes.string,
    required: PropTypes.bool,
    onChange: PropTypes.func,
    options: PropTypes.object
  };
}

AltDateTimeWidget.defaultProps = /*#__PURE__*/_extends({}, AltDateWidget.defaultProps, {
  time: true
});

function BaseInput(props) {
  // Note: since React 15.2.0 we can't forward unknown element attributes, so we
  // exclude the "options" and "schema" ones here.
  if (!props.id) {
    console.log("No id for", props);
    throw new Error("no id for props " + JSON.stringify(props));
  }

  var value = props.value,
      readonly = props.readonly,
      disabled = props.disabled,
      autofocus = props.autofocus,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      options = props.options,
      schema = props.schema,
      inputProps = _objectWithoutPropertiesLoose(props, ["value", "readonly", "disabled", "autofocus", "onBlur", "onFocus", "options", "schema", "uiSchema", "formContext", "registry", "rawErrors"]); // If options.inputType is set use that as the input type


  if (options.inputType) {
    inputProps.type = options.inputType;
  } else if (!inputProps.type) {
    // If the schema is of type number or integer, set the input type to number
    if (schema.type === "number") {
      inputProps.type = "number"; // Setting step to 'any' fixes a bug in Safari where decimals are not
      // allowed in number inputs

      inputProps.step = "any";
    } else if (schema.type === "integer") {
      inputProps.type = "number"; // Since this is integer, you always want to step up or down in multiples
      // of 1

      inputProps.step = "1";
    } else {
      inputProps.type = "text";
    }
  }

  if (options.autocomplete) {
    inputProps.autoComplete = options.autocomplete;
  } // If multipleOf is defined, use this as the step value. This mainly improves
  // the experience for keyboard users (who can use the up/down KB arrows).


  if (schema.multipleOf) {
    inputProps.step = schema.multipleOf;
  }

  if (typeof schema.minimum !== "undefined") {
    inputProps.min = schema.minimum;
  }

  if (typeof schema.maximum !== "undefined") {
    inputProps.max = schema.maximum;
  }

  var _onChange = function _onChange(_ref) {
    var value = _ref.target.value;
    return props.onChange(value === "" ? options.emptyValue : value);
  };

  return [/*#__PURE__*/React.createElement("input", _extends({
    key: inputProps.id,
    className: "form-control",
    readOnly: readonly,
    disabled: disabled,
    autoFocus: autofocus,
    value: value == null ? "" : value
  }, inputProps, {
    list: schema.examples ? "examples_" + inputProps.id : null,
    onChange: _onChange,
    onBlur: onBlur && function (event) {
      return onBlur(inputProps.id, event.target.value);
    },
    onFocus: onFocus && function (event) {
      return onFocus(inputProps.id, event.target.value);
    }
  })), schema.examples ? /*#__PURE__*/React.createElement("datalist", {
    key: "datalist_" + inputProps.id,
    id: "examples_" + inputProps.id
  }, [].concat(new Set(schema.examples.concat(schema["default"] ? [schema["default"]] : []))).map(function (example) {
    return /*#__PURE__*/React.createElement("option", {
      key: example,
      value: example
    });
  })) : null];
}

BaseInput.defaultProps = {
  required: false,
  disabled: false,
  readonly: false,
  autofocus: false
};

if (process.env.NODE_ENV !== "production") {
  BaseInput.propTypes = {
    id: PropTypes.string.isRequired,
    placeholder: PropTypes.string,
    value: PropTypes.any,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func
  };
}

function CheckboxWidget(props) {
  var schema = props.schema,
      id = props.id,
      value = props.value,
      disabled = props.disabled,
      readonly = props.readonly,
      label = props.label,
      autofocus = props.autofocus,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      _onChange = props.onChange,
      DescriptionField = props.DescriptionField; // Because an unchecked checkbox will cause html5 validation to fail, only add
  // the "required" attribute if the field value must be "true", due to the
  // "const" or "enum" keywords

  var required = schemaRequiresTrueValue(schema);
  return /*#__PURE__*/React.createElement("div", {
    className: "checkbox " + (disabled || readonly ? "disabled" : "")
  }, schema.description && /*#__PURE__*/React.createElement(DescriptionField, {
    description: schema.description
  }), /*#__PURE__*/React.createElement("label", null, /*#__PURE__*/React.createElement("input", {
    type: "checkbox",
    id: id,
    checked: typeof value === "undefined" ? false : value,
    required: required,
    disabled: disabled || readonly,
    autoFocus: autofocus,
    onChange: function onChange(event) {
      return _onChange(event.target.checked);
    },
    onBlur: onBlur && function (event) {
      return onBlur(id, event.target.checked);
    },
    onFocus: onFocus && function (event) {
      return onFocus(id, event.target.checked);
    }
  }), /*#__PURE__*/React.createElement("span", null, label)));
}

CheckboxWidget.defaultProps = {
  autofocus: false
};

if (process.env.NODE_ENV !== "production") {
  CheckboxWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    value: PropTypes.bool,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func
  };
}

function selectValue(value, selected, all) {
  var at = all.indexOf(value);
  var updated = selected.slice(0, at).concat(value, selected.slice(at)); // As inserting values at predefined index positions doesn't work with empty
  // arrays, we need to reorder the updated selection to match the initial order

  return updated.sort(function (a, b) {
    return all.indexOf(a) > all.indexOf(b);
  });
}

function deselectValue(value, selected) {
  return selected.filter(function (v) {
    return v !== value;
  });
}

function CheckboxesWidget(props) {
  var id = props.id,
      disabled = props.disabled,
      options = props.options,
      value = props.value,
      autofocus = props.autofocus,
      readonly = props.readonly,
      _onChange = props.onChange;
  var enumOptions = options.enumOptions,
      enumDisabled = options.enumDisabled,
      inline = options.inline;
  return /*#__PURE__*/React.createElement("div", {
    className: "checkboxes",
    id: id
  }, enumOptions.map(function (option, index) {
    var checked = value.indexOf(option.value) !== -1;
    var itemDisabled = enumDisabled && enumDisabled.indexOf(option.value) != -1;
    var disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    var checkbox = /*#__PURE__*/React.createElement("span", null, /*#__PURE__*/React.createElement("input", {
      type: "checkbox",
      id: id + "_" + index,
      checked: checked,
      disabled: disabled || itemDisabled || readonly,
      autoFocus: autofocus && index === 0,
      onChange: function onChange(event) {
        var all = enumOptions.map(function (_ref) {
          var value = _ref.value;
          return value;
        });

        if (event.target.checked) {
          _onChange(selectValue(option.value, value, all));
        } else {
          _onChange(deselectValue(option.value, value));
        }
      }
    }), /*#__PURE__*/React.createElement("span", null, option.label));
    return inline ? /*#__PURE__*/React.createElement("label", {
      key: index,
      className: "checkbox-inline " + disabledCls
    }, checkbox) : /*#__PURE__*/React.createElement("div", {
      key: index,
      className: "checkbox " + disabledCls
    }, /*#__PURE__*/React.createElement("label", null, checkbox));
  }));
}

CheckboxesWidget.defaultProps = {
  autofocus: false,
  options: {
    inline: false
  }
};

if (process.env.NODE_ENV !== "production") {
  CheckboxesWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    options: /*#__PURE__*/PropTypes.shape({
      enumOptions: PropTypes.array,
      inline: PropTypes.bool
    }).isRequired,
    value: PropTypes.any,
    required: PropTypes.bool,
    readonly: PropTypes.bool,
    disabled: PropTypes.bool,
    multiple: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func
  };
}

function ColorWidget(props) {
  var disabled = props.disabled,
      readonly = props.readonly,
      BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "color"
  }, props, {
    disabled: disabled || readonly
  }));
}

if (process.env.NODE_ENV !== "production") {
  ColorWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    value: PropTypes.string,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func
  };
}

function DateWidget(props) {
  var _onChange = props.onChange,
      BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "date"
  }, props, {
    onChange: function onChange(value) {
      return _onChange(value || undefined);
    }
  }));
}

if (process.env.NODE_ENV !== "production") {
  DateWidget.propTypes = {
    value: PropTypes.string
  };
}

function DateTimeWidget(props) {
  var value = props.value,
      _onChange = props.onChange,
      BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "datetime-local"
  }, props, {
    value: utcToLocal(value),
    onChange: function onChange(value) {
      return _onChange(localToUTC(value));
    }
  }));
}

if (process.env.NODE_ENV !== "production") {
  DateTimeWidget.propTypes = {
    value: PropTypes.string
  };
}

function EmailWidget(props) {
  var BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "email"
  }, props));
}

if (process.env.NODE_ENV !== "production") {
  EmailWidget.propTypes = {
    value: PropTypes.string
  };
}

function addNameToDataURL(dataURL, name) {
  return dataURL.replace(";base64", ";name=" + encodeURIComponent(name) + ";base64");
}

function processFile(file) {
  var name = file.name,
      size = file.size,
      type = file.type;
  return new Promise(function (resolve, reject) {
    var reader = new window.FileReader();
    reader.onerror = reject;

    reader.onload = function (event) {
      resolve({
        dataURL: addNameToDataURL(event.target.result, name),
        name: name,
        size: size,
        type: type
      });
    };

    reader.readAsDataURL(file);
  });
}

function processFiles(files) {
  return Promise.all([].map.call(files, processFile));
}

function FilesInfo(props) {
  var filesInfo = props.filesInfo;

  if (filesInfo.length === 0) {
    return null;
  }

  return /*#__PURE__*/React.createElement("ul", {
    className: "file-info"
  }, filesInfo.map(function (fileInfo, key) {
    var name = fileInfo.name,
        size = fileInfo.size,
        type = fileInfo.type;
    return /*#__PURE__*/React.createElement("li", {
      key: key
    }, /*#__PURE__*/React.createElement("strong", null, name), " (", type, ", ", size, " bytes)");
  }));
}

function extractFileInfo(dataURLs) {
  return dataURLs.filter(function (dataURL) {
    return typeof dataURL !== "undefined";
  }).map(function (dataURL) {
    var _dataURItoBlob = dataURItoBlob(dataURL),
        blob = _dataURItoBlob.blob,
        name = _dataURItoBlob.name;

    return {
      name: name,
      size: blob.size,
      type: blob.type
    };
  });
}

var FileWidget = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileWidget, _Component);

  function FileWidget(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.onChange = function (event) {
      var _this$props = _this.props,
          multiple = _this$props.multiple,
          onChange = _this$props.onChange;
      processFiles(event.target.files).then(function (filesInfo) {
        var state = {
          values: filesInfo.map(function (fileInfo) {
            return fileInfo.dataURL;
          }),
          filesInfo: filesInfo
        };

        _this.setState(state, function () {
          if (multiple) {
            onChange(state.values);
          } else {
            onChange(state.values[0]);
          }
        });
      });
    };

    var value = props.value;
    var values = Array.isArray(value) ? value : [value];
    _this.state = {
      values: values,
      filesInfo: extractFileInfo(values)
    };
    return _this;
  }

  var _proto = FileWidget.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    return shouldRender(this, nextProps, nextState);
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        multiple = _this$props2.multiple,
        id = _this$props2.id,
        readonly = _this$props2.readonly,
        disabled = _this$props2.disabled,
        autofocus = _this$props2.autofocus,
        options = _this$props2.options;
    var filesInfo = this.state.filesInfo;
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("p", null, /*#__PURE__*/React.createElement("input", {
      ref: function ref(_ref) {
        return _this2.inputRef = _ref;
      },
      id: id,
      type: "file",
      disabled: readonly || disabled,
      onChange: this.onChange,
      defaultValue: "",
      autoFocus: autofocus,
      multiple: multiple,
      accept: options.accept
    })), /*#__PURE__*/React.createElement(FilesInfo, {
      filesInfo: filesInfo
    }));
  };

  return FileWidget;
}(Component);

FileWidget.defaultProps = {
  autofocus: false
};

if (process.env.NODE_ENV !== "production") {
  FileWidget.propTypes = {
    multiple: PropTypes.bool,
    value: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, /*#__PURE__*/PropTypes.arrayOf(PropTypes.string)]),
    autofocus: PropTypes.bool
  };
}

function HiddenWidget(_ref) {
  var id = _ref.id,
      value = _ref.value;
  return /*#__PURE__*/React.createElement("input", {
    type: "hidden",
    id: id,
    value: typeof value === "undefined" ? "" : value
  });
}

if (process.env.NODE_ENV !== "production") {
  HiddenWidget.propTypes = {
    id: PropTypes.string.isRequired,
    value: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool])
  };
}

function PasswordWidget(props) {
  var BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "password"
  }, props));
}

if (process.env.NODE_ENV !== "production") {
  PasswordWidget.propTypes = {
    value: PropTypes.string
  };
}

function RadioWidget(props) {
  var options = props.options,
      value = props.value,
      required = props.required,
      disabled = props.disabled,
      readonly = props.readonly,
      autofocus = props.autofocus,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      _onChange = props.onChange,
      id = props.id; // Generating a unique field name to identify this set of radio buttons

  var name = Math.random().toString();
  var enumOptions = options.enumOptions,
      enumDisabled = options.enumDisabled,
      inline = options.inline; // checked={checked} has been moved above name={name}, As mentioned in #349;
  // this is a temporary fix for radio button rendering bug in React, facebook/react#7630.

  return /*#__PURE__*/React.createElement("div", {
    className: "field-radio-group",
    id: id
  }, enumOptions.map(function (option, i) {
    var checked = option.value === value;
    var itemDisabled = enumDisabled && enumDisabled.indexOf(option.value) != -1;
    var disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    var radio = /*#__PURE__*/React.createElement("span", null, /*#__PURE__*/React.createElement("input", {
      type: "radio",
      checked: checked,
      name: name,
      required: required,
      value: option.value,
      disabled: disabled || itemDisabled || readonly,
      autoFocus: autofocus && i === 0,
      onChange: function onChange(_) {
        return _onChange(option.value);
      },
      onBlur: onBlur && function (event) {
        return onBlur(id, event.target.value);
      },
      onFocus: onFocus && function (event) {
        return onFocus(id, event.target.value);
      }
    }), /*#__PURE__*/React.createElement("span", null, option.label));
    return inline ? /*#__PURE__*/React.createElement("label", {
      key: i,
      className: "radio-inline " + disabledCls
    }, radio) : /*#__PURE__*/React.createElement("div", {
      key: i,
      className: "radio " + disabledCls
    }, /*#__PURE__*/React.createElement("label", null, radio));
  }));
}

RadioWidget.defaultProps = {
  autofocus: false
};

if (process.env.NODE_ENV !== "production") {
  RadioWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    options: /*#__PURE__*/PropTypes.shape({
      enumOptions: PropTypes.array,
      inline: PropTypes.bool
    }).isRequired,
    value: PropTypes.any,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func
  };
}

function RangeWidget(props) {
  var schema = props.schema,
      value = props.value,
      BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement("div", {
    className: "field-range-wrapper"
  }, /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "range"
  }, props, rangeSpec(schema))), /*#__PURE__*/React.createElement("span", {
    className: "range-view"
  }, value));
}

if (process.env.NODE_ENV !== "production") {
  RangeWidget.propTypes = {
    value: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  };
}

var nums = /*#__PURE__*/new Set(["number", "integer"]);
/**
 * This is a silly limitation in the DOM where option change event values are
 * always retrieved as strings.
 */

function processValue(schema, value) {
  // "enum" is a reserved word, so only "type" and "items" can be destructured
  var type = schema.type,
      items = schema.items;

  if (value === "") {
    return undefined;
  } else if (type === "array" && items && nums.has(items.type)) {
    return value.map(asNumber);
  } else if (type === "boolean") {
    return value === "true";
  } else if (type === "number") {
    return asNumber(value);
  } // If type is undefined, but an enum is present, try and infer the type from
  // the enum values


  if (schema["enum"]) {
    if (schema["enum"].every(function (x) {
      return guessType(x) === "number";
    })) {
      return asNumber(value);
    } else if (schema["enum"].every(function (x) {
      return guessType(x) === "boolean";
    })) {
      return value === "true";
    }
  }

  return value;
}

function getValue(event, multiple) {
  if (multiple) {
    return [].slice.call(event.target.options).filter(function (o) {
      return o.selected;
    }).map(function (o) {
      return o.value;
    });
  } else {
    return event.target.value;
  }
}

function SelectWidget(props) {
  var schema = props.schema,
      id = props.id,
      options = props.options,
      value = props.value,
      required = props.required,
      disabled = props.disabled,
      readonly = props.readonly,
      multiple = props.multiple,
      autofocus = props.autofocus,
      _onChange = props.onChange,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      placeholder = props.placeholder;
  var enumOptions = options.enumOptions,
      enumDisabled = options.enumDisabled;
  var emptyValue = multiple ? [] : "";
  return /*#__PURE__*/React.createElement("select", {
    id: id,
    multiple: multiple,
    className: "form-control",
    value: typeof value === "undefined" ? emptyValue : value,
    required: required,
    disabled: disabled || readonly,
    autoFocus: autofocus,
    onBlur: onBlur && function (event) {
      var newValue = getValue(event, multiple);
      onBlur(id, processValue(schema, newValue));
    },
    onFocus: onFocus && function (event) {
      var newValue = getValue(event, multiple);
      onFocus(id, processValue(schema, newValue));
    },
    onChange: function onChange(event) {
      var newValue = getValue(event, multiple);

      _onChange(processValue(schema, newValue));
    }
  }, !multiple && schema["default"] === undefined && /*#__PURE__*/React.createElement("option", {
    value: ""
  }, placeholder), enumOptions.map(function (_ref, i) {
    var value = _ref.value,
        label = _ref.label;
    var disabled = enumDisabled && enumDisabled.indexOf(value) != -1;
    return /*#__PURE__*/React.createElement("option", {
      key: i,
      value: value,
      disabled: disabled
    }, label);
  }));
}

SelectWidget.defaultProps = {
  autofocus: false
};

if (process.env.NODE_ENV !== "production") {
  SelectWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    options: /*#__PURE__*/PropTypes.shape({
      enumOptions: PropTypes.array
    }).isRequired,
    value: PropTypes.any,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    multiple: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func
  };
}

function TextareaWidget(props) {
  var id = props.id,
      options = props.options,
      placeholder = props.placeholder,
      value = props.value,
      required = props.required,
      disabled = props.disabled,
      readonly = props.readonly,
      autofocus = props.autofocus,
      onChange = props.onChange,
      onBlur = props.onBlur,
      onFocus = props.onFocus;

  var _onChange = function _onChange(_ref) {
    var value = _ref.target.value;
    return onChange(value === "" ? options.emptyValue : value);
  };

  return /*#__PURE__*/React.createElement("textarea", {
    id: id,
    className: "form-control",
    value: value ? value : "",
    placeholder: placeholder,
    required: required,
    disabled: disabled,
    readOnly: readonly,
    autoFocus: autofocus,
    rows: options.rows,
    onBlur: onBlur && function (event) {
      return onBlur(id, event.target.value);
    },
    onFocus: onFocus && function (event) {
      return onFocus(id, event.target.value);
    },
    onChange: _onChange
  });
}

TextareaWidget.defaultProps = {
  autofocus: false,
  options: {}
};

if (process.env.NODE_ENV !== "production") {
  TextareaWidget.propTypes = {
    schema: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    placeholder: PropTypes.string,
    options: /*#__PURE__*/PropTypes.shape({
      rows: PropTypes.number
    }),
    value: PropTypes.string,
    required: PropTypes.bool,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    autofocus: PropTypes.bool,
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func
  };
}

function TextWidget(props) {
  var BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, props);
}

if (process.env.NODE_ENV !== "production") {
  TextWidget.propTypes = {
    value: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    id: PropTypes.string
  };
}

function URLWidget(props) {
  var BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "url"
  }, props));
}

if (process.env.NODE_ENV !== "production") {
  URLWidget.propTypes = {
    value: PropTypes.string
  };
}

function UpDownWidget(props) {
  var BaseInput = props.registry.widgets.BaseInput;
  return /*#__PURE__*/React.createElement(BaseInput, _extends({
    type: "number"
  }, props, rangeSpec(props.schema)));
}

if (process.env.NODE_ENV !== "production") {
  UpDownWidget.propTypes = {
    value: /*#__PURE__*/PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  };
}

function SubmitButton(_ref) {
  var uiSchema = _ref.uiSchema;

  var _getSubmitButtonOptio = getSubmitButtonOptions(uiSchema),
      submitText = _getSubmitButtonOptio.submitText,
      norender = _getSubmitButtonOptio.norender,
      submitButtonProps = _getSubmitButtonOptio.props;

  return /*#__PURE__*/React.createElement("div", null, !norender && /*#__PURE__*/React.createElement("button", _extends({
    type: "submit"
  }, submitButtonProps, {
    className: "btn btn-info"
  }), submitText));
}

var widgets = {
  BaseInput: BaseInput,
  PasswordWidget: PasswordWidget,
  RadioWidget: RadioWidget,
  UpDownWidget: UpDownWidget,
  RangeWidget: RangeWidget,
  SelectWidget: SelectWidget,
  TextWidget: TextWidget,
  DateWidget: DateWidget,
  DateTimeWidget: DateTimeWidget,
  AltDateWidget: AltDateWidget,
  AltDateTimeWidget: AltDateTimeWidget,
  EmailWidget: EmailWidget,
  URLWidget: URLWidget,
  TextareaWidget: TextareaWidget,
  HiddenWidget: HiddenWidget,
  ColorWidget: ColorWidget,
  FileWidget: FileWidget,
  CheckboxWidget: CheckboxWidget,
  CheckboxesWidget: CheckboxesWidget,
  SubmitButton: SubmitButton
};

function getDefaultRegistry() {
  return {
    fields: fields,
    widgets: widgets,
    definitions: {},
    rootSchema: {},
    formContext: {}
  };
}

function ErrorList$1(props) {
  var errors = props.errors;
  return /*#__PURE__*/React.createElement("div", {
    className: "panel panel-danger errors"
  }, /*#__PURE__*/React.createElement("div", {
    className: "panel-heading"
  }, /*#__PURE__*/React.createElement("h3", {
    className: "panel-title"
  }, "Errors")), /*#__PURE__*/React.createElement("ul", {
    className: "list-group"
  }, errors.map(function (error, i) {
    return /*#__PURE__*/React.createElement("li", {
      key: i,
      className: "list-group-item text-danger"
    }, error.stack);
  })));
}

var Form = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Form, _Component);

  function Form(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.getUsedFormData = function (formData, fields) {
      //for the case of a single input form
      if (fields.length === 0 && typeof formData !== "object") {
        return formData;
      }

      var data = _pick(formData, fields);

      if (Array.isArray(formData)) {
        return Object.keys(data).map(function (key) {
          return data[key];
        });
      }

      return data;
    };

    _this.getFieldNames = function (pathSchema, formData) {
      var getAllPaths = function getAllPaths(_obj, acc, paths) {
        if (acc === void 0) {
          acc = [];
        }

        if (paths === void 0) {
          paths = [""];
        }

        Object.keys(_obj).forEach(function (key) {
          if (typeof _obj[key] === "object") {
            var newPaths = paths.map(function (path) {
              return path + "." + key;
            }); // If an object is marked with additionalProperties, all its keys are valid

            if (_obj[key].__rjsf_additionalProperties && _obj[key].$name !== "") {
              acc.push(_obj[key].$name);
            } else {
              getAllPaths(_obj[key], acc, newPaths);
            }
          } else if (key === "$name" && _obj[key] !== "") {
            paths.forEach(function (path) {
              path = path.replace(/^\./, "");

              var formValue = _get(formData, path); // adds path to fieldNames if it points to a value
              // or an empty object/array


              if (typeof formValue !== "object" || _isEmpty(formValue)) {
                acc.push(path);
              }
            });
          }
        });
        return acc;
      };

      return getAllPaths(pathSchema);
    };

    _this.onChange = function (formData, newErrorSchema) {
      if (isObject(formData) || Array.isArray(formData)) {
        var newState = _this.getStateFromProps(_this.props, formData);

        formData = newState.formData;
      }

      var mustValidate = !_this.props.noValidate && _this.props.liveValidate;
      var state = {
        formData: formData
      };
      var newFormData = formData;

      if (_this.props.omitExtraData === true && _this.props.liveOmit === true) {
        var retrievedSchema = retrieveSchema(_this.state.schema, _this.state.schema, formData);
        var pathSchema = toPathSchema(retrievedSchema, "", _this.state.schema, formData);

        var fieldNames = _this.getFieldNames(pathSchema, formData);

        newFormData = _this.getUsedFormData(formData, fieldNames);
        state = {
          formData: newFormData
        };
      }

      if (mustValidate) {
        var schemaValidation = _this.validate(newFormData);

        var errors = schemaValidation.errors;
        var errorSchema = schemaValidation.errorSchema;
        var schemaValidationErrors = errors;
        var schemaValidationErrorSchema = errorSchema;

        if (_this.props.extraErrors) {
          errorSchema = mergeObjects(errorSchema, _this.props.extraErrors, !!"concat arrays");
          errors = toErrorList(errorSchema);
        }

        state = {
          formData: newFormData,
          errors: errors,
          errorSchema: errorSchema,
          schemaValidationErrors: schemaValidationErrors,
          schemaValidationErrorSchema: schemaValidationErrorSchema
        };
      } else if (!_this.props.noValidate && newErrorSchema) {
        var _errorSchema = _this.props.extraErrors ? mergeObjects(newErrorSchema, _this.props.extraErrors, !!"concat arrays") : newErrorSchema;

        state = {
          formData: newFormData,
          errorSchema: _errorSchema,
          errors: toErrorList(_errorSchema)
        };
      }

      _this.setState(state, function () {
        return _this.props.onChange && _this.props.onChange(_this.state);
      });
    };

    _this.onBlur = function () {
      if (_this.props.onBlur) {
        var _this$props;

        (_this$props = _this.props).onBlur.apply(_this$props, arguments);
      }
    };

    _this.onFocus = function () {
      if (_this.props.onFocus) {
        var _this$props2;

        (_this$props2 = _this.props).onFocus.apply(_this$props2, arguments);
      }
    };

    _this.onSubmit = function (event) {
      event.preventDefault();

      if (event.target !== event.currentTarget) {
        return;
      }

      event.persist();
      var newFormData = _this.state.formData;

      if (_this.props.omitExtraData === true) {
        var retrievedSchema = retrieveSchema(_this.state.schema, _this.state.schema, newFormData);
        var pathSchema = toPathSchema(retrievedSchema, "", _this.state.schema, newFormData);

        var fieldNames = _this.getFieldNames(pathSchema, newFormData);

        newFormData = _this.getUsedFormData(newFormData, fieldNames);
      }

      if (!_this.props.noValidate) {
        var schemaValidation = _this.validate(newFormData);

        var _errors = schemaValidation.errors;
        var _errorSchema2 = schemaValidation.errorSchema;
        var schemaValidationErrors = _errors;
        var schemaValidationErrorSchema = _errorSchema2;

        if (Object.keys(_errors).length > 0) {
          if (_this.props.extraErrors) {
            _errorSchema2 = mergeObjects(_errorSchema2, _this.props.extraErrors, !!"concat arrays");
            _errors = toErrorList(_errorSchema2);
          }

          _this.setState({
            errors: _errors,
            errorSchema: _errorSchema2,
            schemaValidationErrors: schemaValidationErrors,
            schemaValidationErrorSchema: schemaValidationErrorSchema
          }, function () {
            if (_this.props.onError) {
              _this.props.onError(_errors);
            } else {
              console.error("Form validation failed", _errors);
            }
          });

          return;
        }
      } // There are no errors generated through schema validation.
      // Check for user provided errors and update state accordingly.


      var errorSchema;
      var errors;

      if (_this.props.extraErrors) {
        errorSchema = _this.props.extraErrors;
        errors = toErrorList(errorSchema);
      } else {
        errorSchema = {};
        errors = [];
      }

      _this.setState({
        formData: newFormData,
        errors: errors,
        errorSchema: errorSchema,
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      }, function () {
        if (_this.props.onSubmit) {
          _this.props.onSubmit(_extends({}, _this.state, {
            formData: newFormData,
            status: "submitted"
          }), event);
        }
      });
    };

    _this.state = _this.getStateFromProps(props, props.formData);

    if (_this.props.onChange && !deepEquals(_this.state.formData, _this.props.formData)) {
      _this.props.onChange(_this.state);
    }

    _this.formElement = null;
    return _this;
  }

  var _proto = Form.prototype;

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    var nextState = this.getStateFromProps(nextProps, nextProps.formData);

    if (!deepEquals(nextState.formData, nextProps.formData) && !deepEquals(nextState.formData, this.state.formData) && this.props.onChange) {
      this.props.onChange(nextState);
    }

    this.setState(nextState);
  };

  _proto.getStateFromProps = function getStateFromProps(props, inputFormData) {
    var state = this.state || {};
    var schema = "schema" in props ? props.schema : this.props.schema;
    var uiSchema = "uiSchema" in props ? props.uiSchema : this.props.uiSchema;
    var edit = typeof inputFormData !== "undefined";
    var liveValidate = "liveValidate" in props ? props.liveValidate : this.props.liveValidate;
    var mustValidate = edit && !props.noValidate && liveValidate;
    var rootSchema = schema;
    var formData = getDefaultFormState(schema, inputFormData, rootSchema);
    var retrievedSchema = retrieveSchema(schema, rootSchema, formData);
    var customFormats = props.customFormats;
    var additionalMetaSchemas = props.additionalMetaSchemas;

    var getCurrentErrors = function getCurrentErrors() {
      if (props.noValidate) {
        return {
          errors: [],
          errorSchema: {}
        };
      } else if (!props.liveValidate) {
        return {
          errors: state.schemaValidationErrors || [],
          errorSchema: state.schemaValidationErrorSchema || {}
        };
      }

      return {
        errors: state.errors || [],
        errorSchema: state.errorSchema || {}
      };
    };

    var errors, errorSchema, schemaValidationErrors, schemaValidationErrorSchema;

    if (mustValidate) {
      var schemaValidation = this.validate(formData, schema, additionalMetaSchemas, customFormats);
      errors = schemaValidation.errors;
      errorSchema = schemaValidation.errorSchema;
      schemaValidationErrors = errors;
      schemaValidationErrorSchema = errorSchema;
    } else {
      var currentErrors = getCurrentErrors();
      errors = currentErrors.errors;
      errorSchema = currentErrors.errorSchema;
      schemaValidationErrors = state.schemaValidationErrors;
      schemaValidationErrorSchema = state.schemaValidationErrorSchema;
    }

    if (props.extraErrors) {
      errorSchema = mergeObjects(errorSchema, props.extraErrors, !!"concat arrays");
      errors = toErrorList(errorSchema);
    }

    var idSchema = toIdSchema(retrievedSchema, uiSchema["ui:rootFieldId"], rootSchema, formData, props.idPrefix, props.idSeparator);
    var nextState = {
      schema: schema,
      uiSchema: uiSchema,
      idSchema: idSchema,
      formData: formData,
      edit: edit,
      errors: errors,
      errorSchema: errorSchema,
      additionalMetaSchemas: additionalMetaSchemas
    };

    if (schemaValidationErrors) {
      nextState.schemaValidationErrors = schemaValidationErrors;
      nextState.schemaValidationErrorSchema = schemaValidationErrorSchema;
    }

    return nextState;
  };

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    return shouldRender(this, nextProps, nextState);
  };

  _proto.validate = function validate(formData, schema, additionalMetaSchemas, customFormats) {
    if (schema === void 0) {
      schema = this.props.schema;
    }

    if (additionalMetaSchemas === void 0) {
      additionalMetaSchemas = this.props.additionalMetaSchemas;
    }

    if (customFormats === void 0) {
      customFormats = this.props.customFormats;
    }

    var _this$props3 = this.props,
        validate = _this$props3.validate,
        transformErrors = _this$props3.transformErrors;

    var _this$getRegistry = this.getRegistry(),
        rootSchema = _this$getRegistry.rootSchema;

    var resolvedSchema = retrieveSchema(schema, rootSchema, formData);
    return validateFormData(formData, resolvedSchema, validate, transformErrors, additionalMetaSchemas, customFormats);
  };

  _proto.renderErrors = function renderErrors() {
    var _this$state = this.state,
        errors = _this$state.errors,
        errorSchema = _this$state.errorSchema,
        schema = _this$state.schema,
        uiSchema = _this$state.uiSchema;
    var _this$props4 = this.props,
        ErrorList = _this$props4.ErrorList,
        showErrorList = _this$props4.showErrorList,
        formContext = _this$props4.formContext;

    if (errors.length && showErrorList != false) {
      return /*#__PURE__*/React.createElement(ErrorList, {
        errors: errors,
        errorSchema: errorSchema,
        schema: schema,
        uiSchema: uiSchema,
        formContext: formContext
      });
    }

    return null;
  };

  _proto.getRegistry = function getRegistry() {
    // For BC, accept passed SchemaField and TitleField props and pass them to
    // the "fields" registry one.
    var _getDefaultRegistry = getDefaultRegistry(),
        fields = _getDefaultRegistry.fields,
        widgets = _getDefaultRegistry.widgets;

    return {
      fields: _extends({}, fields, this.props.fields),
      widgets: _extends({}, widgets, this.props.widgets),
      ArrayFieldTemplate: this.props.ArrayFieldTemplate,
      ObjectFieldTemplate: this.props.ObjectFieldTemplate,
      FieldTemplate: this.props.FieldTemplate,
      definitions: this.props.schema.definitions || {},
      rootSchema: this.props.schema,
      formContext: this.props.formContext || {}
    };
  };

  _proto.submit = function submit() {
    if (this.formElement) {
      this.formElement.dispatchEvent(new CustomEvent("submit", {
        cancelable: true
      }));
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props5 = this.props,
        children = _this$props5.children,
        id = _this$props5.id,
        idPrefix = _this$props5.idPrefix,
        idSeparator = _this$props5.idSeparator,
        className = _this$props5.className,
        tagName = _this$props5.tagName,
        name = _this$props5.name,
        method = _this$props5.method,
        target = _this$props5.target,
        action = _this$props5.action,
        deprecatedAutocomplete = _this$props5.autocomplete,
        currentAutoComplete = _this$props5.autoComplete,
        enctype = _this$props5.enctype,
        acceptcharset = _this$props5.acceptcharset,
        noHtml5Validate = _this$props5.noHtml5Validate,
        disabled = _this$props5.disabled,
        readonly = _this$props5.readonly,
        formContext = _this$props5.formContext,
        _internalFormWrapper = _this$props5._internalFormWrapper;
    var _this$state2 = this.state,
        schema = _this$state2.schema,
        uiSchema = _this$state2.uiSchema,
        formData = _this$state2.formData,
        errorSchema = _this$state2.errorSchema,
        idSchema = _this$state2.idSchema;
    var registry = this.getRegistry();
    var _SchemaField = registry.fields.SchemaField; // The `semantic-ui` and `material-ui` themes have `_internalFormWrapper`s that take an `as` prop that is the
    // PropTypes.elementType to use for the inner tag so we'll need to pass `tagName` along if it is provided.
    // NOTE, the `as` prop is native to `semantic-ui` and is emulated in the `material-ui` theme

    var as = _internalFormWrapper ? tagName : undefined;
    var FormTag = _internalFormWrapper || tagName || "form";
    var SubmitButton = registry.widgets.SubmitButton;

    if (deprecatedAutocomplete) {
      console.warn("Using autocomplete property of Form is deprecated, use autoComplete instead.");
    }

    var autoComplete = currentAutoComplete ? currentAutoComplete : deprecatedAutocomplete;
    return /*#__PURE__*/React.createElement(FormTag, {
      className: className ? className : "rjsf",
      id: id,
      name: name,
      method: method,
      target: target,
      action: action,
      autoComplete: autoComplete,
      encType: enctype,
      acceptCharset: acceptcharset,
      noValidate: noHtml5Validate,
      onSubmit: this.onSubmit,
      as: as,
      ref: function ref(form) {
        _this2.formElement = form;
      }
    }, this.renderErrors(), /*#__PURE__*/React.createElement(_SchemaField, {
      schema: schema,
      uiSchema: uiSchema,
      errorSchema: errorSchema,
      idSchema: idSchema,
      idPrefix: idPrefix,
      idSeparator: idSeparator,
      formContext: formContext,
      formData: formData,
      onChange: this.onChange,
      onBlur: this.onBlur,
      onFocus: this.onFocus,
      registry: registry,
      disabled: disabled,
      readonly: readonly
    }), children ? children : /*#__PURE__*/React.createElement(SubmitButton, {
      uiSchema: uiSchema
    }));
  };

  return Form;
}(Component);

Form.defaultProps = {
  uiSchema: {},
  noValidate: false,
  liveValidate: false,
  disabled: false,
  readonly: false,
  noHtml5Validate: false,
  ErrorList: ErrorList$1,
  omitExtraData: false
};

if (process.env.NODE_ENV !== "production") {
  Form.propTypes = {
    schema: PropTypes.object.isRequired,
    uiSchema: PropTypes.object,
    formData: PropTypes.any,
    disabled: PropTypes.bool,
    readonly: PropTypes.bool,
    widgets: /*#__PURE__*/PropTypes.objectOf( /*#__PURE__*/PropTypes.oneOfType([PropTypes.func, PropTypes.object])),
    fields: /*#__PURE__*/PropTypes.objectOf(PropTypes.elementType),
    ArrayFieldTemplate: PropTypes.elementType,
    ObjectFieldTemplate: PropTypes.elementType,
    FieldTemplate: PropTypes.elementType,
    ErrorList: PropTypes.func,
    onChange: PropTypes.func,
    onError: PropTypes.func,
    showErrorList: PropTypes.bool,
    onSubmit: PropTypes.func,
    id: PropTypes.string,
    className: PropTypes.string,
    tagName: PropTypes.elementType,
    _internalFormWrapper: PropTypes.elementType,
    name: PropTypes.string,
    method: PropTypes.string,
    target: PropTypes.string,
    action: PropTypes.string,
    autocomplete: PropTypes.string,
    autoComplete: PropTypes.string,
    enctype: PropTypes.string,
    acceptcharset: PropTypes.string,
    noValidate: PropTypes.bool,
    noHtml5Validate: PropTypes.bool,
    liveValidate: PropTypes.bool,
    validate: PropTypes.func,
    transformErrors: PropTypes.func,
    formContext: PropTypes.object,
    customFormats: PropTypes.object,
    additionalMetaSchemas: /*#__PURE__*/PropTypes.arrayOf(PropTypes.object),
    omitExtraData: PropTypes.bool,
    extraErrors: PropTypes.object
  };
}

function withTheme(themeProps) {
  return forwardRef(function (_ref, ref) {
    var fields = _ref.fields,
        widgets = _ref.widgets,
        directProps = _objectWithoutPropertiesLoose(_ref, ["fields", "widgets"]);

    fields = _extends({}, themeProps.fields, fields);
    widgets = _extends({}, themeProps.widgets, widgets);
    return /*#__PURE__*/React.createElement(Form, _extends({}, themeProps, directProps, {
      fields: fields,
      widgets: widgets,
      ref: ref
    }));
  });
}

withTheme.propTypes = {
  widgets: PropTypes.object,
  fields: PropTypes.object
};

var utils = /*#__PURE__*/_extends({}, _utils, {
  getDefaultRegistry: getDefaultRegistry
});

export default Form;
export { utils, withTheme };
//# sourceMappingURL=core.esm.js.map
