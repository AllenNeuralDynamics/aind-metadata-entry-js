function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from "react";
import * as ReactIs from "react-is";
import mergeAllOf from "json-schema-merge-allof";
import fill from "core-js-pure/features/array/fill";
import union from "lodash/union";
import jsonpointer from "jsonpointer";
import validateFormData, { isValid } from "./validate";
export var ADDITIONAL_PROPERTY_FLAG = "__additional_property";
var widgetMap = {
  "boolean": {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
export function canExpand(schema, uiSchema, formData) {
  if (!schema.additionalProperties) {
    return false;
  }

  var _getUiOptions = getUiOptions(uiSchema),
      expandable = _getUiOptions.expandable;

  if (expandable === false) {
    return expandable;
  } // if ui:options.expandable was not explicitly set to false, we can add
  // another property if we have not exceeded maxProperties yet


  if (schema.maxProperties !== undefined) {
    return Object.keys(formData).length < schema.maxProperties;
  }

  return true;
}
/* Gets the type of a given schema. */

export function getSchemaType(schema) {
  var type = schema.type;

  if (!type && schema["const"]) {
    return guessType(schema["const"]);
  }

  if (!type && schema["enum"]) {
    return "string";
  }

  if (!type && (schema.properties || schema.additionalProperties)) {
    return "object";
  }

  if (type instanceof Array && type.length === 2 && type.includes("null")) {
    return type.find(function (type) {
      return type !== "null";
    });
  }

  return type;
}
export function getWidget(schema, widget) {
  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var type = getSchemaType(schema);

  function mergeOptions(Widget) {
    // cache return value as property of widget for proper react reconciliation
    if (!Widget.MergedWidget) {
      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};

      Widget.MergedWidget = function (_ref) {
        var _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            props = _objectWithoutProperties(_ref, ["options"]);

        return (
          /*#__PURE__*/
          React.createElement(Widget, _extends({
            options: _objectSpread({}, defaultOptions, options)
          }, props))
        );
      };
    }

    return Widget.MergedWidget;
  }

  if (typeof widget === "function" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {
    return mergeOptions(widget);
  }

  if (typeof widget !== "string") {
    throw new Error("Unsupported widget definition: ".concat(_typeof(widget)));
  }

  if (registeredWidgets.hasOwnProperty(widget)) {
    var registeredWidget = registeredWidgets[widget];
    return getWidget(schema, registeredWidget, registeredWidgets);
  }

  if (!widgetMap.hasOwnProperty(type)) {
    throw new Error("No widget for type \"".concat(type, "\""));
  }

  if (widgetMap[type].hasOwnProperty(widget)) {
    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];
    return getWidget(schema, _registeredWidget, registeredWidgets);
  }

  throw new Error("No widget \"".concat(widget, "\" for type \"").concat(type, "\""));
}
export function hasWidget(schema, widget) {
  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  try {
    getWidget(schema, widget, registeredWidgets);
    return true;
  } catch (e) {
    if (e.message && (e.message.startsWith("No widget") || e.message.startsWith("Unsupported widget"))) {
      return false;
    }

    throw e;
  }
}

function computeDefaults(_schema, parentDefaults, rootSchema) {
  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var schema = isObject(_schema) ? _schema : {};
  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.

  var defaults = parentDefaults;

  if (isObject(defaults) && isObject(schema["default"])) {
    // For object defaults, only override parent defaults that are defined in
    // schema.default.
    defaults = mergeObjects(defaults, schema["default"]);
  } else if ("default" in schema) {
    // Use schema defaults for this node.
    defaults = schema["default"];
  } else if ("$ref" in schema) {
    // Use referenced schema defaults for this node.
    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);
    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if ("dependencies" in schema) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if (isFixedItems(schema)) {
    defaults = schema.items.map(function (itemSchema, idx) {
      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);
    });
  } else if ("oneOf" in schema) {
    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];
  } else if ("anyOf" in schema) {
    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];
  } // Not defaults defined for this node, fallback to generic typed ones.


  if (typeof defaults === "undefined") {
    defaults = schema["default"];
  }

  switch (getSchemaType(schema)) {
    // We need to recur for object schema inner default values.
    case "object":
      return Object.keys(schema.properties || {}).reduce(function (acc, key) {
        // Compute the defaults for this node, with the parent defaults we might
        // have from a previous run: defaults[key].
        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);

        if (includeUndefinedValues || computedDefault !== undefined) {
          acc[key] = computedDefault;
        }

        return acc;
      }, {});

    case "array":
      // Inject defaults into existing array defaults
      if (Array.isArray(defaults)) {
        defaults = defaults.map(function (item, idx) {
          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);
        });
      } // Deeply inject defaults into already existing form data


      if (Array.isArray(rawFormData)) {
        defaults = rawFormData.map(function (item, idx) {
          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);
        });
      }

      if (schema.minItems) {
        if (!isMultiSelect(schema, rootSchema)) {
          var defaultsLength = defaults ? defaults.length : 0;

          if (schema.minItems > defaultsLength) {
            var defaultEntries = defaults || []; // populate the array with the defaults

            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;
            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems

            return defaultEntries.concat(fillerEntries);
          }
        } else {
          return defaults ? defaults : [];
        }
      }

  }

  return defaults;
}

export function getDefaultFormState(_schema, formData) {
  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (!isObject(_schema)) {
    throw new Error("Invalid schema: " + _schema);
  }

  var schema = retrieveSchema(_schema, rootSchema, formData);
  var defaults = computeDefaults(schema, _schema["default"], rootSchema, formData, includeUndefinedValues);

  if (typeof formData === "undefined") {
    // No form data? Use schema defaults.
    return defaults;
  }

  if (isObject(formData) || Array.isArray(formData)) {
    return mergeDefaultsWithFormData(defaults, formData);
  }

  if (formData === 0 || formData === false || formData === "") {
    return formData;
  }

  return formData || defaults;
}
/**
 * When merging defaults and form data, we want to merge in this specific way:
 * - objects are deeply merged
 * - arrays are merged in such a way that:
 *   - when the array is set in form data, only array entries set in form data
 *     are deeply merged; additional entries from the defaults are ignored
 *   - when the array is not set in form data, the default is copied over
 * - scalars are overwritten/set by form data
 */

export function mergeDefaultsWithFormData(defaults, formData) {
  if (Array.isArray(formData)) {
    if (!Array.isArray(defaults)) {
      defaults = [];
    }

    return formData.map(function (value, idx) {
      if (defaults[idx]) {
        return mergeDefaultsWithFormData(defaults[idx], value);
      }

      return value;
    });
  } else if (isObject(formData)) {
    var acc = Object.assign({}, defaults); // Prevent mutation of source object.

    return Object.keys(formData).reduce(function (acc, key) {
      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);
      return acc;
    }, acc);
  } else {
    return formData;
  }
}
export function getUiOptions(uiSchema) {
  // get all passed options from ui:widget, ui:options, and ui:<optionName>
  return Object.keys(uiSchema).filter(function (key) {
    return key.indexOf("ui:") === 0;
  }).reduce(function (options, key) {
    var value = uiSchema[key];

    if (key === "ui:widget" && isObject(value)) {
      console.warn("Setting options via ui:widget object is deprecated, use ui:options instead");
      return _objectSpread({}, options, value.options || {}, {
        widget: value.component
      });
    }

    if (key === "ui:options" && isObject(value)) {
      return _objectSpread({}, options, value);
    }

    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));
  }, {});
}
export function getSubmitButtonOptions(uiSchema) {
  var uiOptions = getUiOptions(uiSchema);
  var defaultOptions = {
    props: {
      disabled: false
    },
    submitText: "Submit",
    norender: false
  };

  if (uiOptions && uiOptions["submitButtonOptions"]) {
    return Object.assign({}, defaultOptions, uiOptions["submitButtonOptions"]);
  }

  return defaultOptions;
}
export function getDisplayLabel(schema, uiSchema, rootSchema) {
  var uiOptions = getUiOptions(uiSchema);
  var _uiOptions$label = uiOptions.label,
      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;
  var schemaType = getSchemaType(schema);

  if (schemaType === "array") {
    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema) || isCustomWidget(uiSchema);
  }

  if (schemaType === "object") {
    displayLabel = false;
  }

  if (schemaType === "boolean" && !uiSchema["ui:widget"]) {
    displayLabel = false;
  }

  if (uiSchema["ui:field"]) {
    displayLabel = false;
  }

  return displayLabel;
}
export function isObject(thing) {
  if (typeof File !== "undefined" && thing instanceof File) {
    return false;
  }

  return _typeof(thing) === "object" && thing !== null && !Array.isArray(thing);
}
export function mergeObjects(obj1, obj2) {
  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // Recursively merge deeply nested objects.
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeObjects(left, right, concatArrays);
    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
      acc[key] = left.concat(right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}
export function asNumber(value) {
  if (value === "") {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  if (/\.$/.test(value)) {
    // "3." can't really be considered a number even if it parses in js. The
    // user is most likely entering a float.
    return value;
  }

  if (/\.0$/.test(value)) {
    // we need to return this as a string here, to allow for input like 3.07
    return value;
  }

  var n = Number(value);
  var valid = typeof n === "number" && !Number.isNaN(n);

  if (/\.\d*0$/.test(value)) {
    // It's a number, that's cool - but we need it as a string so it doesn't screw
    // with the user when entering dollar amounts or other values (such as those with
    // specific precision or number of significant digits)
    return value;
  }

  return valid ? n : value;
}
export function orderProperties(properties, order) {
  if (!Array.isArray(order)) {
    return properties;
  }

  var arrayToHash = function arrayToHash(arr) {
    return arr.reduce(function (prev, curr) {
      prev[curr] = true;
      return prev;
    }, {});
  };

  var errorPropList = function errorPropList(arr) {
    return arr.length > 1 ? "properties '".concat(arr.join("', '"), "'") : "property '".concat(arr[0], "'");
  };

  var propertyHash = arrayToHash(properties);
  var orderFiltered = order.filter(function (prop) {
    return prop === "*" || propertyHash[prop];
  });
  var orderHash = arrayToHash(orderFiltered);
  var rest = properties.filter(function (prop) {
    return !orderHash[prop];
  });
  var restIndex = orderFiltered.indexOf("*");

  if (restIndex === -1) {
    if (rest.length) {
      throw new Error("uiSchema order list does not contain ".concat(errorPropList(rest)));
    }

    return orderFiltered;
  }

  if (restIndex !== orderFiltered.lastIndexOf("*")) {
    throw new Error("uiSchema order list contains more than one wildcard item");
  }

  var complete = _toConsumableArray(orderFiltered);

  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));
  return complete;
}
/**
 * This function checks if the given schema matches a single
 * constant value.
 */

export function isConstant(schema) {
  return Array.isArray(schema["enum"]) && schema["enum"].length === 1 || schema.hasOwnProperty("const");
}
export function toConstant(schema) {
  if (Array.isArray(schema["enum"]) && schema["enum"].length === 1) {
    return schema["enum"][0];
  } else if (schema.hasOwnProperty("const")) {
    return schema["const"];
  } else {
    throw new Error("schema cannot be inferred as a constant");
  }
}
export function isSelect(_schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var schema = retrieveSchema(_schema, rootSchema);
  var altSchemas = schema.oneOf || schema.anyOf;

  if (Array.isArray(schema["enum"])) {
    return true;
  } else if (Array.isArray(altSchemas)) {
    return altSchemas.every(function (altSchemas) {
      return isConstant(altSchemas);
    });
  }

  return false;
}
export function isMultiSelect(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!schema.uniqueItems || !schema.items) {
    return false;
  }

  return isSelect(schema.items, rootSchema);
}
export function isFilesArray(schema, uiSchema) {
  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (uiSchema["ui:widget"] === "files") {
    return true;
  } else if (schema.items) {
    var itemsSchema = retrieveSchema(schema.items, rootSchema);
    return itemsSchema.type === "string" && itemsSchema.format === "data-url";
  }

  return false;
}
export function isFixedItems(schema) {
  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {
    return isObject(item);
  });
}
export function isCustomWidget(uiSchema) {
  return (// TODO: Remove the `&& uiSchema["ui:widget"] !== "hidden"` once we support hidden widgets for arrays.
    // https://react-jsonschema-form.readthedocs.io/en/latest/usage/widgets/#hidden-widgets
    "widget" in getUiOptions(uiSchema) && getUiOptions(uiSchema)["widget"] !== "hidden"
  );
}
export function allowAdditionalItems(schema) {
  if (schema.additionalItems === true) {
    console.warn("additionalItems=true is currently not supported");
  }

  return isObject(schema.additionalItems);
}
export function optionsList(schema) {
  if (schema["enum"]) {
    return schema["enum"].map(function (value, i) {
      var label = schema.enumNames && schema.enumNames[i] || String(value);
      return {
        label: label,
        value: value
      };
    });
  } else {
    var altSchemas = schema.oneOf || schema.anyOf;
    return altSchemas.map(function (schema) {
      var value = toConstant(schema);
      var label = schema.title || String(value);
      return {
        schema: schema,
        label: label,
        value: value
      };
    });
  }
}
export function findSchemaDefinition($ref) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var origRef = $ref;

  if ($ref.startsWith("#")) {
    // Decode URI fragment representation.
    $ref = decodeURIComponent($ref.substring(1));
  } else {
    throw new Error("Could not find a definition for ".concat(origRef, "."));
  }

  var current = jsonpointer.get(rootSchema, $ref);

  if (current === undefined) {
    throw new Error("Could not find a definition for ".concat(origRef, "."));
  }

  if (current.hasOwnProperty("$ref")) {
    return findSchemaDefinition(current.$ref, rootSchema);
  }

  return current;
} // In the case where we have to implicitly create a schema, it is useful to know what type to use
//  based on the data we are defining

export var guessType = function guessType(value) {
  if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "string") {
    return "string";
  } else if (value == null) {
    return "null";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (!isNaN(value)) {
    return "number";
  } else if (_typeof(value) === "object") {
    return "object";
  } // Default to string if we can't figure it out


  return "string";
}; // This function will create new "properties" items for each key in our formData

export function stubExistingAdditionalProperties(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Clone the schema so we don't ruin the consumer's original
  schema = _objectSpread({}, schema, {
    properties: _objectSpread({}, schema.properties)
  }); // make sure formData is an object

  formData = isObject(formData) ? formData : {};
  Object.keys(formData).forEach(function (key) {
    if (schema.properties.hasOwnProperty(key)) {
      // No need to stub, our schema already has the property
      return;
    }

    var additionalProperties;

    if (schema.additionalProperties.hasOwnProperty("$ref")) {
      additionalProperties = retrieveSchema({
        $ref: schema.additionalProperties["$ref"]
      }, rootSchema, formData);
    } else if (schema.additionalProperties.hasOwnProperty("type")) {
      additionalProperties = _objectSpread({}, schema.additionalProperties);
    } else {
      additionalProperties = {
        type: guessType(formData[key])
      };
    } // The type of our new key should match the additionalProperties value;


    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added

    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;
  });
  return schema;
}
/**
 * Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch with the rest of the schema
 */

var resolveCondition = function resolveCondition(schema, rootSchema, formData) {
  var expression = schema["if"],
      then = schema.then,
      otherwise = schema["else"],
      resolvedSchemaLessConditional = _objectWithoutProperties(schema, ["if", "then", "else"]);

  var conditionalSchema = isValid(expression, formData, rootSchema) ? then : otherwise;

  if (conditionalSchema) {
    return retrieveSchema(mergeSchemas(resolvedSchemaLessConditional, retrieveSchema(conditionalSchema, rootSchema, formData)), rootSchema, formData);
  } else {
    return retrieveSchema(resolvedSchemaLessConditional, rootSchema, formData);
  }
};
/**
 * Resolves references and dependencies within a schema and its 'allOf' children.
 *
 * Called internally by retrieveSchema.
 */


export function resolveSchema(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (schema.hasOwnProperty("$ref")) {
    return resolveReference(schema, rootSchema, formData);
  } else if (schema.hasOwnProperty("dependencies")) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return retrieveSchema(resolvedSchema, rootSchema, formData);
  } else if (schema.hasOwnProperty("allOf")) {
    return _objectSpread({}, schema, {
      allOf: schema.allOf.map(function (allOfSubschema) {
        return retrieveSchema(allOfSubschema, rootSchema, formData);
      })
    });
  } else {
    // No $ref or dependencies attribute found, returning the original schema.
    return schema;
  }
}

function resolveReference(schema, rootSchema, formData) {
  // Retrieve the referenced schema definition.
  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.

  var $ref = schema.$ref,
      localSchema = _objectWithoutProperties(schema, ["$ref"]); // Update referenced schema definition with local schema properties.


  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);
}

export function retrieveSchema(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!isObject(schema)) {
    return {};
  }

  var resolvedSchema = resolveSchema(schema, rootSchema, formData);

  if (schema.hasOwnProperty("if")) {
    return resolveCondition(schema, rootSchema, formData);
  } // For each level of the dependency, we need to recursively determine the appropriate resolved schema given the current state of formData.
  // Otherwise, nested allOf subschemas will not be correctly displayed.


  if (resolvedSchema.properties) {
    var properties = {};
    Object.entries(resolvedSchema.properties).forEach(function (entries) {
      var propName = entries[0];
      var propSchema = entries[1];
      var rawPropData = formData && formData[propName];
      var propData = isObject(rawPropData) ? rawPropData : {};
      var resolvedPropSchema = retrieveSchema(propSchema, rootSchema, propData);
      properties[propName] = resolvedPropSchema;

      if (propSchema !== resolvedPropSchema && resolvedSchema.properties !== properties) {
        resolvedSchema = _objectSpread({}, resolvedSchema, {
          properties: properties
        });
      }
    });
  }

  if ("allOf" in schema) {
    try {
      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {
        allOf: resolvedSchema.allOf
      }));
    } catch (e) {
      console.warn("could not merge subschemas in allOf:\n" + e);

      var _resolvedSchema = resolvedSchema,
          allOf = _resolvedSchema.allOf,
          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, ["allOf"]);

      return resolvedSchemaWithoutAllOf;
    }
  }

  var hasAdditionalProperties = resolvedSchema.hasOwnProperty("additionalProperties") && resolvedSchema.additionalProperties !== false;

  if (hasAdditionalProperties) {
    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function resolveDependencies(schema, rootSchema, formData) {
  // Drop the dependencies from the source schema.
  var _schema$dependencies = schema.dependencies,
      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,
      resolvedSchema = _objectWithoutProperties(schema, ["dependencies"]);

  if ("oneOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];
  } else if ("anyOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];
  }

  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);
}

function processDependencies(dependencies, resolvedSchema, rootSchema, formData) {
  // Process dependencies updating the local schema properties as appropriate.
  for (var dependencyKey in dependencies) {
    // Skip this dependency if its trigger property is not present.
    if (formData[dependencyKey] === undefined) {
      continue;
    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)


    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
      continue;
    }

    var dependencyValue = dependencies[dependencyKey],
        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));

    if (Array.isArray(dependencyValue)) {
      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);
    } else if (isObject(dependencyValue)) {
      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);
    }

    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function withDependentProperties(schema, additionallyRequired) {
  if (!additionallyRequired) {
    return schema;
  }

  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;
  return _objectSpread({}, schema, {
    required: required
  });
}

function withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {
  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),
      oneOf = _retrieveSchema.oneOf,
      dependentSchema = _objectWithoutProperties(_retrieveSchema, ["oneOf"]);

  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.

  if (oneOf === undefined) {
    return schema;
  } else if (!Array.isArray(oneOf)) {
    throw new Error("invalid: it is some ".concat(_typeof(oneOf), " instead of an array"));
  } // Resolve $refs inside oneOf.


  var resolvedOneOf = oneOf.map(function (subschema) {
    return subschema.hasOwnProperty("$ref") ? resolveReference(subschema, rootSchema, formData) : subschema;
  });
  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);
}

function withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {
  var validSubschemas = oneOf.filter(function (subschema) {
    if (!subschema.properties) {
      return false;
    }

    var conditionPropertySchema = subschema.properties[dependencyKey];

    if (conditionPropertySchema) {
      var conditionSchema = {
        type: "object",
        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)
      };

      var _validateFormData = validateFormData(formData, conditionSchema),
          errors = _validateFormData.errors;

      return errors.length === 0;
    }
  });

  if (validSubschemas.length !== 1) {
    console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
    return schema;
  }

  var subschema = validSubschemas[0];

  var _subschema$properties = subschema.properties,
      conditionPropertySchema = _subschema$properties[dependencyKey],
      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));

  var dependentSchema = _objectSpread({}, subschema, {
    properties: dependentSubschema
  });

  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));
} // Recursively merge deeply nested schemas.
// The difference between mergeSchemas and mergeObjects
// is that mergeSchemas only concats arrays for
// values under the "required" keyword, and when it does,
// it doesn't include duplicate values.


export function mergeSchemas(obj1, obj2) {
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeSchemas(left, right);
    } else if (obj1 && obj2 && (getSchemaType(obj1) === "object" || getSchemaType(obj2) === "object") && key === "required" && Array.isArray(left) && Array.isArray(right)) {
      // Don't include duplicate values when merging
      // "required" fields.
      acc[key] = union(left, right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}

function isArguments(object) {
  return Object.prototype.toString.call(object) === "[object Arguments]";
}

export function deepEquals(a, b) {
  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  // Partially extracted from node-deeper and adapted to exclude comparison
  // checks for functions.
  // https://github.com/othiym23/node-deeper
  if (a === b) {
    return true;
  } else if (typeof a === "function" || typeof b === "function") {
    // Assume all functions are equivalent
    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255
    return true;
  } else if (_typeof(a) !== "object" || _typeof(b) !== "object") {
    return false;
  } else if (a === null || b === null) {
    return false;
  } else if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  } else if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;
  } else if (isArguments(a) || isArguments(b)) {
    if (!(isArguments(a) && isArguments(b))) {
      return false;
    }

    var slice = Array.prototype.slice;
    return deepEquals(slice.call(a), slice.call(b), ca, cb);
  } else {
    if (a.constructor !== b.constructor) {
      return false;
    }

    var ka = Object.keys(a);
    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there

    if (ka.length === 0 && kb.length === 0) {
      return true;
    }

    if (ka.length !== kb.length) {
      return false;
    }

    var cal = ca.length;

    while (cal--) {
      if (ca[cal] === a) {
        return cb[cal] === b;
      }
    }

    ca.push(a);
    cb.push(b);
    ka.sort();
    kb.sort();

    for (var j = ka.length - 1; j >= 0; j--) {
      if (ka[j] !== kb[j]) {
        return false;
      }
    }

    var _key;

    for (var k = ka.length - 1; k >= 0; k--) {
      _key = ka[k];

      if (!deepEquals(a[_key], b[_key], ca, cb)) {
        return false;
      }
    }

    ca.pop();
    cb.pop();
    return true;
  }
}
export function shouldRender(comp, nextProps, nextState) {
  var props = comp.props,
      state = comp.state;
  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);
}
export function toIdSchema(schema, id, rootSchema) {
  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "root";
  var idSeparator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "_";
  var idSchema = {
    $id: id || idPrefix
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toIdSchema(_schema, id, rootSchema, formData, idPrefix, idSeparator);
  }

  if ("items" in schema && !schema.items.$ref) {
    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix, idSeparator);
  }

  if (schema.type !== "object") {
    return idSchema;
  }

  for (var name in schema.properties || {}) {
    var field = schema.properties[name];
    var fieldId = idSchema.$id + idSeparator + name;
    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an
    // array item has just been added, but not populated with data yet
    (formData || {})[name], idPrefix, idSeparator);
  }

  return idSchema;
}
export function toPathSchema(schema) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;
  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var pathSchema = {
    $name: name.replace(/^\./, "")
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toPathSchema(_schema, name, rootSchema, formData);
  }

  if (schema.hasOwnProperty("additionalProperties")) {
    pathSchema.__rjsf_additionalProperties = true;
  }

  if (schema.hasOwnProperty("items") && Array.isArray(formData)) {
    formData.forEach(function (element, i) {
      pathSchema[i] = toPathSchema(schema.items, "".concat(name, ".").concat(i), rootSchema, element);
    });
  } else if (schema.hasOwnProperty("properties")) {
    for (var property in schema.properties) {
      pathSchema[property] = toPathSchema(schema.properties[property], "".concat(name, ".").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an
      // array item has just been added, but not populated with data yet
      (formData || {})[property]);
    }
  }

  return pathSchema;
}
export function parseDateString(dateString) {
  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (!dateString) {
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: includeTime ? -1 : 0,
      minute: includeTime ? -1 : 0,
      second: includeTime ? -1 : 0
    };
  }

  var date = new Date(dateString);

  if (Number.isNaN(date.getTime())) {
    throw new Error("Unable to parse date " + dateString);
  }

  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    // oh you, javascript.
    day: date.getUTCDate(),
    hour: includeTime ? date.getUTCHours() : 0,
    minute: includeTime ? date.getUTCMinutes() : 0,
    second: includeTime ? date.getUTCSeconds() : 0
  };
}
export function toDateString(_ref2) {
  var year = _ref2.year,
      month = _ref2.month,
      day = _ref2.day,
      _ref2$hour = _ref2.hour,
      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,
      _ref2$minute = _ref2.minute,
      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,
      _ref2$second = _ref2.second,
      second = _ref2$second === void 0 ? 0 : _ref2$second;
  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);
  var datetime = new Date(utcTime).toJSON();
  return time ? datetime : datetime.slice(0, 10);
}
export function utcToLocal(jsonDate) {
  if (!jsonDate) {
    return "";
  } // required format of `"yyyy-MM-ddThh:mm" followed by optional ":ss" or ":ss.SSS"
  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)
  // > should be a _valid local date and time string_ (not GMT)
  // Note - date constructor passed local ISO-8601 does not correctly
  // change time to UTC in node pre-8


  var date = new Date(jsonDate);
  var yyyy = pad(date.getFullYear(), 4);
  var MM = pad(date.getMonth() + 1, 2);
  var dd = pad(date.getDate(), 2);
  var hh = pad(date.getHours(), 2);
  var mm = pad(date.getMinutes(), 2);
  var ss = pad(date.getSeconds(), 2);
  var SSS = pad(date.getMilliseconds(), 3);
  return "".concat(yyyy, "-").concat(MM, "-").concat(dd, "T").concat(hh, ":").concat(mm, ":").concat(ss, ".").concat(SSS);
}
export function localToUTC(dateString) {
  if (dateString) {
    return new Date(dateString).toJSON();
  }
}
export function pad(num, size) {
  var s = String(num);

  while (s.length < size) {
    s = "0" + s;
  }

  return s;
}
export function dataURItoBlob(dataURI) {
  // Split metadata from data
  var splitted = dataURI.split(","); // Split params

  var params = splitted[0].split(";"); // Get mime-type from params

  var type = params[0].replace("data:", ""); // Filter the name property from params

  var properties = params.filter(function (param) {
    return param.split("=")[0] === "name";
  }); // Look for the name and use unknown if no name property.

  var name;

  if (properties.length !== 1) {
    name = "unknown";
  } else {
    // Because we filtered out the other property,
    // we only have the name case here.
    name = properties[0].split("=")[1];
  } // Built the Uint8Array Blob parameter from the base64 string.


  var binary = atob(splitted[1]);
  var array = [];

  for (var _i = 0; _i < binary.length; _i++) {
    array.push(binary.charCodeAt(_i));
  } // Create the blob object


  var blob = new window.Blob([new Uint8Array(array)], {
    type: type
  });
  return {
    blob: blob,
    name: name
  };
}
export function rangeSpec(schema) {
  var spec = {};

  if (schema.multipleOf) {
    spec.step = schema.multipleOf;
  }

  if (schema.minimum || schema.minimum === 0) {
    spec.min = schema.minimum;
  }

  if (schema.maximum || schema.maximum === 0) {
    spec.max = schema.maximum;
  }

  return spec;
}
export function getMatchingOption(formData, options, rootSchema) {
  // For performance, skip validating subschemas if formData is undefined. We just
  // want to get the first option in that case.
  if (formData === undefined) {
    return 0;
  }

  for (var _i2 = 0; _i2 < options.length; _i2++) {
    var option = options[_i2]; // If the schema describes an object then we need to add slightly more
    // strict matching to the schema, because unless the schema uses the
    // "requires" keyword, an object will match the schema as long as it
    // doesn't have matching keys with a conflicting type. To do this we use an
    // "anyOf" with an array of requires. This augmentation expresses that the
    // schema should match if any of the keys in the schema are present on the
    // object and pass validation.

    if (option.properties) {
      // Create an "anyOf" schema that requires at least one of the keys in the
      // "properties" object
      var requiresAnyOf = {
        anyOf: Object.keys(option.properties).map(function (key) {
          return {
            required: [key]
          };
        })
      };
      var augmentedSchema = void 0; // If the "anyOf" keyword already exists, wrap the augmentation in an "allOf"

      if (option.anyOf) {
        // Create a shallow clone of the option
        var shallowClone = _extends({}, option);

        if (!shallowClone.allOf) {
          shallowClone.allOf = [];
        } else {
          // If "allOf" already exists, shallow clone the array
          shallowClone.allOf = shallowClone.allOf.slice();
        }

        shallowClone.allOf.push(requiresAnyOf);
        augmentedSchema = shallowClone;
      } else {
        augmentedSchema = Object.assign({}, option, requiresAnyOf);
      } // Remove the "required" field as it's likely that not all fields have
      // been filled in yet, which will mean that the schema is not valid


      delete augmentedSchema.required;

      if (isValid(augmentedSchema, formData, rootSchema)) {
        return _i2;
      }
    } else if (isValid(option, formData, rootSchema)) {
      return _i2;
    }
  }

  return 0;
} // Check to see if a schema specifies that a value must be true

export function schemaRequiresTrueValue(schema) {
  // Check if const is a truthy value
  if (schema["const"]) {
    return true;
  } // Check if an enum has a single value of true


  if (schema["enum"] && schema["enum"].length === 1 && schema["enum"][0] === true) {
    return true;
  } // If anyOf has a single value, evaluate the subschema


  if (schema.anyOf && schema.anyOf.length === 1) {
    return schemaRequiresTrueValue(schema.anyOf[0]);
  } // If oneOf has a single value, evaluate the subschema


  if (schema.oneOf && schema.oneOf.length === 1) {
    return schemaRequiresTrueValue(schema.oneOf[0]);
  } // Evaluate each subschema in allOf, to see if one of them requires a true
  // value


  if (schema.allOf) {
    return schema.allOf.some(schemaRequiresTrueValue);
  }

  return false;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0SXMiLCJtZXJnZUFsbE9mIiwiZmlsbCIsInVuaW9uIiwianNvbnBvaW50ZXIiLCJ2YWxpZGF0ZUZvcm1EYXRhIiwiaXNWYWxpZCIsIkFERElUSU9OQUxfUFJPUEVSVFlfRkxBRyIsIndpZGdldE1hcCIsImNoZWNrYm94IiwicmFkaW8iLCJzZWxlY3QiLCJoaWRkZW4iLCJzdHJpbmciLCJ0ZXh0IiwicGFzc3dvcmQiLCJlbWFpbCIsImhvc3RuYW1lIiwiaXB2NCIsImlwdjYiLCJ1cmkiLCJ0ZXh0YXJlYSIsImRhdGUiLCJkYXRldGltZSIsImNvbG9yIiwiZmlsZSIsIm51bWJlciIsInVwZG93biIsInJhbmdlIiwiaW50ZWdlciIsImFycmF5IiwiY2hlY2tib3hlcyIsImZpbGVzIiwiY2FuRXhwYW5kIiwic2NoZW1hIiwidWlTY2hlbWEiLCJmb3JtRGF0YSIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiZ2V0VWlPcHRpb25zIiwiZXhwYW5kYWJsZSIsIm1heFByb3BlcnRpZXMiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZ2V0U2NoZW1hVHlwZSIsInR5cGUiLCJndWVzc1R5cGUiLCJwcm9wZXJ0aWVzIiwiQXJyYXkiLCJpbmNsdWRlcyIsImZpbmQiLCJnZXRXaWRnZXQiLCJ3aWRnZXQiLCJyZWdpc3RlcmVkV2lkZ2V0cyIsIm1lcmdlT3B0aW9ucyIsIldpZGdldCIsIk1lcmdlZFdpZGdldCIsImRlZmF1bHRPcHRpb25zIiwiZGVmYXVsdFByb3BzIiwib3B0aW9ucyIsInByb3BzIiwiaXNGb3J3YXJkUmVmIiwiY3JlYXRlRWxlbWVudCIsImlzTWVtbyIsIkVycm9yIiwiaGFzT3duUHJvcGVydHkiLCJyZWdpc3RlcmVkV2lkZ2V0IiwiaGFzV2lkZ2V0IiwiZSIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiY29tcHV0ZURlZmF1bHRzIiwiX3NjaGVtYSIsInBhcmVudERlZmF1bHRzIiwicm9vdFNjaGVtYSIsInJhd0Zvcm1EYXRhIiwiaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyIsImlzT2JqZWN0IiwiZGVmYXVsdHMiLCJtZXJnZU9iamVjdHMiLCJyZWZTY2hlbWEiLCJmaW5kU2NoZW1hRGVmaW5pdGlvbiIsIiRyZWYiLCJyZXNvbHZlZFNjaGVtYSIsInJlc29sdmVEZXBlbmRlbmNpZXMiLCJpc0ZpeGVkSXRlbXMiLCJpdGVtcyIsIm1hcCIsIml0ZW1TY2hlbWEiLCJpZHgiLCJpc0FycmF5Iiwib25lT2YiLCJnZXRNYXRjaGluZ09wdGlvbiIsImFueU9mIiwicmVkdWNlIiwiYWNjIiwia2V5IiwiY29tcHV0ZWREZWZhdWx0IiwiaXRlbSIsImFkZGl0aW9uYWxJdGVtcyIsIm1pbkl0ZW1zIiwiaXNNdWx0aVNlbGVjdCIsImRlZmF1bHRzTGVuZ3RoIiwiZGVmYXVsdEVudHJpZXMiLCJmaWxsZXJTY2hlbWEiLCJmaWxsZXJFbnRyaWVzIiwiY29uY2F0IiwiZ2V0RGVmYXVsdEZvcm1TdGF0ZSIsInJldHJpZXZlU2NoZW1hIiwibWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YSIsInZhbHVlIiwiYXNzaWduIiwiZmlsdGVyIiwiaW5kZXhPZiIsImNvbnNvbGUiLCJ3YXJuIiwiY29tcG9uZW50Iiwic3Vic3RyaW5nIiwiZ2V0U3VibWl0QnV0dG9uT3B0aW9ucyIsInVpT3B0aW9ucyIsImRpc2FibGVkIiwic3VibWl0VGV4dCIsIm5vcmVuZGVyIiwiZ2V0RGlzcGxheUxhYmVsIiwibGFiZWwiLCJkaXNwbGF5TGFiZWwiLCJzY2hlbWFUeXBlIiwiaXNGaWxlc0FycmF5IiwiaXNDdXN0b21XaWRnZXQiLCJ0aGluZyIsIkZpbGUiLCJvYmoxIiwib2JqMiIsImNvbmNhdEFycmF5cyIsImxlZnQiLCJyaWdodCIsImFzTnVtYmVyIiwidGVzdCIsIm4iLCJOdW1iZXIiLCJ2YWxpZCIsImlzTmFOIiwib3JkZXJQcm9wZXJ0aWVzIiwib3JkZXIiLCJhcnJheVRvSGFzaCIsImFyciIsInByZXYiLCJjdXJyIiwiZXJyb3JQcm9wTGlzdCIsImpvaW4iLCJwcm9wZXJ0eUhhc2giLCJvcmRlckZpbHRlcmVkIiwicHJvcCIsIm9yZGVySGFzaCIsInJlc3QiLCJyZXN0SW5kZXgiLCJsYXN0SW5kZXhPZiIsImNvbXBsZXRlIiwic3BsaWNlIiwiaXNDb25zdGFudCIsInRvQ29uc3RhbnQiLCJpc1NlbGVjdCIsImFsdFNjaGVtYXMiLCJldmVyeSIsInVuaXF1ZUl0ZW1zIiwiaXRlbXNTY2hlbWEiLCJmb3JtYXQiLCJhbGxvd0FkZGl0aW9uYWxJdGVtcyIsIm9wdGlvbnNMaXN0IiwiaSIsImVudW1OYW1lcyIsIlN0cmluZyIsInRpdGxlIiwib3JpZ1JlZiIsImRlY29kZVVSSUNvbXBvbmVudCIsImN1cnJlbnQiLCJnZXQiLCJzdHViRXhpc3RpbmdBZGRpdGlvbmFsUHJvcGVydGllcyIsImZvckVhY2giLCJyZXNvbHZlQ29uZGl0aW9uIiwiZXhwcmVzc2lvbiIsInRoZW4iLCJvdGhlcndpc2UiLCJyZXNvbHZlZFNjaGVtYUxlc3NDb25kaXRpb25hbCIsImNvbmRpdGlvbmFsU2NoZW1hIiwibWVyZ2VTY2hlbWFzIiwicmVzb2x2ZVNjaGVtYSIsInJlc29sdmVSZWZlcmVuY2UiLCJhbGxPZiIsImFsbE9mU3Vic2NoZW1hIiwiJHJlZlNjaGVtYSIsImxvY2FsU2NoZW1hIiwiZW50cmllcyIsInByb3BOYW1lIiwicHJvcFNjaGVtYSIsInJhd1Byb3BEYXRhIiwicHJvcERhdGEiLCJyZXNvbHZlZFByb3BTY2hlbWEiLCJyZXNvbHZlZFNjaGVtYVdpdGhvdXRBbGxPZiIsImhhc0FkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiZGVwZW5kZW5jaWVzIiwicHJvY2Vzc0RlcGVuZGVuY2llcyIsImRlcGVuZGVuY3lLZXkiLCJkZXBlbmRlbmN5VmFsdWUiLCJyZW1haW5pbmdEZXBlbmRlbmNpZXMiLCJ3aXRoRGVwZW5kZW50UHJvcGVydGllcyIsIndpdGhEZXBlbmRlbnRTY2hlbWEiLCJhZGRpdGlvbmFsbHlSZXF1aXJlZCIsInJlcXVpcmVkIiwiZnJvbSIsIlNldCIsImRlcGVuZGVudFNjaGVtYSIsInJlc29sdmVkT25lT2YiLCJzdWJzY2hlbWEiLCJ3aXRoRXhhY3RseU9uZVN1YnNjaGVtYSIsInZhbGlkU3Vic2NoZW1hcyIsImNvbmRpdGlvblByb3BlcnR5U2NoZW1hIiwiY29uZGl0aW9uU2NoZW1hIiwiZXJyb3JzIiwiZGVwZW5kZW50U3Vic2NoZW1hIiwiaXNBcmd1bWVudHMiLCJvYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJkZWVwRXF1YWxzIiwiYSIsImIiLCJjYSIsImNiIiwiRGF0ZSIsImdldFRpbWUiLCJSZWdFeHAiLCJzb3VyY2UiLCJnbG9iYWwiLCJtdWx0aWxpbmUiLCJsYXN0SW5kZXgiLCJpZ25vcmVDYXNlIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsImthIiwia2IiLCJjYWwiLCJwdXNoIiwic29ydCIsImoiLCJrIiwicG9wIiwic2hvdWxkUmVuZGVyIiwiY29tcCIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsInN0YXRlIiwidG9JZFNjaGVtYSIsImlkIiwiaWRQcmVmaXgiLCJpZFNlcGFyYXRvciIsImlkU2NoZW1hIiwiJGlkIiwibmFtZSIsImZpZWxkIiwiZmllbGRJZCIsInRvUGF0aFNjaGVtYSIsInBhdGhTY2hlbWEiLCIkbmFtZSIsInJlcGxhY2UiLCJfX3Jqc2ZfYWRkaXRpb25hbFByb3BlcnRpZXMiLCJlbGVtZW50IiwicHJvcGVydHkiLCJwYXJzZURhdGVTdHJpbmciLCJkYXRlU3RyaW5nIiwiaW5jbHVkZVRpbWUiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwidG9EYXRlU3RyaW5nIiwidGltZSIsInV0Y1RpbWUiLCJVVEMiLCJ0b0pTT04iLCJ1dGNUb0xvY2FsIiwianNvbkRhdGUiLCJ5eXl5IiwicGFkIiwiZ2V0RnVsbFllYXIiLCJNTSIsImdldE1vbnRoIiwiZGQiLCJnZXREYXRlIiwiaGgiLCJnZXRIb3VycyIsIm1tIiwiZ2V0TWludXRlcyIsInNzIiwiZ2V0U2Vjb25kcyIsIlNTUyIsImdldE1pbGxpc2Vjb25kcyIsImxvY2FsVG9VVEMiLCJudW0iLCJzaXplIiwicyIsImRhdGFVUkl0b0Jsb2IiLCJkYXRhVVJJIiwic3BsaXR0ZWQiLCJzcGxpdCIsInBhcmFtcyIsInBhcmFtIiwiYmluYXJ5IiwiYXRvYiIsImNoYXJDb2RlQXQiLCJibG9iIiwid2luZG93IiwiQmxvYiIsIlVpbnQ4QXJyYXkiLCJyYW5nZVNwZWMiLCJzcGVjIiwibXVsdGlwbGVPZiIsInN0ZXAiLCJtaW5pbXVtIiwibWluIiwibWF4aW11bSIsIm1heCIsIm9wdGlvbiIsInJlcXVpcmVzQW55T2YiLCJhdWdtZW50ZWRTY2hlbWEiLCJzaGFsbG93Q2xvbmUiLCJzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZSIsInNvbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsTUFBa0IsT0FBbEI7QUFDQSxPQUFPLEtBQUtDLE9BQVosTUFBeUIsVUFBekI7QUFDQSxPQUFPQyxVQUFQLE1BQXVCLHlCQUF2QjtBQUNBLE9BQU9DLElBQVAsTUFBaUIsa0NBQWpCO0FBQ0EsT0FBT0MsS0FBUCxNQUFrQixjQUFsQjtBQUNBLE9BQU9DLFdBQVAsTUFBd0IsYUFBeEI7QUFDQSxPQUFPQyxnQkFBUCxJQUEyQkMsT0FBM0IsUUFBMEMsWUFBMUM7QUFFQSxPQUFPLElBQU1DLHdCQUF3QixHQUFHLHVCQUFqQztBQUVQLElBQU1DLFNBQVMsR0FBRztBQUNoQixhQUFTO0FBQ1BDLElBQUFBLFFBQVEsRUFBRSxnQkFESDtBQUVQQyxJQUFBQSxLQUFLLEVBQUUsYUFGQTtBQUdQQyxJQUFBQSxNQUFNLEVBQUUsY0FIRDtBQUlQQyxJQUFBQSxNQUFNLEVBQUU7QUFKRCxHQURPO0FBT2hC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LFNBQU8sQ0FBUDtBQUNELEMsQ0FFRDs7QUFDQSxPQUFPLFNBQVNzSyx1QkFBVCxDQUFpQzlTLE1BQWpDLEVBQXlDO0FBQzlDO0FBQ0EsTUFBSUEsTUFBTSxTQUFWLEVBQWtCO0FBQ2hCLFdBQU8sSUFBUDtBQUNELEdBSjZDLENBTTlDOzs7QUFDQSxNQUFJQSxNQUFNLFFBQU4sSUFBZUEsTUFBTSxRQUFOLENBQVlVLE1BQVosS0FBdUIsQ0FBdEMsSUFBMkNWLE1BQU0sUUFBTixDQUFZLENBQVosTUFBbUIsSUFBbEUsRUFBd0U7QUFDdEUsV0FBTyxJQUFQO0FBQ0QsR0FUNkMsQ0FXOUM7OztBQUNBLE1BQUlBLE1BQU0sQ0FBQzRELEtBQVAsSUFBZ0I1RCxNQUFNLENBQUM0RCxLQUFQLENBQWFsRCxNQUFiLEtBQXdCLENBQTVDLEVBQStDO0FBQzdDLFdBQU9vUyx1QkFBdUIsQ0FBQzlTLE1BQU0sQ0FBQzRELEtBQVAsQ0FBYSxDQUFiLENBQUQsQ0FBOUI7QUFDRCxHQWQ2QyxDQWdCOUM7OztBQUNBLE1BQUk1RCxNQUFNLENBQUMwRCxLQUFQLElBQWdCMUQsTUFBTSxDQUFDMEQsS0FBUCxDQUFhaEQsTUFBYixLQUF3QixDQUE1QyxFQUErQztBQUM3QyxXQUFPb1MsdUJBQXVCLENBQUM5UyxNQUFNLENBQUMwRCxLQUFQLENBQWEsQ0FBYixDQUFELENBQTlCO0FBQ0QsR0FuQjZDLENBcUI5QztBQUNBOzs7QUFDQSxNQUFJMUQsTUFBTSxDQUFDMkosS0FBWCxFQUFrQjtBQUNoQixXQUFPM0osTUFBTSxDQUFDMkosS0FBUCxDQUFhb0osSUFBYixDQUFrQkQsdUJBQWxCLENBQVA7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0SXMgZnJvbSBcInJlYWN0LWlzXCI7XG5pbXBvcnQgbWVyZ2VBbGxPZiBmcm9tIFwianNvbi1zY2hlbWEtbWVyZ2UtYWxsb2ZcIjtcbmltcG9ydCBmaWxsIGZyb20gXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvYXJyYXkvZmlsbFwiO1xuaW1wb3J0IHVuaW9uIGZyb20gXCJsb2Rhc2gvdW5pb25cIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbnBvaW50ZXJcIjtcbmltcG9ydCB2YWxpZGF0ZUZvcm1EYXRhLCB7IGlzVmFsaWQgfSBmcm9tIFwiLi92YWxpZGF0ZVwiO1xuXG5leHBvcnQgY29uc3QgQURESVRJT05BTF9QUk9QRVJUWV9GTEFHID0gXCJfX2FkZGl0aW9uYWxfcHJvcGVydHlcIjtcblxuY29uc3Qgd2lkZ2V0TWFwID0ge1xuICBib29sZWFuOiB7XG4gICAgY2hlY2tib3g6IFwiQ2hlY2tib3hXaWRnZXRcIixcbiAgICByYWRpbzogXCJSYWRpb1dpZGdldFwiLFxuICAgIHNlbGVjdDogXCJTZWxlY3RXaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gIH0sXG4gIHN0cmluZzoge1xuICAgIHRleHQ6IFwiVGV4dFdpZGdldFwiLFxuICAgIHBhc3N3b3JkOiBcIlBhc3N3b3JkV2lkZ2V0XCIsXG4gICAgZW1haWw6IFwiRW1haWxXaWRnZXRcIixcbiAgICBob3N0bmFtZTogXCJUZXh0V2lkZ2V0XCIsXG4gICAgaXB2NDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgaXB2NjogXCJUZXh0V2lkZ2V0XCIsXG4gICAgdXJpOiBcIlVSTFdpZGdldFwiLFxuICAgIFwiZGF0YS11cmxcIjogXCJGaWxlV2lkZ2V0XCIsXG4gICAgcmFkaW86IFwiUmFkaW9XaWRnZXRcIixcbiAgICBzZWxlY3Q6IFwiU2VsZWN0V2lkZ2V0XCIsXG4gICAgdGV4dGFyZWE6IFwiVGV4dGFyZWFXaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gICAgZGF0ZTogXCJEYXRlV2lkZ2V0XCIsXG4gICAgZGF0ZXRpbWU6IFwiRGF0ZVRpbWVXaWRnZXRcIixcbiAgICBcImRhdGUtdGltZVwiOiBcIkRhdGVUaW1lV2lkZ2V0XCIsXG4gICAgXCJhbHQtZGF0ZVwiOiBcIkFsdERhdGVXaWRnZXRcIixcbiAgICBcImFsdC1kYXRldGltZVwiOiBcIkFsdERhdGVUaW1lV2lkZ2V0XCIsXG4gICAgY29sb3I6IFwiQ29sb3JXaWRnZXRcIixcbiAgICBmaWxlOiBcIkZpbGVXaWRnZXRcIixcbiAgfSxcbiAgbnVtYmVyOiB7XG4gICAgdGV4dDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgc2VsZWN0OiBcIlNlbGVjdFdpZGdldFwiLFxuICAgIHVwZG93bjogXCJVcERvd25XaWRnZXRcIixcbiAgICByYW5nZTogXCJSYW5nZVdpZGdldFwiLFxuICAgIHJhZGlvOiBcIlJhZGlvV2lkZ2V0XCIsXG4gICAgaGlkZGVuOiBcIkhpZGRlbldpZGdldFwiLFxuICB9LFxuICBpbnRlZ2VyOiB7XG4gICAgdGV4dDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgc2VsZWN0OiBcIlNlbGVjdFdpZGdldFwiLFxuICAgIHVwZG93bjogXCJVcERvd25XaWRnZXRcIixcbiAgICByYW5nZTogXCJSYW5nZVdpZGdldFwiLFxuICAgIHJhZGlvOiBcIlJhZGlvV2lkZ2V0XCIsXG4gICAgaGlkZGVuOiBcIkhpZGRlbldpZGdldFwiLFxuICB9LFxuICBhcnJheToge1xuICAgIHNlbGVjdDogXCJTZWxlY3RXaWRnZXRcIixcbiAgICBjaGVja2JveGVzOiBcIkNoZWNrYm94ZXNXaWRnZXRcIixcbiAgICBmaWxlczogXCJGaWxlV2lkZ2V0XCIsXG4gICAgaGlkZGVuOiBcIkhpZGRlbldpZGdldFwiLFxuICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbkV4cGFuZChzY2hlbWEsIHVpU2NoZW1hLCBmb3JtRGF0YSkge1xuICBpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7IGV4cGFuZGFibGUgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSk7XG4gIGlmIChleHBhbmRhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBleHBhbmRhYmxlO1xuICB9XG4gIC8vIGlmIHVpOm9wdGlvbnMuZXhwYW5kYWJsZSB3YXMgbm90IGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLCB3ZSBjYW4gYWRkXG4gIC8vIGFub3RoZXIgcHJvcGVydHkgaWYgd2UgaGF2ZSBub3QgZXhjZWVkZWQgbWF4UHJvcGVydGllcyB5ZXRcbiAgaWYgKHNjaGVtYS5tYXhQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybURhdGEpLmxlbmd0aCA8IHNjaGVtYS5tYXhQcm9wZXJ0aWVzO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiBHZXRzIHRoZSB0eXBlIG9mIGEgZ2l2ZW4gc2NoZW1hLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGUoc2NoZW1hKSB7XG4gIGxldCB7IHR5cGUgfSA9IHNjaGVtYTtcblxuICBpZiAoIXR5cGUgJiYgc2NoZW1hLmNvbnN0KSB7XG4gICAgcmV0dXJuIGd1ZXNzVHlwZShzY2hlbWEuY29uc3QpO1xuICB9XG5cbiAgaWYgKCF0eXBlICYmIHNjaGVtYS5lbnVtKSB7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cblxuICBpZiAoIXR5cGUgJiYgKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykpIHtcbiAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgfVxuXG4gIGlmICh0eXBlIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZS5sZW5ndGggPT09IDIgJiYgdHlwZS5pbmNsdWRlcyhcIm51bGxcIikpIHtcbiAgICByZXR1cm4gdHlwZS5maW5kKHR5cGUgPT4gdHlwZSAhPT0gXCJudWxsXCIpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHJlZ2lzdGVyZWRXaWRnZXRzID0ge30pIHtcbiAgY29uc3QgdHlwZSA9IGdldFNjaGVtYVR5cGUoc2NoZW1hKTtcblxuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMoV2lkZ2V0KSB7XG4gICAgLy8gY2FjaGUgcmV0dXJuIHZhbHVlIGFzIHByb3BlcnR5IG9mIHdpZGdldCBmb3IgcHJvcGVyIHJlYWN0IHJlY29uY2lsaWF0aW9uXG4gICAgaWYgKCFXaWRnZXQuTWVyZ2VkV2lkZ2V0KSB7XG4gICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9XG4gICAgICAgIChXaWRnZXQuZGVmYXVsdFByb3BzICYmIFdpZGdldC5kZWZhdWx0UHJvcHMub3B0aW9ucykgfHwge307XG4gICAgICBXaWRnZXQuTWVyZ2VkV2lkZ2V0ID0gKHsgb3B0aW9ucyA9IHt9LCAuLi5wcm9wcyB9KSA9PiAoXG4gICAgICAgIDxXaWRnZXQgb3B0aW9ucz17eyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9fSB7Li4ucHJvcHN9IC8+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gV2lkZ2V0Lk1lcmdlZFdpZGdldDtcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2Ygd2lkZ2V0ID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICBSZWFjdElzLmlzRm9yd2FyZFJlZihSZWFjdC5jcmVhdGVFbGVtZW50KHdpZGdldCkpIHx8XG4gICAgUmVhY3RJcy5pc01lbW8od2lkZ2V0KVxuICApIHtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKHdpZGdldCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpZGdldCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgd2lkZ2V0IGRlZmluaXRpb246ICR7dHlwZW9mIHdpZGdldH1gKTtcbiAgfVxuXG4gIGlmIChyZWdpc3RlcmVkV2lkZ2V0cy5oYXNPd25Qcm9wZXJ0eSh3aWRnZXQpKSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZFdpZGdldCA9IHJlZ2lzdGVyZWRXaWRnZXRzW3dpZGdldF07XG4gICAgcmV0dXJuIGdldFdpZGdldChzY2hlbWEsIHJlZ2lzdGVyZWRXaWRnZXQsIHJlZ2lzdGVyZWRXaWRnZXRzKTtcbiAgfVxuXG4gIGlmICghd2lkZ2V0TWFwLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyB3aWRnZXQgZm9yIHR5cGUgXCIke3R5cGV9XCJgKTtcbiAgfVxuXG4gIGlmICh3aWRnZXRNYXBbdHlwZV0uaGFzT3duUHJvcGVydHkod2lkZ2V0KSkge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRXaWRnZXQgPSByZWdpc3RlcmVkV2lkZ2V0c1t3aWRnZXRNYXBbdHlwZV1bd2lkZ2V0XV07XG4gICAgcmV0dXJuIGdldFdpZGdldChzY2hlbWEsIHJlZ2lzdGVyZWRXaWRnZXQsIHJlZ2lzdGVyZWRXaWRnZXRzKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihgTm8gd2lkZ2V0IFwiJHt3aWRnZXR9XCIgZm9yIHR5cGUgXCIke3R5cGV9XCJgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1dpZGdldChzY2hlbWEsIHdpZGdldCwgcmVnaXN0ZXJlZFdpZGdldHMgPSB7fSkge1xuICB0cnkge1xuICAgIGdldFdpZGdldChzY2hlbWEsIHdpZGdldCwgcmVnaXN0ZXJlZFdpZGdldHMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKFxuICAgICAgZS5tZXNzYWdlICYmXG4gICAgICAoZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJObyB3aWRnZXRcIikgfHxcbiAgICAgICAgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJVbnN1cHBvcnRlZCB3aWRnZXRcIikpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlZmF1bHRzKFxuICBfc2NoZW1hLFxuICBwYXJlbnREZWZhdWx0cyxcbiAgcm9vdFNjaGVtYSxcbiAgcmF3Rm9ybURhdGEgPSB7fSxcbiAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyA9IGZhbHNlXG4pIHtcbiAgbGV0IHNjaGVtYSA9IGlzT2JqZWN0KF9zY2hlbWEpID8gX3NjaGVtYSA6IHt9O1xuICBjb25zdCBmb3JtRGF0YSA9IGlzT2JqZWN0KHJhd0Zvcm1EYXRhKSA/IHJhd0Zvcm1EYXRhIDoge307XG4gIC8vIENvbXB1dGUgdGhlIGRlZmF1bHRzIHJlY3Vyc2l2ZWx5OiBnaXZlIGhpZ2hlc3QgcHJpb3JpdHkgdG8gZGVlcGVzdCBub2Rlcy5cbiAgbGV0IGRlZmF1bHRzID0gcGFyZW50RGVmYXVsdHM7XG4gIGlmIChpc09iamVjdChkZWZhdWx0cykgJiYgaXNPYmplY3Qoc2NoZW1hLmRlZmF1bHQpKSB7XG4gICAgLy8gRm9yIG9iamVjdCBkZWZhdWx0cywgb25seSBvdmVycmlkZSBwYXJlbnQgZGVmYXVsdHMgdGhhdCBhcmUgZGVmaW5lZCBpblxuICAgIC8vIHNjaGVtYS5kZWZhdWx0LlxuICAgIGRlZmF1bHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRzLCBzY2hlbWEuZGVmYXVsdCk7XG4gIH0gZWxzZSBpZiAoXCJkZWZhdWx0XCIgaW4gc2NoZW1hKSB7XG4gICAgLy8gVXNlIHNjaGVtYSBkZWZhdWx0cyBmb3IgdGhpcyBub2RlLlxuICAgIGRlZmF1bHRzID0gc2NoZW1hLmRlZmF1bHQ7XG4gIH0gZWxzZSBpZiAoXCIkcmVmXCIgaW4gc2NoZW1hKSB7XG4gICAgLy8gVXNlIHJlZmVyZW5jZWQgc2NoZW1hIGRlZmF1bHRzIGZvciB0aGlzIG5vZGUuXG4gICAgY29uc3QgcmVmU2NoZW1hID0gZmluZFNjaGVtYURlZmluaXRpb24oc2NoZW1hLiRyZWYsIHJvb3RTY2hlbWEpO1xuICAgIHJldHVybiBjb21wdXRlRGVmYXVsdHMoXG4gICAgICByZWZTY2hlbWEsXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNcbiAgICApO1xuICB9IGVsc2UgaWYgKFwiZGVwZW5kZW5jaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlRGVwZW5kZW5jaWVzKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgIHJldHVybiBjb21wdXRlRGVmYXVsdHMoXG4gICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgcm9vdFNjaGVtYSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc1xuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNGaXhlZEl0ZW1zKHNjaGVtYSkpIHtcbiAgICBkZWZhdWx0cyA9IHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW1TY2hlbWEsIGlkeCkgPT5cbiAgICAgIGNvbXB1dGVEZWZhdWx0cyhcbiAgICAgICAgaXRlbVNjaGVtYSxcbiAgICAgICAgQXJyYXkuaXNBcnJheShwYXJlbnREZWZhdWx0cykgPyBwYXJlbnREZWZhdWx0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc1xuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoXCJvbmVPZlwiIGluIHNjaGVtYSkge1xuICAgIHNjaGVtYSA9XG4gICAgICBzY2hlbWEub25lT2ZbZ2V0TWF0Y2hpbmdPcHRpb24odW5kZWZpbmVkLCBzY2hlbWEub25lT2YsIHJvb3RTY2hlbWEpXTtcbiAgfSBlbHNlIGlmIChcImFueU9mXCIgaW4gc2NoZW1hKSB7XG4gICAgc2NoZW1hID1cbiAgICAgIHNjaGVtYS5hbnlPZltnZXRNYXRjaGluZ09wdGlvbih1bmRlZmluZWQsIHNjaGVtYS5hbnlPZiwgcm9vdFNjaGVtYSldO1xuICB9XG5cbiAgLy8gTm90IGRlZmF1bHRzIGRlZmluZWQgZm9yIHRoaXMgbm9kZSwgZmFsbGJhY2sgdG8gZ2VuZXJpYyB0eXBlZCBvbmVzLlxuICBpZiAodHlwZW9mIGRlZmF1bHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGVmYXVsdHMgPSBzY2hlbWEuZGVmYXVsdDtcbiAgfVxuXG4gIHN3aXRjaCAoZ2V0U2NoZW1hVHlwZShzY2hlbWEpKSB7XG4gICAgLy8gV2UgbmVlZCB0byByZWN1ciBmb3Igb2JqZWN0IHNjaGVtYSBpbm5lciBkZWZhdWx0IHZhbHVlcy5cbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMgfHwge30pLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdHMgZm9yIHRoaXMgbm9kZSwgd2l0aCB0aGUgcGFyZW50IGRlZmF1bHRzIHdlIG1pZ2h0XG4gICAgICAgIC8vIGhhdmUgZnJvbSBhIHByZXZpb3VzIHJ1bjogZGVmYXVsdHNba2V5XS5cbiAgICAgICAgbGV0IGNvbXB1dGVkRGVmYXVsdCA9IGNvbXB1dGVEZWZhdWx0cyhcbiAgICAgICAgICBzY2hlbWEucHJvcGVydGllc1trZXldLFxuICAgICAgICAgIChkZWZhdWx0cyB8fCB7fSlba2V5XSxcbiAgICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAgIChmb3JtRGF0YSB8fCB7fSlba2V5XSxcbiAgICAgICAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbmNsdWRlVW5kZWZpbmVkVmFsdWVzIHx8IGNvbXB1dGVkRGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWNjW2tleV0gPSBjb21wdXRlZERlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcblxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgLy8gSW5qZWN0IGRlZmF1bHRzIGludG8gZXhpc3RpbmcgYXJyYXkgZGVmYXVsdHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xuICAgICAgICBkZWZhdWx0cyA9IGRlZmF1bHRzLm1hcCgoaXRlbSwgaWR4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0cyhcbiAgICAgICAgICAgIHNjaGVtYS5pdGVtc1tpZHhdIHx8IHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgfHwge30sXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgcm9vdFNjaGVtYVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWVwbHkgaW5qZWN0IGRlZmF1bHRzIGludG8gYWxyZWFkeSBleGlzdGluZyBmb3JtIGRhdGFcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0Zvcm1EYXRhKSkge1xuICAgICAgICBkZWZhdWx0cyA9IHJhd0Zvcm1EYXRhLm1hcCgoaXRlbSwgaWR4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0cyhcbiAgICAgICAgICAgIHNjaGVtYS5pdGVtcyxcbiAgICAgICAgICAgIChkZWZhdWx0cyB8fCB7fSlbaWR4XSxcbiAgICAgICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2NoZW1hLm1pbkl0ZW1zKSB7XG4gICAgICAgIGlmICghaXNNdWx0aVNlbGVjdChzY2hlbWEsIHJvb3RTY2hlbWEpKSB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdHNMZW5ndGggPSBkZWZhdWx0cyA/IGRlZmF1bHRzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKHNjaGVtYS5taW5JdGVtcyA+IGRlZmF1bHRzTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RW50cmllcyA9IGRlZmF1bHRzIHx8IFtdO1xuICAgICAgICAgICAgLy8gcG9wdWxhdGUgdGhlIGFycmF5IHdpdGggdGhlIGRlZmF1bHRzXG4gICAgICAgICAgICBjb25zdCBmaWxsZXJTY2hlbWEgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcylcbiAgICAgICAgICAgICAgPyBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zXG4gICAgICAgICAgICAgIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgZmlsbGVyRW50cmllcyA9IGZpbGwoXG4gICAgICAgICAgICAgIG5ldyBBcnJheShzY2hlbWEubWluSXRlbXMgLSBkZWZhdWx0c0xlbmd0aCksXG4gICAgICAgICAgICAgIGNvbXB1dGVEZWZhdWx0cyhmaWxsZXJTY2hlbWEsIGZpbGxlclNjaGVtYS5kZWZhdWx0cywgcm9vdFNjaGVtYSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyB0aGVuIGZpbGwgdXAgdGhlIHJlc3Qgd2l0aCBlaXRoZXIgdGhlIGl0ZW0gZGVmYXVsdCBvciBlbXB0eSwgdXAgdG8gbWluSXRlbXNcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRFbnRyaWVzLmNvbmNhdChmaWxsZXJFbnRyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRzID8gZGVmYXVsdHMgOiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRGb3JtU3RhdGUoXG4gIF9zY2hlbWEsXG4gIGZvcm1EYXRhLFxuICByb290U2NoZW1hID0ge30sXG4gIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMgPSBmYWxzZVxuKSB7XG4gIGlmICghaXNPYmplY3QoX3NjaGVtYSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjaGVtYTogXCIgKyBfc2NoZW1hKTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShfc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gIGNvbnN0IGRlZmF1bHRzID0gY29tcHV0ZURlZmF1bHRzKFxuICAgIHNjaGVtYSxcbiAgICBfc2NoZW1hLmRlZmF1bHQsXG4gICAgcm9vdFNjaGVtYSxcbiAgICBmb3JtRGF0YSxcbiAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzXG4gICk7XG4gIGlmICh0eXBlb2YgZm9ybURhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBObyBmb3JtIGRhdGE/IFVzZSBzY2hlbWEgZGVmYXVsdHMuXG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG4gIGlmIChpc09iamVjdChmb3JtRGF0YSkgfHwgQXJyYXkuaXNBcnJheShmb3JtRGF0YSkpIHtcbiAgICByZXR1cm4gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShkZWZhdWx0cywgZm9ybURhdGEpO1xuICB9XG4gIGlmIChmb3JtRGF0YSA9PT0gMCB8fCBmb3JtRGF0YSA9PT0gZmFsc2UgfHwgZm9ybURhdGEgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gZm9ybURhdGE7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhIHx8IGRlZmF1bHRzO1xufVxuXG4vKipcbiAqIFdoZW4gbWVyZ2luZyBkZWZhdWx0cyBhbmQgZm9ybSBkYXRhLCB3ZSB3YW50IHRvIG1lcmdlIGluIHRoaXMgc3BlY2lmaWMgd2F5OlxuICogLSBvYmplY3RzIGFyZSBkZWVwbHkgbWVyZ2VkXG4gKiAtIGFycmF5cyBhcmUgbWVyZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdDpcbiAqICAgLSB3aGVuIHRoZSBhcnJheSBpcyBzZXQgaW4gZm9ybSBkYXRhLCBvbmx5IGFycmF5IGVudHJpZXMgc2V0IGluIGZvcm0gZGF0YVxuICogICAgIGFyZSBkZWVwbHkgbWVyZ2VkOyBhZGRpdGlvbmFsIGVudHJpZXMgZnJvbSB0aGUgZGVmYXVsdHMgYXJlIGlnbm9yZWRcbiAqICAgLSB3aGVuIHRoZSBhcnJheSBpcyBub3Qgc2V0IGluIGZvcm0gZGF0YSwgdGhlIGRlZmF1bHQgaXMgY29waWVkIG92ZXJcbiAqIC0gc2NhbGFycyBhcmUgb3ZlcndyaXR0ZW4vc2V0IGJ5IGZvcm0gZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShkZWZhdWx0cywgZm9ybURhdGEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybURhdGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xuICAgICAgZGVmYXVsdHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1EYXRhLm1hcCgodmFsdWUsIGlkeCkgPT4ge1xuICAgICAgaWYgKGRlZmF1bHRzW2lkeF0pIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHNXaXRoRm9ybURhdGEoZGVmYXVsdHNbaWR4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZvcm1EYXRhKSkge1xuICAgIGNvbnN0IGFjYyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTsgLy8gUHJldmVudCBtdXRhdGlvbiBvZiBzb3VyY2Ugb2JqZWN0LlxuICAgIHJldHVybiBPYmplY3Qua2V5cyhmb3JtRGF0YSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhKFxuICAgICAgICBkZWZhdWx0cyA/IGRlZmF1bHRzW2tleV0gOiB7fSxcbiAgICAgICAgZm9ybURhdGFba2V5XVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgYWNjKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZm9ybURhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVpT3B0aW9ucyh1aVNjaGVtYSkge1xuICAvLyBnZXQgYWxsIHBhc3NlZCBvcHRpb25zIGZyb20gdWk6d2lkZ2V0LCB1aTpvcHRpb25zLCBhbmQgdWk6PG9wdGlvbk5hbWU+XG4gIHJldHVybiBPYmplY3Qua2V5cyh1aVNjaGVtYSlcbiAgICAuZmlsdGVyKGtleSA9PiBrZXkuaW5kZXhPZihcInVpOlwiKSA9PT0gMClcbiAgICAucmVkdWNlKChvcHRpb25zLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdWlTY2hlbWFba2V5XTtcbiAgICAgIGlmIChrZXkgPT09IFwidWk6d2lkZ2V0XCIgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlNldHRpbmcgb3B0aW9ucyB2aWEgdWk6d2lkZ2V0IG9iamVjdCBpcyBkZXByZWNhdGVkLCB1c2UgdWk6b3B0aW9ucyBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIC4uLih2YWx1ZS5vcHRpb25zIHx8IHt9KSxcbiAgICAgICAgICB3aWRnZXQ6IHZhbHVlLmNvbXBvbmVudCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwidWk6b3B0aW9uc1wiICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyAuLi5vcHRpb25zLCAuLi52YWx1ZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgW2tleS5zdWJzdHJpbmcoMyldOiB2YWx1ZSB9O1xuICAgIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1Ym1pdEJ1dHRvbk9wdGlvbnModWlTY2hlbWEpIHtcbiAgY29uc3QgdWlPcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHN1Ym1pdFRleHQ6IFwiU3VibWl0XCIsXG4gICAgbm9yZW5kZXI6IGZhbHNlLFxuICB9O1xuICBpZiAodWlPcHRpb25zICYmIHVpT3B0aW9uc1tcInN1Ym1pdEJ1dHRvbk9wdGlvbnNcIl0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHVpT3B0aW9uc1tcInN1Ym1pdEJ1dHRvbk9wdGlvbnNcIl0pO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIHJvb3RTY2hlbWEpIHtcbiAgY29uc3QgdWlPcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgbGV0IHsgbGFiZWw6IGRpc3BsYXlMYWJlbCA9IHRydWUgfSA9IHVpT3B0aW9ucztcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGUoc2NoZW1hKTtcblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgZGlzcGxheUxhYmVsID1cbiAgICAgIGlzTXVsdGlTZWxlY3Qoc2NoZW1hLCByb290U2NoZW1hKSB8fFxuICAgICAgaXNGaWxlc0FycmF5KHNjaGVtYSwgdWlTY2hlbWEsIHJvb3RTY2hlbWEpIHx8XG4gICAgICBpc0N1c3RvbVdpZGdldCh1aVNjaGVtYSk7XG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGRpc3BsYXlMYWJlbCA9IGZhbHNlO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcImJvb2xlYW5cIiAmJiAhdWlTY2hlbWFbXCJ1aTp3aWRnZXRcIl0pIHtcbiAgICBkaXNwbGF5TGFiZWwgPSBmYWxzZTtcbiAgfVxuICBpZiAodWlTY2hlbWFbXCJ1aTpmaWVsZFwiXSkge1xuICAgIGRpc3BsYXlMYWJlbCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TGFiZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpbmcgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodGhpbmcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIsIGNvbmNhdEFycmF5cyA9IGZhbHNlKSB7XG4gIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIGRlZXBseSBuZXN0ZWQgb2JqZWN0cy5cbiAgdmFyIGFjYyA9IE9iamVjdC5hc3NpZ24oe30sIG9iajEpOyAvLyBQcmV2ZW50IG11dGF0aW9uIG9mIHNvdXJjZSBvYmplY3QuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmoyKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IG9iajEgPyBvYmoxW2tleV0gOiB7fSxcbiAgICAgIHJpZ2h0ID0gb2JqMltrZXldO1xuICAgIGlmIChvYmoxICYmIG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpc09iamVjdChyaWdodCkpIHtcbiAgICAgIGFjY1trZXldID0gbWVyZ2VPYmplY3RzKGxlZnQsIHJpZ2h0LCBjb25jYXRBcnJheXMpO1xuICAgIH0gZWxzZSBpZiAoY29uY2F0QXJyYXlzICYmIEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgIGFjY1trZXldID0gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba2V5XSA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBhY2MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoL1xcLiQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gXCIzLlwiIGNhbid0IHJlYWxseSBiZSBjb25zaWRlcmVkIGEgbnVtYmVyIGV2ZW4gaWYgaXQgcGFyc2VzIGluIGpzLiBUaGVcbiAgICAvLyB1c2VyIGlzIG1vc3QgbGlrZWx5IGVudGVyaW5nIGEgZmxvYXQuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICgvXFwuMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gdGhpcyBhcyBhIHN0cmluZyBoZXJlLCB0byBhbGxvdyBmb3IgaW5wdXQgbGlrZSAzLjA3XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IG4gPSBOdW1iZXIodmFsdWUpO1xuICBjb25zdCB2YWxpZCA9IHR5cGVvZiBuID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4obik7XG5cbiAgaWYgKC9cXC5cXGQqMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gSXQncyBhIG51bWJlciwgdGhhdCdzIGNvb2wgLSBidXQgd2UgbmVlZCBpdCBhcyBhIHN0cmluZyBzbyBpdCBkb2Vzbid0IHNjcmV3XG4gICAgLy8gd2l0aCB0aGUgdXNlciB3aGVuIGVudGVyaW5nIGRvbGxhciBhbW91bnRzIG9yIG90aGVyIHZhbHVlcyAoc3VjaCBhcyB0aG9zZSB3aXRoXG4gICAgLy8gc3BlY2lmaWMgcHJlY2lzaW9uIG9yIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMpXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkID8gbiA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIG9yZGVyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG4gIGNvbnN0IGFycmF5VG9IYXNoID0gYXJyID0+XG4gICAgYXJyLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgcHJldltjdXJyXSA9IHRydWU7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG4gIGNvbnN0IGVycm9yUHJvcExpc3QgPSBhcnIgPT5cbiAgICBhcnIubGVuZ3RoID4gMVxuICAgICAgPyBgcHJvcGVydGllcyAnJHthcnIuam9pbihcIicsICdcIil9J2BcbiAgICAgIDogYHByb3BlcnR5ICcke2FyclswXX0nYDtcbiAgY29uc3QgcHJvcGVydHlIYXNoID0gYXJyYXlUb0hhc2gocHJvcGVydGllcyk7XG4gIGNvbnN0IG9yZGVyRmlsdGVyZWQgPSBvcmRlci5maWx0ZXIoXG4gICAgcHJvcCA9PiBwcm9wID09PSBcIipcIiB8fCBwcm9wZXJ0eUhhc2hbcHJvcF1cbiAgKTtcbiAgY29uc3Qgb3JkZXJIYXNoID0gYXJyYXlUb0hhc2gob3JkZXJGaWx0ZXJlZCk7XG5cbiAgY29uc3QgcmVzdCA9IHByb3BlcnRpZXMuZmlsdGVyKHByb3AgPT4gIW9yZGVySGFzaFtwcm9wXSk7XG4gIGNvbnN0IHJlc3RJbmRleCA9IG9yZGVyRmlsdGVyZWQuaW5kZXhPZihcIipcIik7XG4gIGlmIChyZXN0SW5kZXggPT09IC0xKSB7XG4gICAgaWYgKHJlc3QubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB1aVNjaGVtYSBvcmRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gJHtlcnJvclByb3BMaXN0KHJlc3QpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvcmRlckZpbHRlcmVkO1xuICB9XG4gIGlmIChyZXN0SW5kZXggIT09IG9yZGVyRmlsdGVyZWQubGFzdEluZGV4T2YoXCIqXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidWlTY2hlbWEgb3JkZXIgbGlzdCBjb250YWlucyBtb3JlIHRoYW4gb25lIHdpbGRjYXJkIGl0ZW1cIik7XG4gIH1cblxuICBjb25zdCBjb21wbGV0ZSA9IFsuLi5vcmRlckZpbHRlcmVkXTtcbiAgY29tcGxldGUuc3BsaWNlKHJlc3RJbmRleCwgMSwgLi4ucmVzdCk7XG4gIHJldHVybiBjb21wbGV0ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gc2NoZW1hIG1hdGNoZXMgYSBzaW5nbGVcbiAqIGNvbnN0YW50IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdGFudChzY2hlbWEpIHtcbiAgcmV0dXJuIChcbiAgICAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB8fFxuICAgIHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImNvbnN0XCIpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0NvbnN0YW50KHNjaGVtYSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5lbnVtWzBdO1xuICB9IGVsc2UgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImNvbnN0XCIpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5jb25zdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgY2Fubm90IGJlIGluZmVycmVkIGFzIGEgY29uc3RhbnRcIik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VsZWN0KF9zY2hlbWEsIHJvb3RTY2hlbWEgPSB7fSkge1xuICBjb25zdCBzY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShfc2NoZW1hLCByb290U2NoZW1hKTtcbiAgY29uc3QgYWx0U2NoZW1hcyA9IHNjaGVtYS5vbmVPZiB8fCBzY2hlbWEuYW55T2Y7XG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWx0U2NoZW1hcykpIHtcbiAgICByZXR1cm4gYWx0U2NoZW1hcy5ldmVyeShhbHRTY2hlbWFzID0+IGlzQ29uc3RhbnQoYWx0U2NoZW1hcykpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTXVsdGlTZWxlY3Qoc2NoZW1hLCByb290U2NoZW1hID0ge30pIHtcbiAgaWYgKCFzY2hlbWEudW5pcXVlSXRlbXMgfHwgIXNjaGVtYS5pdGVtcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNTZWxlY3Qoc2NoZW1hLml0ZW1zLCByb290U2NoZW1hKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZXNBcnJheShzY2hlbWEsIHVpU2NoZW1hLCByb290U2NoZW1hID0ge30pIHtcbiAgaWYgKHVpU2NoZW1hW1widWk6d2lkZ2V0XCJdID09PSBcImZpbGVzXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaXRlbXMpIHtcbiAgICBjb25zdCBpdGVtc1NjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHNjaGVtYS5pdGVtcywgcm9vdFNjaGVtYSk7XG4gICAgcmV0dXJuIGl0ZW1zU2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgaXRlbXNTY2hlbWEuZm9ybWF0ID09PSBcImRhdGEtdXJsXCI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXhlZEl0ZW1zKHNjaGVtYSkge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSAmJlxuICAgIHNjaGVtYS5pdGVtcy5sZW5ndGggPiAwICYmXG4gICAgc2NoZW1hLml0ZW1zLmV2ZXJ5KGl0ZW0gPT4gaXNPYmplY3QoaXRlbSkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1c3RvbVdpZGdldCh1aVNjaGVtYSkge1xuICByZXR1cm4gKFxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGUgYCYmIHVpU2NoZW1hW1widWk6d2lkZ2V0XCJdICE9PSBcImhpZGRlblwiYCBvbmNlIHdlIHN1cHBvcnQgaGlkZGVuIHdpZGdldHMgZm9yIGFycmF5cy5cbiAgICAvLyBodHRwczovL3JlYWN0LWpzb25zY2hlbWEtZm9ybS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvdXNhZ2Uvd2lkZ2V0cy8jaGlkZGVuLXdpZGdldHNcbiAgICBcIndpZGdldFwiIGluIGdldFVpT3B0aW9ucyh1aVNjaGVtYSkgJiZcbiAgICBnZXRVaU9wdGlvbnModWlTY2hlbWEpW1wid2lkZ2V0XCJdICE9PSBcImhpZGRlblwiXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxvd0FkZGl0aW9uYWxJdGVtcyhzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJhZGRpdGlvbmFsSXRlbXM9dHJ1ZSBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25zTGlzdChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5lbnVtKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5lbnVtLm1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gKHNjaGVtYS5lbnVtTmFtZXMgJiYgc2NoZW1hLmVudW1OYW1lc1tpXSkgfHwgU3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB7IGxhYmVsLCB2YWx1ZSB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFsdFNjaGVtYXMgPSBzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mO1xuICAgIHJldHVybiBhbHRTY2hlbWFzLm1hcChzY2hlbWEgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0NvbnN0YW50KHNjaGVtYSk7XG4gICAgICBjb25zdCBsYWJlbCA9IHNjaGVtYS50aXRsZSB8fCBTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kU2NoZW1hRGVmaW5pdGlvbigkcmVmLCByb290U2NoZW1hID0ge30pIHtcbiAgY29uc3Qgb3JpZ1JlZiA9ICRyZWY7XG4gIGlmICgkcmVmLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgLy8gRGVjb2RlIFVSSSBmcmFnbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAkcmVmID0gZGVjb2RlVVJJQ29tcG9uZW50KCRyZWYuc3Vic3RyaW5nKDEpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmaW5pdGlvbiBmb3IgJHtvcmlnUmVmfS5gKTtcbiAgfVxuICBjb25zdCBjdXJyZW50ID0ganNvbnBvaW50ZXIuZ2V0KHJvb3RTY2hlbWEsICRyZWYpO1xuICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIGRlZmluaXRpb24gZm9yICR7b3JpZ1JlZn0uYCk7XG4gIH1cbiAgaWYgKGN1cnJlbnQuaGFzT3duUHJvcGVydHkoXCIkcmVmXCIpKSB7XG4gICAgcmV0dXJuIGZpbmRTY2hlbWFEZWZpbml0aW9uKGN1cnJlbnQuJHJlZiwgcm9vdFNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8vIEluIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgdG8gaW1wbGljaXRseSBjcmVhdGUgYSBzY2hlbWEsIGl0IGlzIHVzZWZ1bCB0byBrbm93IHdoYXQgdHlwZSB0byB1c2Vcbi8vICBiYXNlZCBvbiB0aGUgZGF0YSB3ZSBhcmUgZGVmaW5pbmdcbmV4cG9ydCBjb25zdCBndWVzc1R5cGUgPSBmdW5jdGlvbiBndWVzc1R5cGUodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBcIm9iamVjdFwiO1xuICB9XG4gIC8vIERlZmF1bHQgdG8gc3RyaW5nIGlmIHdlIGNhbid0IGZpZ3VyZSBpdCBvdXRcbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIG5ldyBcInByb3BlcnRpZXNcIiBpdGVtcyBmb3IgZWFjaCBrZXkgaW4gb3VyIGZvcm1EYXRhXG5leHBvcnQgZnVuY3Rpb24gc3R1YkV4aXN0aW5nQWRkaXRpb25hbFByb3BlcnRpZXMoXG4gIHNjaGVtYSxcbiAgcm9vdFNjaGVtYSA9IHt9LFxuICBmb3JtRGF0YSA9IHt9XG4pIHtcbiAgLy8gQ2xvbmUgdGhlIHNjaGVtYSBzbyB3ZSBkb24ndCBydWluIHRoZSBjb25zdW1lcidzIG9yaWdpbmFsXG4gIHNjaGVtYSA9IHtcbiAgICAuLi5zY2hlbWEsXG4gICAgcHJvcGVydGllczogeyAuLi5zY2hlbWEucHJvcGVydGllcyB9LFxuICB9O1xuXG4gIC8vIG1ha2Ugc3VyZSBmb3JtRGF0YSBpcyBhbiBvYmplY3RcbiAgZm9ybURhdGEgPSBpc09iamVjdChmb3JtRGF0YSkgPyBmb3JtRGF0YSA6IHt9O1xuXG4gIE9iamVjdC5rZXlzKGZvcm1EYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gc3R1Yiwgb3VyIHNjaGVtYSBhbHJlYWR5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcIiRyZWZcIikpIHtcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcmV0cmlldmVTY2hlbWEoXG4gICAgICAgIHsgJHJlZjogc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzW1wiJHJlZlwiXSB9LFxuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICBmb3JtRGF0YVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0geyAuLi5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSB7IHR5cGU6IGd1ZXNzVHlwZShmb3JtRGF0YVtrZXldKSB9O1xuICAgIH1cblxuICAgIC8vIFRoZSB0eXBlIG9mIG91ciBuZXcga2V5IHNob3VsZCBtYXRjaCB0aGUgYWRkaXRpb25hbFByb3BlcnRpZXMgdmFsdWU7XG4gICAgc2NoZW1hLnByb3BlcnRpZXNba2V5XSA9IGFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgIC8vIFNldCBvdXIgYWRkaXRpb25hbCBwcm9wZXJ0eSBmbGFnIHNvIHdlIGtub3cgaXQgd2FzIGR5bmFtaWNhbGx5IGFkZGVkXG4gICAgc2NoZW1hLnByb3BlcnRpZXNba2V5XVtBRERJVElPTkFMX1BST1BFUlRZX0ZMQUddID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGNvbmRpdGlvbmFsIGJsb2NrIChpZi9lbHNlL3RoZW4pIGJ5IHJlbW92aW5nIHRoZSBjb25kaXRpb24gYW5kIG1lcmdpbmcgdGhlIGFwcHJvcHJpYXRlIGNvbmRpdGlvbmFsIGJyYW5jaCB3aXRoIHRoZSByZXN0IG9mIHRoZSBzY2hlbWFcbiAqL1xuY29uc3QgcmVzb2x2ZUNvbmRpdGlvbiA9IChzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKSA9PiB7XG4gIGxldCB7XG4gICAgaWY6IGV4cHJlc3Npb24sXG4gICAgdGhlbixcbiAgICBlbHNlOiBvdGhlcndpc2UsXG4gICAgLi4ucmVzb2x2ZWRTY2hlbWFMZXNzQ29uZGl0aW9uYWxcbiAgfSA9IHNjaGVtYTtcblxuICBjb25zdCBjb25kaXRpb25hbFNjaGVtYSA9IGlzVmFsaWQoZXhwcmVzc2lvbiwgZm9ybURhdGEsIHJvb3RTY2hlbWEpXG4gICAgPyB0aGVuXG4gICAgOiBvdGhlcndpc2U7XG5cbiAgaWYgKGNvbmRpdGlvbmFsU2NoZW1hKSB7XG4gICAgcmV0dXJuIHJldHJpZXZlU2NoZW1hKFxuICAgICAgbWVyZ2VTY2hlbWFzKFxuICAgICAgICByZXNvbHZlZFNjaGVtYUxlc3NDb25kaXRpb25hbCxcbiAgICAgICAgcmV0cmlldmVTY2hlbWEoY29uZGl0aW9uYWxTY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKVxuICAgICAgKSxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJldHJpZXZlU2NoZW1hKHJlc29sdmVkU2NoZW1hTGVzc0NvbmRpdGlvbmFsLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgcmVmZXJlbmNlcyBhbmQgZGVwZW5kZW5jaWVzIHdpdGhpbiBhIHNjaGVtYSBhbmQgaXRzICdhbGxPZicgY2hpbGRyZW4uXG4gKlxuICogQ2FsbGVkIGludGVybmFsbHkgYnkgcmV0cmlldmVTY2hlbWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKHNjaGVtYSwgcm9vdFNjaGVtYSA9IHt9LCBmb3JtRGF0YSA9IHt9KSB7XG4gIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCIkcmVmXCIpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVSZWZlcmVuY2Uoc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KFwiZGVwZW5kZW5jaWVzXCIpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlRGVwZW5kZW5jaWVzKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgIHJldHVybiByZXRyaWV2ZVNjaGVtYShyZXNvbHZlZFNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICB9IGVsc2UgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImFsbE9mXCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNjaGVtYSxcbiAgICAgIGFsbE9mOiBzY2hlbWEuYWxsT2YubWFwKGFsbE9mU3Vic2NoZW1hID0+XG4gICAgICAgIHJldHJpZXZlU2NoZW1hKGFsbE9mU3Vic2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSlcbiAgICAgICksXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyAkcmVmIG9yIGRlcGVuZGVuY2llcyBhdHRyaWJ1dGUgZm91bmQsIHJldHVybmluZyB0aGUgb3JpZ2luYWwgc2NoZW1hLlxuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZShzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKSB7XG4gIC8vIFJldHJpZXZlIHRoZSByZWZlcmVuY2VkIHNjaGVtYSBkZWZpbml0aW9uLlxuICBjb25zdCAkcmVmU2NoZW1hID0gZmluZFNjaGVtYURlZmluaXRpb24oc2NoZW1hLiRyZWYsIHJvb3RTY2hlbWEpO1xuICAvLyBEcm9wIHRoZSAkcmVmIHByb3BlcnR5IG9mIHRoZSBzb3VyY2Ugc2NoZW1hLlxuICBjb25zdCB7ICRyZWYsIC4uLmxvY2FsU2NoZW1hIH0gPSBzY2hlbWE7XG4gIC8vIFVwZGF0ZSByZWZlcmVuY2VkIHNjaGVtYSBkZWZpbml0aW9uIHdpdGggbG9jYWwgc2NoZW1hIHByb3BlcnRpZXMuXG4gIHJldHVybiByZXRyaWV2ZVNjaGVtYShcbiAgICB7IC4uLiRyZWZTY2hlbWEsIC4uLmxvY2FsU2NoZW1hIH0sXG4gICAgcm9vdFNjaGVtYSxcbiAgICBmb3JtRGF0YVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0cmlldmVTY2hlbWEoc2NoZW1hLCByb290U2NoZW1hID0ge30sIGZvcm1EYXRhID0ge30pIHtcbiAgaWYgKCFpc09iamVjdChzY2hlbWEpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGxldCByZXNvbHZlZFNjaGVtYSA9IHJlc29sdmVTY2hlbWEoc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG5cbiAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImlmXCIpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVDb25kaXRpb24oc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gIH1cblxuICAvLyBGb3IgZWFjaCBsZXZlbCBvZiB0aGUgZGVwZW5kZW5jeSwgd2UgbmVlZCB0byByZWN1cnNpdmVseSBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHJlc29sdmVkIHNjaGVtYSBnaXZlbiB0aGUgY3VycmVudCBzdGF0ZSBvZiBmb3JtRGF0YS5cbiAgLy8gT3RoZXJ3aXNlLCBuZXN0ZWQgYWxsT2Ygc3Vic2NoZW1hcyB3aWxsIG5vdCBiZSBjb3JyZWN0bHkgZGlzcGxheWVkLlxuICBpZiAocmVzb2x2ZWRTY2hlbWEucHJvcGVydGllcykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcblxuICAgIE9iamVjdC5lbnRyaWVzKHJlc29sdmVkU2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goZW50cmllcyA9PiB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IGVudHJpZXNbMF07XG4gICAgICBjb25zdCBwcm9wU2NoZW1hID0gZW50cmllc1sxXTtcbiAgICAgIGNvbnN0IHJhd1Byb3BEYXRhID0gZm9ybURhdGEgJiYgZm9ybURhdGFbcHJvcE5hbWVdO1xuICAgICAgY29uc3QgcHJvcERhdGEgPSBpc09iamVjdChyYXdQcm9wRGF0YSkgPyByYXdQcm9wRGF0YSA6IHt9O1xuICAgICAgY29uc3QgcmVzb2x2ZWRQcm9wU2NoZW1hID0gcmV0cmlldmVTY2hlbWEoXG4gICAgICAgIHByb3BTY2hlbWEsXG4gICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgIHByb3BEYXRhXG4gICAgICApO1xuXG4gICAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHJlc29sdmVkUHJvcFNjaGVtYTtcblxuICAgICAgaWYgKFxuICAgICAgICBwcm9wU2NoZW1hICE9PSByZXNvbHZlZFByb3BTY2hlbWEgJiZcbiAgICAgICAgcmVzb2x2ZWRTY2hlbWEucHJvcGVydGllcyAhPT0gcHJvcGVydGllc1xuICAgICAgKSB7XG4gICAgICAgIHJlc29sdmVkU2NoZW1hID0geyAuLi5yZXNvbHZlZFNjaGVtYSwgcHJvcGVydGllcyB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKFwiYWxsT2ZcIiBpbiBzY2hlbWEpIHtcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZUFsbE9mKHtcbiAgICAgICAgLi4ucmVzb2x2ZWRTY2hlbWEsXG4gICAgICAgIGFsbE9mOiByZXNvbHZlZFNjaGVtYS5hbGxPZixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImNvdWxkIG5vdCBtZXJnZSBzdWJzY2hlbWFzIGluIGFsbE9mOlxcblwiICsgZSk7XG4gICAgICBjb25zdCB7IGFsbE9mLCAuLi5yZXNvbHZlZFNjaGVtYVdpdGhvdXRBbGxPZiB9ID0gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWFXaXRob3V0QWxsT2Y7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc0FkZGl0aW9uYWxQcm9wZXJ0aWVzID1cbiAgICByZXNvbHZlZFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpICYmXG4gICAgcmVzb2x2ZWRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgIT09IGZhbHNlO1xuICBpZiAoaGFzQWRkaXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gc3R1YkV4aXN0aW5nQWRkaXRpb25hbFByb3BlcnRpZXMoXG4gICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVwZW5kZW5jaWVzKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpIHtcbiAgLy8gRHJvcCB0aGUgZGVwZW5kZW5jaWVzIGZyb20gdGhlIHNvdXJjZSBzY2hlbWEuXG4gIGxldCB7IGRlcGVuZGVuY2llcyA9IHt9LCAuLi5yZXNvbHZlZFNjaGVtYSB9ID0gc2NoZW1hO1xuICBpZiAoXCJvbmVPZlwiIGluIHJlc29sdmVkU2NoZW1hKSB7XG4gICAgcmVzb2x2ZWRTY2hlbWEgPVxuICAgICAgcmVzb2x2ZWRTY2hlbWEub25lT2ZbXG4gICAgICAgIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCByZXNvbHZlZFNjaGVtYS5vbmVPZiwgcm9vdFNjaGVtYSlcbiAgICAgIF07XG4gIH0gZWxzZSBpZiAoXCJhbnlPZlwiIGluIHJlc29sdmVkU2NoZW1hKSB7XG4gICAgcmVzb2x2ZWRTY2hlbWEgPVxuICAgICAgcmVzb2x2ZWRTY2hlbWEuYW55T2ZbXG4gICAgICAgIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCByZXNvbHZlZFNjaGVtYS5hbnlPZiwgcm9vdFNjaGVtYSlcbiAgICAgIF07XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NEZXBlbmRlbmNpZXMoXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIHJlc29sdmVkU2NoZW1hLFxuICAgIHJvb3RTY2hlbWEsXG4gICAgZm9ybURhdGFcbiAgKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NEZXBlbmRlbmNpZXMoXG4gIGRlcGVuZGVuY2llcyxcbiAgcmVzb2x2ZWRTY2hlbWEsXG4gIHJvb3RTY2hlbWEsXG4gIGZvcm1EYXRhXG4pIHtcbiAgLy8gUHJvY2VzcyBkZXBlbmRlbmNpZXMgdXBkYXRpbmcgdGhlIGxvY2FsIHNjaGVtYSBwcm9wZXJ0aWVzIGFzIGFwcHJvcHJpYXRlLlxuICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lLZXkgaW4gZGVwZW5kZW5jaWVzKSB7XG4gICAgLy8gU2tpcCB0aGlzIGRlcGVuZGVuY3kgaWYgaXRzIHRyaWdnZXIgcHJvcGVydHkgaXMgbm90IHByZXNlbnQuXG4gICAgaWYgKGZvcm1EYXRhW2RlcGVuZGVuY3lLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBTa2lwIHRoaXMgZGVwZW5kZW5jeSBpZiBpdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHNjaGVtYSAoc3VjaCBhcyB3aGVuIGRlcGVuZGVuY3lLZXkgaXMgaXRzZWxmIGEgaGlkZGVuIGRlcGVuZGVuY3kuKVxuICAgIGlmIChcbiAgICAgIHJlc29sdmVkU2NoZW1hLnByb3BlcnRpZXMgJiZcbiAgICAgICEoZGVwZW5kZW5jeUtleSBpbiByZXNvbHZlZFNjaGVtYS5wcm9wZXJ0aWVzKVxuICAgICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIFtkZXBlbmRlbmN5S2V5XTogZGVwZW5kZW5jeVZhbHVlLFxuICAgICAgLi4ucmVtYWluaW5nRGVwZW5kZW5jaWVzXG4gICAgfSA9IGRlcGVuZGVuY2llcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXBlbmRlbmN5VmFsdWUpKSB7XG4gICAgICByZXNvbHZlZFNjaGVtYSA9IHdpdGhEZXBlbmRlbnRQcm9wZXJ0aWVzKHJlc29sdmVkU2NoZW1hLCBkZXBlbmRlbmN5VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVwZW5kZW5jeVZhbHVlKSkge1xuICAgICAgcmVzb2x2ZWRTY2hlbWEgPSB3aXRoRGVwZW5kZW50U2NoZW1hKFxuICAgICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGRlcGVuZGVuY3lLZXksXG4gICAgICAgIGRlcGVuZGVuY3lWYWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NEZXBlbmRlbmNpZXMoXG4gICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMsXG4gICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xufVxuXG5mdW5jdGlvbiB3aXRoRGVwZW5kZW50UHJvcGVydGllcyhzY2hlbWEsIGFkZGl0aW9uYWxseVJlcXVpcmVkKSB7XG4gIGlmICghYWRkaXRpb25hbGx5UmVxdWlyZWQpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIGNvbnN0IHJlcXVpcmVkID0gQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpXG4gICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLnNjaGVtYS5yZXF1aXJlZCwgLi4uYWRkaXRpb25hbGx5UmVxdWlyZWRdKSlcbiAgICA6IGFkZGl0aW9uYWxseVJlcXVpcmVkO1xuICByZXR1cm4geyAuLi5zY2hlbWEsIHJlcXVpcmVkOiByZXF1aXJlZCB9O1xufVxuXG5mdW5jdGlvbiB3aXRoRGVwZW5kZW50U2NoZW1hKFxuICBzY2hlbWEsXG4gIHJvb3RTY2hlbWEsXG4gIGZvcm1EYXRhLFxuICBkZXBlbmRlbmN5S2V5LFxuICBkZXBlbmRlbmN5VmFsdWVcbikge1xuICBsZXQgeyBvbmVPZiwgLi4uZGVwZW5kZW50U2NoZW1hIH0gPSByZXRyaWV2ZVNjaGVtYShcbiAgICBkZXBlbmRlbmN5VmFsdWUsXG4gICAgcm9vdFNjaGVtYSxcbiAgICBmb3JtRGF0YVxuICApO1xuICBzY2hlbWEgPSBtZXJnZVNjaGVtYXMoc2NoZW1hLCBkZXBlbmRlbnRTY2hlbWEpO1xuICAvLyBTaW5jZSBpdCBkb2VzIG5vdCBjb250YWluIG9uZU9mLCB3ZSByZXR1cm4gdGhlIG9yaWdpbmFsIHNjaGVtYS5cbiAgaWYgKG9uZU9mID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9uZU9mKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZDogaXQgaXMgc29tZSAke3R5cGVvZiBvbmVPZn0gaW5zdGVhZCBvZiBhbiBhcnJheWApO1xuICB9XG4gIC8vIFJlc29sdmUgJHJlZnMgaW5zaWRlIG9uZU9mLlxuICBjb25zdCByZXNvbHZlZE9uZU9mID0gb25lT2YubWFwKHN1YnNjaGVtYSA9PlxuICAgIHN1YnNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcIiRyZWZcIilcbiAgICAgID8gcmVzb2x2ZVJlZmVyZW5jZShzdWJzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKVxuICAgICAgOiBzdWJzY2hlbWFcbiAgKTtcbiAgcmV0dXJuIHdpdGhFeGFjdGx5T25lU3Vic2NoZW1hKFxuICAgIHNjaGVtYSxcbiAgICByb290U2NoZW1hLFxuICAgIGZvcm1EYXRhLFxuICAgIGRlcGVuZGVuY3lLZXksXG4gICAgcmVzb2x2ZWRPbmVPZlxuICApO1xufVxuXG5mdW5jdGlvbiB3aXRoRXhhY3RseU9uZVN1YnNjaGVtYShcbiAgc2NoZW1hLFxuICByb290U2NoZW1hLFxuICBmb3JtRGF0YSxcbiAgZGVwZW5kZW5jeUtleSxcbiAgb25lT2Zcbikge1xuICBjb25zdCB2YWxpZFN1YnNjaGVtYXMgPSBvbmVPZi5maWx0ZXIoc3Vic2NoZW1hID0+IHtcbiAgICBpZiAoIXN1YnNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgW2RlcGVuZGVuY3lLZXldOiBjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSB9ID0gc3Vic2NoZW1hLnByb3BlcnRpZXM7XG4gICAgaWYgKGNvbmRpdGlvblByb3BlcnR5U2NoZW1hKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25TY2hlbWEgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBbZGVwZW5kZW5jeUtleV06IGNvbmRpdGlvblByb3BlcnR5U2NoZW1hLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSB2YWxpZGF0ZUZvcm1EYXRhKGZvcm1EYXRhLCBjb25kaXRpb25TY2hlbWEpO1xuICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9KTtcbiAgaWYgKHZhbGlkU3Vic2NoZW1hcy5sZW5ndGggIT09IDEpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcImlnbm9yaW5nIG9uZU9mIGluIGRlcGVuZGVuY2llcyBiZWNhdXNlIHRoZXJlIGlzbid0IGV4YWN0bHkgb25lIHN1YnNjaGVtYSB0aGF0IGlzIHZhbGlkXCJcbiAgICApO1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgY29uc3Qgc3Vic2NoZW1hID0gdmFsaWRTdWJzY2hlbWFzWzBdO1xuICBjb25zdCB7XG4gICAgW2RlcGVuZGVuY3lLZXldOiBjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSxcbiAgICAuLi5kZXBlbmRlbnRTdWJzY2hlbWFcbiAgfSA9IHN1YnNjaGVtYS5wcm9wZXJ0aWVzO1xuICBjb25zdCBkZXBlbmRlbnRTY2hlbWEgPSB7IC4uLnN1YnNjaGVtYSwgcHJvcGVydGllczogZGVwZW5kZW50U3Vic2NoZW1hIH07XG4gIHJldHVybiBtZXJnZVNjaGVtYXMoXG4gICAgc2NoZW1hLFxuICAgIHJldHJpZXZlU2NoZW1hKGRlcGVuZGVudFNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpXG4gICk7XG59XG5cbi8vIFJlY3Vyc2l2ZWx5IG1lcmdlIGRlZXBseSBuZXN0ZWQgc2NoZW1hcy5cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gbWVyZ2VTY2hlbWFzIGFuZCBtZXJnZU9iamVjdHNcbi8vIGlzIHRoYXQgbWVyZ2VTY2hlbWFzIG9ubHkgY29uY2F0cyBhcnJheXMgZm9yXG4vLyB2YWx1ZXMgdW5kZXIgdGhlIFwicmVxdWlyZWRcIiBrZXl3b3JkLCBhbmQgd2hlbiBpdCBkb2VzLFxuLy8gaXQgZG9lc24ndCBpbmNsdWRlIGR1cGxpY2F0ZSB2YWx1ZXMuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTY2hlbWFzKG9iajEsIG9iajIpIHtcbiAgdmFyIGFjYyA9IE9iamVjdC5hc3NpZ24oe30sIG9iajEpOyAvLyBQcmV2ZW50IG11dGF0aW9uIG9mIHNvdXJjZSBvYmplY3QuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmoyKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IG9iajEgPyBvYmoxW2tleV0gOiB7fSxcbiAgICAgIHJpZ2h0ID0gb2JqMltrZXldO1xuICAgIGlmIChvYmoxICYmIG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpc09iamVjdChyaWdodCkpIHtcbiAgICAgIGFjY1trZXldID0gbWVyZ2VTY2hlbWFzKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgb2JqMSAmJlxuICAgICAgb2JqMiAmJlxuICAgICAgKGdldFNjaGVtYVR5cGUob2JqMSkgPT09IFwib2JqZWN0XCIgfHwgZ2V0U2NoZW1hVHlwZShvYmoyKSA9PT0gXCJvYmplY3RcIikgJiZcbiAgICAgIGtleSA9PT0gXCJyZXF1aXJlZFwiICYmXG4gICAgICBBcnJheS5pc0FycmF5KGxlZnQpICYmXG4gICAgICBBcnJheS5pc0FycmF5KHJpZ2h0KVxuICAgICkge1xuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBkdXBsaWNhdGUgdmFsdWVzIHdoZW4gbWVyZ2luZ1xuICAgICAgLy8gXCJyZXF1aXJlZFwiIGZpZWxkcy5cbiAgICAgIGFjY1trZXldID0gdW5pb24obGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba2V5XSA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBhY2MpO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVlcEVxdWFscyhhLCBiLCBjYSA9IFtdLCBjYiA9IFtdKSB7XG4gIC8vIFBhcnRpYWxseSBleHRyYWN0ZWQgZnJvbSBub2RlLWRlZXBlciBhbmQgYWRhcHRlZCB0byBleGNsdWRlIGNvbXBhcmlzb25cbiAgLy8gY2hlY2tzIGZvciBmdW5jdGlvbnMuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vdGhpeW0yMy9ub2RlLWRlZXBlclxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIEFzc3VtZSBhbGwgZnVuY3Rpb25zIGFyZSBlcXVpdmFsZW50XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yanNmLXRlYW0vcmVhY3QtanNvbnNjaGVtYS1mb3JtL2lzc3Vlcy8yNTVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHAgJiYgYiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiZcbiAgICAgIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJlxuICAgICAgYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lICYmXG4gICAgICBhLmxhc3RJbmRleCA9PT0gYi5sYXN0SW5kZXggJiZcbiAgICAgIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc0FyZ3VtZW50cyhhKSB8fCBpc0FyZ3VtZW50cyhiKSkge1xuICAgIGlmICghKGlzQXJndW1lbnRzKGEpICYmIGlzQXJndW1lbnRzKGIpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgcmV0dXJuIGRlZXBFcXVhbHMoc2xpY2UuY2FsbChhKSwgc2xpY2UuY2FsbChiKSwgY2EsIGNiKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBrYSA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxldCBrYiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIC8vIGRvbid0IGJvdGhlciB3aXRoIHN0YWNrIGFjcm9iYXRpY3MgaWYgdGhlcmUncyBub3RoaW5nIHRoZXJlXG4gICAgaWYgKGthLmxlbmd0aCA9PT0gMCAmJiBrYi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY2FsID0gY2EubGVuZ3RoO1xuICAgIHdoaWxlIChjYWwtLSkge1xuICAgICAgaWYgKGNhW2NhbF0gPT09IGEpIHtcbiAgICAgICAgcmV0dXJuIGNiW2NhbF0gPT09IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGNhLnB1c2goYSk7XG4gICAgY2IucHVzaChiKTtcblxuICAgIGthLnNvcnQoKTtcbiAgICBrYi5zb3J0KCk7XG4gICAgZm9yICh2YXIgaiA9IGthLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoa2Fbal0gIT09IGtiW2pdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGsgPSBrYS5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xuICAgICAga2V5ID0ga2Fba107XG4gICAgICBpZiAoIWRlZXBFcXVhbHMoYVtrZXldLCBiW2tleV0sIGNhLCBjYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhLnBvcCgpO1xuICAgIGNiLnBvcCgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFJlbmRlcihjb21wLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICBjb25zdCB7IHByb3BzLCBzdGF0ZSB9ID0gY29tcDtcbiAgcmV0dXJuICFkZWVwRXF1YWxzKHByb3BzLCBuZXh0UHJvcHMpIHx8ICFkZWVwRXF1YWxzKHN0YXRlLCBuZXh0U3RhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9JZFNjaGVtYShcbiAgc2NoZW1hLFxuICBpZCxcbiAgcm9vdFNjaGVtYSxcbiAgZm9ybURhdGEgPSB7fSxcbiAgaWRQcmVmaXggPSBcInJvb3RcIixcbiAgaWRTZXBhcmF0b3IgPSBcIl9cIlxuKSB7XG4gIGNvbnN0IGlkU2NoZW1hID0ge1xuICAgICRpZDogaWQgfHwgaWRQcmVmaXgsXG4gIH07XG4gIGlmIChcIiRyZWZcIiBpbiBzY2hlbWEgfHwgXCJkZXBlbmRlbmNpZXNcIiBpbiBzY2hlbWEgfHwgXCJhbGxPZlwiIGluIHNjaGVtYSkge1xuICAgIGNvbnN0IF9zY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICByZXR1cm4gdG9JZFNjaGVtYShfc2NoZW1hLCBpZCwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGlkUHJlZml4LCBpZFNlcGFyYXRvcik7XG4gIH1cbiAgaWYgKFwiaXRlbXNcIiBpbiBzY2hlbWEgJiYgIXNjaGVtYS5pdGVtcy4kcmVmKSB7XG4gICAgcmV0dXJuIHRvSWRTY2hlbWEoXG4gICAgICBzY2hlbWEuaXRlbXMsXG4gICAgICBpZCxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGlkUHJlZml4LFxuICAgICAgaWRTZXBhcmF0b3JcbiAgICApO1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBpZFNjaGVtYTtcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMgfHwge30pIHtcbiAgICBjb25zdCBmaWVsZCA9IHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIGNvbnN0IGZpZWxkSWQgPSBpZFNjaGVtYS4kaWQgKyBpZFNlcGFyYXRvciArIG5hbWU7XG4gICAgaWRTY2hlbWFbbmFtZV0gPSB0b0lkU2NoZW1hKFxuICAgICAgaXNPYmplY3QoZmllbGQpID8gZmllbGQgOiB7fSxcbiAgICAgIGZpZWxkSWQsXG4gICAgICByb290U2NoZW1hLFxuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGZvcm1EYXRhIGlzIG5vdCBhbiBvYmplY3QgLS0gdGhpcyBjYW4gaGFwcGVuIGlmIGFuXG4gICAgICAvLyBhcnJheSBpdGVtIGhhcyBqdXN0IGJlZW4gYWRkZWQsIGJ1dCBub3QgcG9wdWxhdGVkIHdpdGggZGF0YSB5ZXRcbiAgICAgIChmb3JtRGF0YSB8fCB7fSlbbmFtZV0sXG4gICAgICBpZFByZWZpeCxcbiAgICAgIGlkU2VwYXJhdG9yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaWRTY2hlbWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BhdGhTY2hlbWEoc2NoZW1hLCBuYW1lID0gXCJcIiwgcm9vdFNjaGVtYSwgZm9ybURhdGEgPSB7fSkge1xuICBjb25zdCBwYXRoU2NoZW1hID0ge1xuICAgICRuYW1lOiBuYW1lLnJlcGxhY2UoL15cXC4vLCBcIlwiKSxcbiAgfTtcbiAgaWYgKFwiJHJlZlwiIGluIHNjaGVtYSB8fCBcImRlcGVuZGVuY2llc1wiIGluIHNjaGVtYSB8fCBcImFsbE9mXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgX3NjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgIHJldHVybiB0b1BhdGhTY2hlbWEoX3NjaGVtYSwgbmFtZSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKSB7XG4gICAgcGF0aFNjaGVtYS5fX3Jqc2ZfYWRkaXRpb25hbFByb3BlcnRpZXMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcIml0ZW1zXCIpICYmIEFycmF5LmlzQXJyYXkoZm9ybURhdGEpKSB7XG4gICAgZm9ybURhdGEuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4ge1xuICAgICAgcGF0aFNjaGVtYVtpXSA9IHRvUGF0aFNjaGVtYShcbiAgICAgICAgc2NoZW1hLml0ZW1zLFxuICAgICAgICBgJHtuYW1lfS4ke2l9YCxcbiAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgZWxlbWVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJwcm9wZXJ0aWVzXCIpKSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgcGF0aFNjaGVtYVtwcm9wZXJ0eV0gPSB0b1BhdGhTY2hlbWEoXG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSxcbiAgICAgICAgYCR7bmFtZX0uJHtwcm9wZXJ0eX1gLFxuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZm9ybURhdGEgaXMgbm90IGFuIG9iamVjdCAtLSB0aGlzIGNhbiBoYXBwZW4gaWYgYW5cbiAgICAgICAgLy8gYXJyYXkgaXRlbSBoYXMganVzdCBiZWVuIGFkZGVkLCBidXQgbm90IHBvcHVsYXRlZCB3aXRoIGRhdGEgeWV0XG4gICAgICAgIChmb3JtRGF0YSB8fCB7fSlbcHJvcGVydHldXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aFNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZVN0cmluZyhkYXRlU3RyaW5nLCBpbmNsdWRlVGltZSA9IHRydWUpIHtcbiAgaWYgKCFkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IC0xLFxuICAgICAgbW9udGg6IC0xLFxuICAgICAgZGF5OiAtMSxcbiAgICAgIGhvdXI6IGluY2x1ZGVUaW1lID8gLTEgOiAwLFxuICAgICAgbWludXRlOiBpbmNsdWRlVGltZSA/IC0xIDogMCxcbiAgICAgIHNlY29uZDogaW5jbHVkZVRpbWUgPyAtMSA6IDAsXG4gICAgfTtcbiAgfVxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGRhdGUgXCIgKyBkYXRlU3RyaW5nKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHllYXI6IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZGF0ZS5nZXRVVENNb250aCgpICsgMSwgLy8gb2ggeW91LCBqYXZhc2NyaXB0LlxuICAgIGRheTogZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgaG91cjogaW5jbHVkZVRpbWUgPyBkYXRlLmdldFVUQ0hvdXJzKCkgOiAwLFxuICAgIG1pbnV0ZTogaW5jbHVkZVRpbWUgPyBkYXRlLmdldFVUQ01pbnV0ZXMoKSA6IDAsXG4gICAgc2Vjb25kOiBpbmNsdWRlVGltZSA/IGRhdGUuZ2V0VVRDU2Vjb25kcygpIDogMCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0ZVN0cmluZyhcbiAgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCB9LFxuICB0aW1lID0gdHJ1ZVxuKSB7XG4gIGNvbnN0IHV0Y1RpbWUgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlKHV0Y1RpbWUpLnRvSlNPTigpO1xuICByZXR1cm4gdGltZSA/IGRhdGV0aW1lIDogZGF0ZXRpbWUuc2xpY2UoMCwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXRjVG9Mb2NhbChqc29uRGF0ZSkge1xuICBpZiAoIWpzb25EYXRlKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvLyByZXF1aXJlZCBmb3JtYXQgb2YgYFwieXl5eS1NTS1kZFRoaDptbVwiIGZvbGxvd2VkIGJ5IG9wdGlvbmFsIFwiOnNzXCIgb3IgXCI6c3MuU1NTXCJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNsb2NhbC1kYXRlLWFuZC10aW1lLXN0YXRlLSh0eXBlJTNEZGF0ZXRpbWUtbG9jYWwpXG4gIC8vID4gc2hvdWxkIGJlIGEgX3ZhbGlkIGxvY2FsIGRhdGUgYW5kIHRpbWUgc3RyaW5nXyAobm90IEdNVClcblxuICAvLyBOb3RlIC0gZGF0ZSBjb25zdHJ1Y3RvciBwYXNzZWQgbG9jYWwgSVNPLTg2MDEgZG9lcyBub3QgY29ycmVjdGx5XG4gIC8vIGNoYW5nZSB0aW1lIHRvIFVUQyBpbiBub2RlIHByZS04XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShqc29uRGF0ZSk7XG5cbiAgY29uc3QgeXl5eSA9IHBhZChkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICBjb25zdCBNTSA9IHBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgY29uc3QgZGQgPSBwYWQoZGF0ZS5nZXREYXRlKCksIDIpO1xuICBjb25zdCBoaCA9IHBhZChkYXRlLmdldEhvdXJzKCksIDIpO1xuICBjb25zdCBtbSA9IHBhZChkYXRlLmdldE1pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNzID0gcGFkKGRhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgY29uc3QgU1NTID0gcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuXG4gIHJldHVybiBgJHt5eXl5fS0ke01NfS0ke2RkfVQke2hofToke21tfToke3NzfS4ke1NTU31gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUb1VUQyhkYXRlU3RyaW5nKSB7XG4gIGlmIChkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVTdHJpbmcpLnRvSlNPTigpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gIGxldCBzID0gU3RyaW5nKG51bSk7XG4gIHdoaWxlIChzLmxlbmd0aCA8IHNpemUpIHtcbiAgICBzID0gXCIwXCIgKyBzO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF0YVVSSXRvQmxvYihkYXRhVVJJKSB7XG4gIC8vIFNwbGl0IG1ldGFkYXRhIGZyb20gZGF0YVxuICBjb25zdCBzcGxpdHRlZCA9IGRhdGFVUkkuc3BsaXQoXCIsXCIpO1xuICAvLyBTcGxpdCBwYXJhbXNcbiAgY29uc3QgcGFyYW1zID0gc3BsaXR0ZWRbMF0uc3BsaXQoXCI7XCIpO1xuICAvLyBHZXQgbWltZS10eXBlIGZyb20gcGFyYW1zXG4gIGNvbnN0IHR5cGUgPSBwYXJhbXNbMF0ucmVwbGFjZShcImRhdGE6XCIsIFwiXCIpO1xuICAvLyBGaWx0ZXIgdGhlIG5hbWUgcHJvcGVydHkgZnJvbSBwYXJhbXNcbiAgY29uc3QgcHJvcGVydGllcyA9IHBhcmFtcy5maWx0ZXIocGFyYW0gPT4ge1xuICAgIHJldHVybiBwYXJhbS5zcGxpdChcIj1cIilbMF0gPT09IFwibmFtZVwiO1xuICB9KTtcbiAgLy8gTG9vayBmb3IgdGhlIG5hbWUgYW5kIHVzZSB1bmtub3duIGlmIG5vIG5hbWUgcHJvcGVydHkuXG4gIGxldCBuYW1lO1xuICBpZiAocHJvcGVydGllcy5sZW5ndGggIT09IDEpIHtcbiAgICBuYW1lID0gXCJ1bmtub3duXCI7XG4gIH0gZWxzZSB7XG4gICAgLy8gQmVjYXVzZSB3ZSBmaWx0ZXJlZCBvdXQgdGhlIG90aGVyIHByb3BlcnR5LFxuICAgIC8vIHdlIG9ubHkgaGF2ZSB0aGUgbmFtZSBjYXNlIGhlcmUuXG4gICAgbmFtZSA9IHByb3BlcnRpZXNbMF0uc3BsaXQoXCI9XCIpWzFdO1xuICB9XG5cbiAgLy8gQnVpbHQgdGhlIFVpbnQ4QXJyYXkgQmxvYiBwYXJhbWV0ZXIgZnJvbSB0aGUgYmFzZTY0IHN0cmluZy5cbiAgY29uc3QgYmluYXJ5ID0gYXRvYihzcGxpdHRlZFsxXSk7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaChiaW5hcnkuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgLy8gQ3JlYXRlIHRoZSBibG9iIG9iamVjdFxuICBjb25zdCBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFtuZXcgVWludDhBcnJheShhcnJheSldLCB7IHR5cGUgfSk7XG5cbiAgcmV0dXJuIHsgYmxvYiwgbmFtZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VTcGVjKHNjaGVtYSkge1xuICBjb25zdCBzcGVjID0ge307XG4gIGlmIChzY2hlbWEubXVsdGlwbGVPZikge1xuICAgIHNwZWMuc3RlcCA9IHNjaGVtYS5tdWx0aXBsZU9mO1xuICB9XG4gIGlmIChzY2hlbWEubWluaW11bSB8fCBzY2hlbWEubWluaW11bSA9PT0gMCkge1xuICAgIHNwZWMubWluID0gc2NoZW1hLm1pbmltdW07XG4gIH1cbiAgaWYgKHNjaGVtYS5tYXhpbXVtIHx8IHNjaGVtYS5tYXhpbXVtID09PSAwKSB7XG4gICAgc3BlYy5tYXggPSBzY2hlbWEubWF4aW11bTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCBvcHRpb25zLCByb290U2NoZW1hKSB7XG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc2tpcCB2YWxpZGF0aW5nIHN1YnNjaGVtYXMgaWYgZm9ybURhdGEgaXMgdW5kZWZpbmVkLiBXZSBqdXN0XG4gIC8vIHdhbnQgdG8gZ2V0IHRoZSBmaXJzdCBvcHRpb24gaW4gdGhhdCBjYXNlLlxuICBpZiAoZm9ybURhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgICAvLyBJZiB0aGUgc2NoZW1hIGRlc2NyaWJlcyBhbiBvYmplY3QgdGhlbiB3ZSBuZWVkIHRvIGFkZCBzbGlnaHRseSBtb3JlXG4gICAgLy8gc3RyaWN0IG1hdGNoaW5nIHRvIHRoZSBzY2hlbWEsIGJlY2F1c2UgdW5sZXNzIHRoZSBzY2hlbWEgdXNlcyB0aGVcbiAgICAvLyBcInJlcXVpcmVzXCIga2V5d29yZCwgYW4gb2JqZWN0IHdpbGwgbWF0Y2ggdGhlIHNjaGVtYSBhcyBsb25nIGFzIGl0XG4gICAgLy8gZG9lc24ndCBoYXZlIG1hdGNoaW5nIGtleXMgd2l0aCBhIGNvbmZsaWN0aW5nIHR5cGUuIFRvIGRvIHRoaXMgd2UgdXNlIGFuXG4gICAgLy8gXCJhbnlPZlwiIHdpdGggYW4gYXJyYXkgb2YgcmVxdWlyZXMuIFRoaXMgYXVnbWVudGF0aW9uIGV4cHJlc3NlcyB0aGF0IHRoZVxuICAgIC8vIHNjaGVtYSBzaG91bGQgbWF0Y2ggaWYgYW55IG9mIHRoZSBrZXlzIGluIHRoZSBzY2hlbWEgYXJlIHByZXNlbnQgb24gdGhlXG4gICAgLy8gb2JqZWN0IGFuZCBwYXNzIHZhbGlkYXRpb24uXG4gICAgaWYgKG9wdGlvbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAvLyBDcmVhdGUgYW4gXCJhbnlPZlwiIHNjaGVtYSB0aGF0IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvZiB0aGUga2V5cyBpbiB0aGVcbiAgICAgIC8vIFwicHJvcGVydGllc1wiIG9iamVjdFxuICAgICAgY29uc3QgcmVxdWlyZXNBbnlPZiA9IHtcbiAgICAgICAgYW55T2Y6IE9iamVjdC5rZXlzKG9wdGlvbi5wcm9wZXJ0aWVzKS5tYXAoa2V5ID0+ICh7XG4gICAgICAgICAgcmVxdWlyZWQ6IFtrZXldLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICBsZXQgYXVnbWVudGVkU2NoZW1hO1xuXG4gICAgICAvLyBJZiB0aGUgXCJhbnlPZlwiIGtleXdvcmQgYWxyZWFkeSBleGlzdHMsIHdyYXAgdGhlIGF1Z21lbnRhdGlvbiBpbiBhbiBcImFsbE9mXCJcbiAgICAgIGlmIChvcHRpb24uYW55T2YpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgb3B0aW9uXG4gICAgICAgIGNvbnN0IHsgLi4uc2hhbGxvd0Nsb25lIH0gPSBvcHRpb247XG5cbiAgICAgICAgaWYgKCFzaGFsbG93Q2xvbmUuYWxsT2YpIHtcbiAgICAgICAgICBzaGFsbG93Q2xvbmUuYWxsT2YgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBcImFsbE9mXCIgYWxyZWFkeSBleGlzdHMsIHNoYWxsb3cgY2xvbmUgdGhlIGFycmF5XG4gICAgICAgICAgc2hhbGxvd0Nsb25lLmFsbE9mID0gc2hhbGxvd0Nsb25lLmFsbE9mLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzaGFsbG93Q2xvbmUuYWxsT2YucHVzaChyZXF1aXJlc0FueU9mKTtcblxuICAgICAgICBhdWdtZW50ZWRTY2hlbWEgPSBzaGFsbG93Q2xvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWdtZW50ZWRTY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb24sIHJlcXVpcmVzQW55T2YpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIFwicmVxdWlyZWRcIiBmaWVsZCBhcyBpdCdzIGxpa2VseSB0aGF0IG5vdCBhbGwgZmllbGRzIGhhdmVcbiAgICAgIC8vIGJlZW4gZmlsbGVkIGluIHlldCwgd2hpY2ggd2lsbCBtZWFuIHRoYXQgdGhlIHNjaGVtYSBpcyBub3QgdmFsaWRcbiAgICAgIGRlbGV0ZSBhdWdtZW50ZWRTY2hlbWEucmVxdWlyZWQ7XG5cbiAgICAgIGlmIChpc1ZhbGlkKGF1Z21lbnRlZFNjaGVtYSwgZm9ybURhdGEsIHJvb3RTY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZChvcHRpb24sIGZvcm1EYXRhLCByb290U2NoZW1hKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBDaGVjayB0byBzZWUgaWYgYSBzY2hlbWEgc3BlY2lmaWVzIHRoYXQgYSB2YWx1ZSBtdXN0IGJlIHRydWVcbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZShzY2hlbWEpIHtcbiAgLy8gQ2hlY2sgaWYgY29uc3QgaXMgYSB0cnV0aHkgdmFsdWVcbiAgaWYgKHNjaGVtYS5jb25zdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW4gZW51bSBoYXMgYSBzaW5nbGUgdmFsdWUgb2YgdHJ1ZVxuICBpZiAoc2NoZW1hLmVudW0gJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxICYmIHNjaGVtYS5lbnVtWzBdID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiBhbnlPZiBoYXMgYSBzaW5nbGUgdmFsdWUsIGV2YWx1YXRlIHRoZSBzdWJzY2hlbWFcbiAgaWYgKHNjaGVtYS5hbnlPZiAmJiBzY2hlbWEuYW55T2YubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKHNjaGVtYS5hbnlPZlswXSk7XG4gIH1cblxuICAvLyBJZiBvbmVPZiBoYXMgYSBzaW5nbGUgdmFsdWUsIGV2YWx1YXRlIHRoZSBzdWJzY2hlbWFcbiAgaWYgKHNjaGVtYS5vbmVPZiAmJiBzY2hlbWEub25lT2YubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKHNjaGVtYS5vbmVPZlswXSk7XG4gIH1cblxuICAvLyBFdmFsdWF0ZSBlYWNoIHN1YnNjaGVtYSBpbiBhbGxPZiwgdG8gc2VlIGlmIG9uZSBvZiB0aGVtIHJlcXVpcmVzIGEgdHJ1ZVxuICAvLyB2YWx1ZVxuICBpZiAoc2NoZW1hLmFsbE9mKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5zb21lKHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiJdfQ==